# RISC-V Purgatory 对齐修复补丁分析

## 基本信息

**Commit ID**: fb197c5d2fd2
**作者**: Daniel Maslowski <cyrevolt@googlemail.com>
**日期**: 2024年7月19日
**标题**: riscv/purgatory: align riscv_kernel_entry
**修复的原始提交**: 736e30af583fb ("RISC-V: Add purgatory")

## 1. 补丁内容详细分析

### 1.1 修改的文件

文件: `arch/riscv/purgatory/entry.S`

### 1.2 具体修改内容

```diff
+#include <asm/asm.h>
 #include <linux/linkage.h>

 .text
@@ -34,6 +35,7 @@ SYM_CODE_END(purgatory_start)

 .data

+.align LGREG
 SYM_DATA(riscv_kernel_entry, .quad 0)
```

**修改说明**:
1. 添加了 `#include <asm/asm.h>` 头文件包含
2. 在 `riscv_kernel_entry` 符号前添加了 `.align LGREG` 对齐指令

### 1.3 LGREG 对齐常量分析

根据 `arch/riscv/include/asm/asm.h` 中的定义:

```c
#define LGREG    __REG_SEL(3, 2)
```

其中 `__REG_SEL` 根据架构位数选择:
- **64位RISC-V**: `LGREG = 3` (即 2^3 = 8字节对齐)
- **32位RISC-V**: `LGREG = 2` (即 2^2 = 4字节对齐)

这确保了 `riscv_kernel_entry` 变量按照寄存器大小进行对齐。

## 2. 问题背景与原理分析

### 2.1 Purgatory 机制

Purgatory 是 kexec 机制中的一个关键组件，运行在两个内核之间:

1. **作用**: 在旧内核关闭后、新内核启动前执行
2. **功能**:
   - 验证新内核镜像的完整性(SHA256校验)
   - 设置新内核的启动参数
   - 跳转到新内核入口点

### 2.2 对齐问题的根本原因

#### 2.2.1 异常处理委托机制

在某些RISC-V系统中(如JH7110 SoC配合oreboot):

1. **SBI异常委托**: SBI(Supervisor Binary Interface)将未对齐访问异常委托给内核处理
2. **内核异常处理**: 内核配置为处理未对齐访问异常
3. **Purgatory环境**: 在purgatory执行期间，异常处理程序已经设置为kexec专用的处理程序

#### 2.2.2 问题场景

```
正常情况:
用户空间/内核 -> 未对齐访问 -> 内核异常处理程序 -> 软件模拟 -> 继续执行

Purgatory环境:
 Purgatory代码 -> 未对齐访问 -> kexec异常处理程序 -> 系统崩溃
```

**关键问题**:
- Purgatory中的kexec异常处理程序无法处理未对齐访问异常
- 如果 `riscv_kernel_entry` 未正确对齐，访问时会触发异常
- 异常无法被正确处理，导致系统崩溃

### 2.3 内存访问对齐要求

#### 2.3.1 RISC-V对齐规则

```c
// 64位系统
.quad 0    // 8字节数据，需要8字节对齐

// 32位系统
.word 0    // 4字节数据，需要4字节对齐
```

#### 2.3.2 访问模式分析

在 `entry.S` 中的关键代码:

```assembly
ld  a2, riscv_kernel_entry  // 64位加载指令
jr  a2                      // 跳转到新内核
```

- `ld` 指令要求8字节对齐的内存访问
- 如果 `riscv_kernel_entry` 未对齐，会触发未对齐访问异常

## 3. 修复方案分析

### 3.1 对齐指令的作用

```assembly
.align LGREG
SYM_DATA(riscv_kernel_entry, .quad 0)
```

**效果**:
- 确保 `riscv_kernel_entry` 按照寄存器大小对齐
- 64位系统: 8字节对齐
- 32位系统: 4字节对齐
- 避免未对齐访问异常的产生

### 3.2 为什么之前没有问题

1. **硬件处理**: 某些RISC-V实现在硬件层面支持未对齐访问
2. **异常处理**: 在正常内核环境中，未对齐访问异常可以被内核处理程序正确处理
3. **编译器对齐**: 在某些情况下，编译器可能自动进行了对齐

### 3.3 特定环境触发条件

该问题在以下环境中被发现:
- **硬件平台**: JH7110 SoC
- **固件**: oreboot
- **SBI配置**: 异常委托给内核
- **内核配置**: 配置为处理未对齐访问异常

## 4. 相关提交分析

### 4.1 原始Purgatory实现 (736e30af583fb)

**引入时间**: 2022年
**作者**: Li Zhengyu (华为)
**目的**: 为RISC-V架构添加kexec支持

**原始代码问题**:
```assembly
.data
.globl riscv_kernel_entry
riscv_kernel_entry:
    .quad   0
```

缺少显式的对齐指令，依赖于编译器的默认行为。

### 4.2 修复提交的改进

1. **显式对齐**: 明确指定对齐要求，不依赖编译器行为
2. **架构适配**: 使用 `LGREG` 宏适配不同位数的RISC-V架构
3. **兼容性**: 确保在各种硬件和固件配置下都能正常工作

## 5. 技术影响与意义

### 5.1 解决的问题

1. **系统稳定性**: 防止kexec过程中的系统崩溃
2. **硬件兼容性**: 支持更多RISC-V硬件平台和固件配置
3. **异常处理**: 避免在purgatory环境中触发无法处理的异常

### 5.2 适用场景

- **系统重启**: kexec快速重启
- **内核调试**: 内核崩溃转储
- **系统升级**: 在线内核更新
- **容器化**: 轻量级虚拟化环境

### 5.3 架构意义

这个修复体现了RISC-V架构的几个重要特点:

1. **模块化设计**: SBI异常委托机制的灵活性
2. **软件处理**: 未对齐访问的软件模拟能力
3. **兼容性要求**: 不同实现之间的兼容性挑战

## 6. 总结

这个看似简单的对齐修复补丁实际上解决了一个复杂的系统级问题。它展示了:

1. **底层细节的重要性**: 内存对齐在系统编程中的关键作用
2. **异常处理的复杂性**: 不同执行环境下异常处理机制的差异
3. **硬件抽象的挑战**: RISC-V作为开放架构面临的兼容性问题
4. **系统级编程的严谨性**: 在关键系统组件中每个细节都至关重要

该修复确保了RISC-V平台上kexec功能的可靠性，特别是在使用异常委托机制的系统中，为RISC-V生态系统的稳定发展做出了贡献。


&i2c3 {
        status = "okay";
        clock-frequency=<100000>;
        no-irq-suspend;
};