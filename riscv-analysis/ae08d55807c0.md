# Patch Analysis: ae08d55807c0 - riscv: Fix kernel crash due to PR_SET_TAGGED_ADDR_CTRL

## 基本信息

- **Commit ID**: ae08d55807c099357c047dba17624b09414635dd
- **作者**: Nam Cao <namcao@linutronix.de>
- **日期**: Sun May 4 12:19:20 2025 +0200
- **标题**: riscv: Fix kernel crash due to PR_SET_TAGGED_ADDR_CTRL
- **修改文件**: arch/riscv/kernel/process.c
- **修改行数**: +3 -0

## 修改内容详细分析

### 1. 问题背景

当用户空间调用`PR_SET_TAGGED_ADDR_CTRL`但Supm扩展不可用时，内核会发生崩溃：

```
Oops - illegal instruction [#1]
    [snip]
epc : set_tagged_addr_ctrl+0x112/0x15a
 ra : set_tagged_addr_ctrl+0x74/0x15a
epc : ffffffff80011ace ra : ffffffff80011a30 sp : ffffffc60039be10
    [snip]
status: 0000000200000120 badaddr: 0000000010a79073 cause: 0000000000000002
    set_tagged_addr_ctrl+0x112/0x15a
    __riscv_sys_prctl+0x352/0x73c
    do_trap_ecall_u+0x17c/0x20c
    andle_exception+0x150/0x15c
```

### 2. 具体修改

在`set_tagged_addr_ctrl()`函数开头添加了对Supm扩展的检查：

```c
long set_tagged_addr_ctrl(struct task_struct *task, unsigned long arg)
{
	unsigned long valid_mask = PR_PMLEN_MASK | PR_TAGGED_ADDR_ENABLE;
	struct thread_info *ti = task_thread_info(task);
	struct mm_struct *mm = task->mm;
	unsigned long pmm;
	u8 pmlen;

+	if (!riscv_has_extension_unlikely(RISCV_ISA_EXT_SUPM))
+		return -EINVAL;
+
	if (is_compat_thread(ti))
		return -EINVAL;
	// ... 其余代码
}
```

### 3. 修改原理分析

#### 3.1 RISCV_ISA_EXT_SUPM扩展

`RISCV_ISA_EXT_SUPM`在`arch/riscv/include/asm/hwcap.h`中定义：

```c
#ifdef CONFIG_RISCV_M_MODE
#define RISCV_ISA_EXT_SUPM		RISCV_ISA_EXT_SMNPM
#else
#define RISCV_ISA_EXT_SUPM		RISCV_ISA_EXT_SSNPM
#endif
```

- **SMNPM (88)**: Supervisor-mode Pointer Masking for Next-level page tables, Machine mode
- **SSNPM (89)**: Supervisor-mode Pointer Masking for Next-level page tables, Supervisor mode

根据当前运行模式（Machine mode或Supervisor mode），`RISCV_ISA_EXT_SUPM`会映射到相应的扩展。

#### 3.2 riscv_has_extension_unlikely()函数

该函数在`arch/riscv/include/asm/cpufeature-macros.h`中定义：

```c
static __always_inline bool riscv_has_extension_unlikely(const unsigned long ext)
{
	compiletime_assert(ext < RISCV_ISA_EXT_MAX, "ext must be < RISCV_ISA_EXT_MAX");

	if (IS_ENABLED(CONFIG_RISCV_ALTERNATIVE))
		return __riscv_has_extension_unlikely(STANDARD_EXT, ext);

	return __riscv_isa_extension_available(NULL, ext);
}
```

该函数使用了两种机制来检查扩展支持：
1. **Alternative机制**: 在编译时或运行时动态替换指令，提供更高效的检查
2. **传统ISA bitmap检查**: 通过`__riscv_isa_extension_available()`检查ISA位图

#### 3.3 `__riscv_has_extension_unlikely()`实现

```c
static __always_inline bool __riscv_has_extension_unlikely(const unsigned long vendor,
							   const unsigned long ext)
{
	asm goto(ALTERNATIVE("nop", "j\t%l[l_yes]", %[vendor], %[ext], 1)
	:
	: [vendor] "i" (vendor), [ext] "i" (ext)
	:
	: l_yes);

	return false;
l_yes:
	return true;
}
```

这个函数使用了RISC-V的Alternative机制：
- 如果扩展不支持：执行`nop`指令，返回`false`
- 如果扩展支持：跳转到`l_yes`标签，返回`true`

### 4. 修复的安全问题

#### 4.1 问题描述

在原始实现（commit 09d6775f503b）中，`set_tagged_addr_ctrl()`函数没有检查Supm扩展是否可用就直接执行了相关操作。当硬件不支持Supm扩展时，函数会尝试访问不存在的CSR寄存器或执行不支持的指令，导致内核崩溃。

#### 4.2 崩溃原因分析

1. **非法指令异常**: 当硬件不支持Supm扩展时，`envcfg_update_bits()`函数中的CSR操作会触发非法指令异常
2. **CSR访问失败**: 尝试访问`CSR_ENVCFG`寄存器的PMM字段，但硬件不支持该功能
3. **异常处理链**: 异常从用户空间系统调用传播到内核，最终导致内核panic

#### 4.3 修复机制

通过在函数开头添加`riscv_has_extension_unlikely(RISCV_ISA_EXT_SUPM)`检查：
- **早期返回**: 如果硬件不支持Supm扩展，立即返回`-EINVAL`
- **避免非法操作**: 防止执行任何可能导致异常的CSR操作
- **用户空间错误处理**: 用户空间程序可以通过返回值判断功能是否可用

### 5. 相关提交分析

#### 5.1 Fixes提交: 09d6775f503b

**标题**: "riscv: Add support for userspace pointer masking"
**作者**: Samuel Holland <samuel.holland@sifive.com>
**日期**: Wed Oct 16 13:27:45 2024 -0700

这个提交引入了RISC-V的用户空间指针掩码支持，实现了：
- `PR_SET_TAGGED_ADDR_CTRL`和`PR_GET_TAGGED_ADDR_CTRL` prctl操作
- 支持可变数量的标签位（PMLEN）
- 线程级别的配置，支持继承和清除

**原始实现的问题**:
```c
long set_tagged_addr_ctrl(struct task_struct *task, unsigned long arg)
{
	unsigned long valid_mask = PR_PMLEN_MASK;
	struct thread_info *ti = task_thread_info(task);
	unsigned long pmm;
	u8 pmlen;

	// 缺少Supm扩展检查！
	if (is_compat_thread(ti))
		return -EINVAL;
	// ... 直接执行CSR操作
}
```

#### 5.2 类似修复: 7f1c3de1370b

在`get_tagged_addr_ctrl()`函数中也有类似的修复，添加了相同的扩展检查。这表明整个tagged address控制API都需要硬件扩展检查。

### 6. 技术细节深入分析

#### 6.1 RISC-V指针掩码机制

RISC-V的指针掩码功能允许在指针的高位存储元数据：
- **PMLEN**: 指定掩码/标签位的数量
- **PMM字段**: 在ENVCFG CSR中配置指针掩码模式
- **用户空间透明**: 硬件自动处理指针掩码，对用户程序透明

#### 6.2 CSR寄存器操作

`envcfg_update_bits()`函数会操作ENVCFG CSR寄存器：
```c
static inline void envcfg_update_bits(struct task_struct *task,
				      unsigned long mask, unsigned long val)
{
	unsigned long envcfg;

	envcfg = (task->thread.envcfg & ~mask) | val;
	task->thread.envcfg = envcfg;
	if (task == current)
		csr_write(CSR_ENVCFG, envcfg);  // 这里会触发异常
}
```

#### 6.3 Alternative机制优势

使用`riscv_has_extension_unlikely()`的优势：
- **编译时优化**: 如果确定不支持，编译器可以优化掉相关代码
- **运行时高效**: 使用分支预测优化，假设扩展不太可能存在
- **动态检测**: 支持运行时检测硬件能力

### 7. 配置选项

在`arch/riscv/Kconfig`中定义了相关配置：

```kconfig
config RISCV_ISA_SUPM
	bool "Supm extension for userspace pointer masking"
	depends on 64BIT
	default y
	help
	  Add support for pointer masking in userspace (Supm) when the
	  underlying hardware extension (Smnpm or Ssnpm) is detected at boot.

	  If this option is disabled, userspace will be unable to use
	  the prctl(PR_{SET,GET}_TAGGED_ADDR_CTRL) API.
```

### 8. 影响和意义

#### 8.1 安全性提升
- **防止内核崩溃**: 避免在不支持的硬件上执行非法指令
- **优雅降级**: 提供明确的错误返回值而不是崩溃
- **系统稳定性**: 确保系统在各种硬件配置下都能稳定运行

#### 8.2 兼容性
- **向后兼容**: 不影响支持Supm扩展的硬件
- **API一致性**: 与ARM64的tagged address实现保持一致
- **错误处理**: 提供标准的错误返回机制

#### 8.3 性能考虑
- **早期检查**: 在函数开头就进行检查，避免不必要的计算
- **分支预测**: 使用`unlikely`暗示这是不太可能的情况
- **Alternative优化**: 利用硬件特性进行高效检查

## 总结

这个patch是一个关键的安全修复，解决了在不支持Supm扩展的RISC-V硬件上调用`PR_SET_TAGGED_ADDR_CTRL`导致的内核崩溃问题。修复方法简洁有效：

1. **根本原因**: 原始实现缺少硬件能力检查
2. **修复方案**: 在函数开头添加`riscv_has_extension_unlikely(RISCV_ISA_EXT_SUPM)`检查
3. **技术优势**: 利用RISC-V的Alternative机制进行高效的硬件能力检测
4. **安全保障**: 防止非法指令异常导致的内核崩溃

这个修复体现了内核开发中"防御性编程"的重要性，特别是在处理硬件特性检测时。通过适当的硬件能力检查，确保了系统在各种硬件配置下的稳定性和安全性。

该patch也展示了RISC-V架构在扩展检测方面的设计优势，能够在编译时和运行时高效地处理不同的硬件能力组合，为操作系统提供了灵活而高效的硬件抽象机制。