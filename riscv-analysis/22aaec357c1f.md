# RISC-V PREEMPT_LAZY 支持分析

## Commit 信息

- **Commit ID**: 22aaec357c1f
- **标题**: riscv: add PREEMPT_LAZY support
- **作者**: Jisheng Zhang <jszhang@kernel.org>
- **提交者**: Peter Zijlstra <peterz@infradead.org>
- **提交日期**: 2024年11月5日
- **邮件列表链接**: https://lkml.kernel.org/r/20241021151257.102296-4-bigeasy@linutronix.de

## 修改概述

这个patch为RISC-V架构添加了PREEMPT_LAZY（懒惰抢占）支持，这是Linux内核调度器的一个重要优化特性。

## 详细修改内容

### 1. Kconfig配置修改

在 `arch/riscv/Kconfig` 中添加了：
```kconfig
select ARCH_HAS_PREEMPT_LAZY
```

这个配置选项表明RISC-V架构支持懒惰抢占功能。

### 2. Thread Info标志位重新排列

在 `arch/riscv/include/asm/thread_info.h` 中进行了以下关键修改：

#### 原始定义：
```c
#define TIF_NOTIFY_RESUME      1       /* callback before returning to user */
#define TIF_SIGPENDING         2       /* signal pending */
#define TIF_NEED_RESCHED       3       /* rescheduling necessary */
```

#### 修改后定义：
```c
#define TIF_NEED_RESCHED       0       /* rescheduling necessary */
#define TIF_NEED_RESCHED_LAZY  1       /* Lazy rescheduling needed */
#define TIF_NOTIFY_RESUME      2       /* callback before returning to user */
#define TIF_SIGPENDING         3       /* signal pending */
```

#### 对应的位掩码定义：
```c
#define _TIF_NEED_RESCHED      (1 << TIF_NEED_RESCHED)
#define _TIF_NEED_RESCHED_LAZY (1 << TIF_NEED_RESCHED_LAZY)
#define _TIF_NOTIFY_RESUME     (1 << TIF_NOTIFY_RESUME)
#define _TIF_SIGPENDING        (1 << TIF_SIGPENDING)
```

## 技术原理分析

### 1. PREEMPT_LAZY的工作机制

PREEMPT_LAZY是一种"懒惰"的抢占机制，它的核心思想是：

- **延迟抢占**: 不立即执行抢占，而是标记需要抢占，在合适的时机再执行
- **减少上下文切换**: 通过延迟抢占减少不必要的上下文切换开销
- **提高缓存效率**: 减少频繁的任务切换，提高CPU缓存命中率

### 2. 标志位重新排列的意义

将`TIF_NEED_RESCHED`移动到位置0有以下优势：

1. **性能优化**: 位置0的检查通常更高效
2. **与其他架构保持一致**: 大多数架构都将`TIF_NEED_RESCHED`放在位置0
3. **为LAZY抢占预留空间**: `TIF_NEED_RESCHED_LAZY`紧跟在后面，便于一起处理

### 3. GENERIC_ENTRY的关键作用

Commit message中提到"riscv has switched to GENERIC_ENTRY"，这是实现PREEMPT_LAZY的前提：

- **统一的入口/出口处理**: GENERIC_ENTRY提供了统一的系统调用和中断处理框架
- **标准化的抢占检查**: 在统一的出口点检查抢占标志
- **简化架构移植**: 使得添加PREEMPT_LAZY支持变得简单

## 相关提交分析

### 1. PREEMPT_AUTO到PREEMPT_LAZY的演进

从commit `4dca1af414fb` 可以看出，这个功能最初叫做PREEMPT_AUTO，后来重命名为PREEMPT_LAZY：

```
rcu: rename PREEMPT_AUTO to PREEMPT_LAZY
```

这个重命名更好地反映了功能的本质 - "懒惰"的抢占策略。

### 2. 其他架构的实现

从相关提交可以看到，多个架构都在添加PREEMPT_LAZY支持：

- **s390架构** (commit `9de3e4bf6cfb`): 类似的实现方式
- **LoongArch架构** (commit `704f06eeff65`): 允许启用PREEMPT_LAZY

这表明PREEMPT_LAZY是一个跨架构的通用优化特性。

## 实现细节

### 1. 最小化修改原则

这个patch的实现非常简洁，只需要：
1. 添加`ARCH_HAS_PREEMPT_LAZY`配置
2. 定义`TIF_NEED_RESCHED_LAZY`标志
3. 重新排列现有标志位

### 2. 向后兼容性

修改保持了向后兼容性：
- 所有现有的标志位都保留
- 只是重新排列了位置
- 添加了新的LAZY标志

## 性能影响分析

### 1. 预期收益

- **减少上下文切换开销**: 通过延迟抢占减少不必要的任务切换
- **提高缓存局部性**: 任务运行时间更长，缓存命中率更高
- **降低调度延迟**: 减少调度器的调用频率

### 2. 潜在风险

- **响应延迟**: 某些情况下可能增加任务响应延迟
- **公平性影响**: 可能影响调度的公平性
- **实时性考虑**: 对实时任务可能有负面影响

## 测试和验证

从相关的RCU torture测试提交可以看出，内核开发者非常重视这个功能的测试：

- `8d608f08017f`: 使TREE07场景构建CONFIG_PREEMPT_LAZY=y
- `118559a9942b`: 使TREE10场景构建CONFIG_PREEMPT_LAZY=y

这确保了PREEMPT_LAZY功能的稳定性和可靠性。

## 总结

这个patch为RISC-V架构添加了PREEMPT_LAZY支持，这是一个重要的调度器优化特性。实现方式简洁高效，充分利用了RISC-V已有的GENERIC_ENTRY基础设施。这个功能有望在保持系统响应性的同时，提高整体性能，特别是在高负载场景下减少不必要的上下文切换开销。

该patch是Linux内核调度器持续优化的一个重要里程碑，展现了内核开发社区对性能优化的不懈追求。