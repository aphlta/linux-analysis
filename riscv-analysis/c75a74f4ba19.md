# RISC-V Memory Hotplug Support Patch Analysis

## Commit Information

**Commit ID:** c75a74f4ba19c904c0ae1e011ae2568449409ae4  
**Author:** Björn Töpel <bjorn@rivosinc.com>  
**Date:** Wed Jun 5 13:40:49 2024 +0200  
**Committer:** Palmer Dabbelt <palmer@rivosinc.com>  
**Commit Date:** Wed Jun 26 08:42:42 2024 -0700  
**Subject:** riscv: mm: Add memory hotplugging support

## Patch Overview

这个patch为RISC-V架构添加了内存热插拔(memory hotplugging)支持，这是一个重要的内存管理功能，允许在系统运行时动态添加和移除内存。

## 详细修改内容

### 修改文件
- `arch/riscv/mm/init.c` - 新增267行代码

### 新增的核心函数

#### 1. 页表释放函数

```c
// 释放PTE页表
static void __meminit free_pte_table(pte_t *pte_start, pmd_t *pmd)

// 释放PMD页表  
static void __meminit free_pmd_table(pmd_t *pmd_start, pud_t *pud)

// 释放PUD页表
static void __meminit free_pud_table(pud_t *pud_start, p4d_t *p4d)
```

这些函数负责在内存热移除时释放各级页表结构，确保内存资源得到正确回收。

#### 2. vmemmap存储释放函数

```c
static void __meminit free_vmemmap_storage(struct page *page, size_t size,
                                         struct vmem_altmap *altmap)
```

处理vmemmap区域的内存释放，支持两种分配方式：
- 标准内存分配器分配的页面
- 通过vmem_altmap分配的页面（用于持久内存）

#### 3. 页表映射移除函数

```c
// 移除PTE映射
static void __meminit remove_pte_mapping(pte_t *pte_base, unsigned long addr,
                                       unsigned long end, bool is_vmemmap,
                                       struct vmem_altmap *altmap)

// 移除PMD映射
static void __meminit remove_pmd_mapping(pmd_t *pmd_base, unsigned long addr,
                                       unsigned long end, bool is_vmemmap,
                                       struct vmem_altmap *altmap)

// 移除PUD映射
static void __meminit remove_pud_mapping(pud_t *pud_base, unsigned long addr,
                                       unsigned long end, bool is_vmemmap,
                                       struct vmem_altmap *altmap)

// 移除P4D映射
static void __meminit remove_p4d_mapping(p4d_t *p4d_base, unsigned long addr,
                                        unsigned long end, bool is_vmemmap,
                                        struct vmem_altmap *altmap)

// 移除PGD映射
static void __meminit remove_pgd_mapping(unsigned long va, unsigned long end,
                                        bool is_vmemmap, struct vmem_altmap *altmap)
```

这些函数实现了完整的页表层次结构拆除，支持大页映射的处理。

#### 4. 线性映射管理

```c
static void __meminit remove_linear_mapping(phys_addr_t start, u64 size)
```

移除指定物理地址范围的线性映射。

#### 5. 架构特定的内存热插拔接口

```c
// 获取可映射范围
struct range arch_get_mappable_range(void)

// 添加内存
int __ref arch_add_memory(int nid, u64 start, u64 size, struct mhp_params *params)

// 移除内存
void __ref arch_remove_memory(u64 start, u64 size, struct vmem_altmap *altmap)

// 释放vmemmap
void __ref vmemmap_free(unsigned long start, unsigned long end, struct vmem_altmap *altmap)
```

## 技术原理分析

### 1. 内存热插拔架构

内存热插拔需要架构提供以下关键回调函数：

- **arch_add_memory()**: 负责将物理内存添加到直接映射中，并调用通用内存热插拔代码
- **arch_remove_memory()**: arch_add_memory()的逆操作
- **vmemmap_free()**: 拆除vmemmap映射并释放backing页面
- **arch_get_mappable_range()**: 返回直接映射可以映射的物理地址范围

### 2. 页表管理策略

#### 页表拆除流程
1. 从PGD级别开始，逐级向下遍历页表
2. 检查每个页表项是否存在和是否为大页映射
3. 对于普通映射，递归处理下一级页表
4. 对于大页映射，直接处理当前级别
5. 在适当时机释放空的页表页面

#### 内存释放策略
- 区分vmemmap区域和普通线性映射区域
- 支持vmem_altmap机制（用于持久内存设备）
- 正确处理页表页面的释放（区分保留页面和普通页面）

### 3. TLB管理

在页表修改完成后，调用`flush_tlb_all()`确保TLB缓存的一致性，这对于内存热插拔的正确性至关重要。

### 4. 错误处理

在`arch_add_memory()`中，如果`__add_pages()`失败，会调用`remove_linear_mapping()`回滚已创建的映射，确保系统状态的一致性。

## 相关提交分析

这个patch是RISC-V内存热插拔支持patch系列的核心部分，相关提交包括：

### 前置准备提交

1. **e3ecf2fdc8f3** - "riscv: mm: Properly forward vmemmap_populate() altmap parameter"
   - 正确转发vmemmap_populate()的altmap参数

2. **66673099f734** - "riscv: mm: Pre-allocate vmemmap/direct map/kasan PGD entries"
   - 预分配vmemmap/直接映射/kasan的PGD条目

3. **fe122b89da67** - "riscv: mm: Change attribute from __init to __meminit for page functions"
   - 将页面函数的属性从__init改为__meminit

4. **007480fe84a9** - "riscv: mm: Refactor create_linear_mapping_range() for memory hot add"
   - 重构create_linear_mapping_range()以支持内存热添加

5. **6e6c5e21b8cb** - "riscv: mm: Add pfn_to_kaddr() implementation"
   - 添加pfn_to_kaddr()实现

### 后续启用提交

6. **37992b7f1097** - "riscv: mm: Take memory hotplug read-lock during kernel page table dump"
   - 在内核页表转储期间获取内存热插拔读锁

7. **f8c2a240556e** - "riscv: Enable memory hotplugging for RISC-V"
   - 为RISC-V启用内存热插拔功能

8. **0546d7043e55** - "virtio-mem: Enable virtio-mem for RISC-V"
   - 为RISC-V启用virtio-mem

9. **216e04bf1e4d** - "riscv: mm: Add support for ZONE_DEVICE"
   - 添加ZONE_DEVICE支持

10. **4705c1571ad3** - "riscv: Enable DAX VMEMMAP optimization"
    - 启用DAX VMEMMAP优化

### 整合提交

11. **60a6707f582e** - "Merge patch series 'riscv: Memory Hot(Un)Plug support'"
    - 合并整个内存热插拔支持patch系列

## 代码设计亮点

### 1. 借鉴x86架构

页表拆除函数大量借鉴了x86架构的实现，这确保了代码的成熟性和可靠性。

### 2. 统一的映射移除接口

`remove_pgd_mapping()`函数同时用于`vmemmap_free()`和`arch_remove_memory()`，但在后者中不移除backing页面，体现了良好的代码复用设计。

### 3. 完整的错误处理

在内存添加失败时能够正确回滚，确保系统状态的一致性。

### 4. 支持多种内存类型

通过vmem_altmap机制支持持久内存设备，增强了系统的灵活性。

## 影响和意义

1. **虚拟化支持**: 使RISC-V能够支持virtio-mem等虚拟化内存管理技术
2. **云计算**: 为RISC-V在云计算环境中的应用提供了重要基础设施
3. **内存管理**: 完善了RISC-V的内存管理子系统
4. **生态系统**: 进一步缩小了RISC-V与其他成熟架构在功能上的差距

## 测试和验证

根据patch系列的描述，可以通过QEMU进行测试：

```bash
# 内存热添加测试
(qemu) object_add memory-backend-ram,id=mem1,size=1G
(qemu) device_add pc-dimm,id=dimm1,memdev=mem1

# 内存热移除测试
# 使用不同大小的内存后端进行测试
```

## 总结

这个patch为RISC-V架构添加了完整的内存热插拔支持，实现了与x86等成熟架构相当的功能。代码设计合理，错误处理完善，为RISC-V在服务器和云计算领域的应用奠定了重要基础。通过这个patch系列，RISC-V在内存管理方面又向前迈进了一大步。