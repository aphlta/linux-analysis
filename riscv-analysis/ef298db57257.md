# RISC-V boot_cpu_hartid 导出分析

## Commit 信息

**Commit ID:** ef298db572577a08185bedd406e4cdde6fe70651  
**作者:** Klara Modin <klarasmodin@gmail.com>  
**日期:** Tue Jun 17 14:58:47 2025 +0200  
**标题:** riscv: export boot_cpu_hartid  
**上游Commit:** c5136add3f9b4c23b8bbe5f4d722c95d4cfb936e  

## 问题背景

### 根本原因

Microchip Inter-processor Communication (IPC) mailbox控制器驱动可以被编译为模块。该驱动使用`cpuid_to_hartid_map()`函数来获取hart ID，而commit 4783ce32b080 ("riscv: export __cpuid_to_hartid_map")已经使得SMP配置下的模块编译成为可能。

然而，在非SMP内核中，`cpuid_to_hartid_map()`函数的实现有所不同：

```c
// SMP配置下
#define cpuid_to_hartid_map(cpu)    __cpuid_to_hartid_map[cpu]

// 非SMP配置下
static inline unsigned long cpuid_to_hartid_map(int cpu)
{
    return boot_cpu_hartid;
}
```

### 技术细节

1. **SMP vs 非SMP差异**: 
   - SMP配置：使用`__cpuid_to_hartid_map`数组存储所有CPU的hart ID映射
   - 非SMP配置：直接返回`boot_cpu_hartid`，因为只有一个CPU

2. **模块编译问题**: 
   - SMP配置下，`__cpuid_to_hartid_map`已通过commit 4783ce32b080导出
   - 非SMP配置下，`boot_cpu_hartid`未导出，导致模块编译失败

3. **驱动使用场景**: Microchip IPC驱动在非SMP配置下仍然有用，因为它用于处理器间通信

## 代码修改分析

### 修改内容

```c
// arch/riscv/kernel/setup.c
unsigned long boot_cpu_hartid;
+EXPORT_SYMBOL_GPL(boot_cpu_hartid);
```

### 关键变化

1. **符号导出**: 添加`EXPORT_SYMBOL_GPL(boot_cpu_hartid)`
2. **模块支持**: 使得非SMP配置下的模块也能访问`boot_cpu_hartid`
3. **一致性**: 保持SMP和非SMP配置下模块编译的一致性

## 相关代码分析

### cpuid_to_hartid_map实现

在`arch/riscv/include/asm/smp.h`中：

```c
#ifdef CONFIG_SMP
extern unsigned long __cpuid_to_hartid_map[NR_CPUS];
#define cpuid_to_hartid_map(cpu)    __cpuid_to_hartid_map[cpu]
#else
static inline unsigned long cpuid_to_hartid_map(int cpu)
{
    return boot_cpu_hartid;
}
#endif
```

### Microchip IPC驱动使用

在`drivers/mailbox/mailbox-mchp-ipc-sbi.c`中：

```c
// 中断处理中使用
for_each_online_cpu(i) {
    hartid = cpuid_to_hartid_map(i);
    if (irq == ipc->cluster_cfg[hartid].irq)
        break;
}

// 中断注册中使用
for_each_online_cpu(cpuid) {
    hartid = cpuid_to_hartid_map(cpuid);
    // ...
}
```

## 依赖关系分析

### 相关提交

1. **commit 4783ce32b080**: "riscv: export __cpuid_to_hartid_map"
   - 导出`__cpuid_to_hartid_map`数组
   - 使SMP配置下的模块编译成为可能

2. **commit e4b1d67e7141**: "mailbox: add Microchip IPC support"
   - 引入Microchip IPC驱动
   - 该驱动需要使用`cpuid_to_hartid_map()`

### 修复链条

```
Microchip IPC驱动引入 (e4b1d67e7141)
         ↓
需要cpuid_to_hartid_map()访问
         ↓
SMP配置: 导出__cpuid_to_hartid_map (4783ce32b080)
         ↓
非SMP配置: 需要导出boot_cpu_hartid (ef298db57257)
```

## 设计考虑

### 符号导出策略

1. **GPL导出**: 使用`EXPORT_SYMBOL_GPL()`而非`EXPORT_SYMBOL()`
2. **内核内部**: `boot_cpu_hartid`是内核内部变量，适合GPL导出
3. **一致性**: 与`__cpuid_to_hartid_map`的导出策略保持一致

### 兼容性影响

1. **向后兼容**: 不影响现有代码
2. **模块支持**: 扩展了模块编译的支持范围
3. **配置无关**: 统一了SMP和非SMP配置的行为

## 验证方法

### 编译测试

```bash
# 非SMP配置下编译Microchip IPC驱动为模块
make ARCH=riscv defconfig
# 禁用SMP
echo "# CONFIG_SMP is not set" >> .config
# 启用Microchip IPC驱动为模块
echo "CONFIG_MAILBOX_MCHP_IPC=m" >> .config
make ARCH=riscv olddefconfig
make ARCH=riscv modules
```

### 运行时测试

```bash
# 加载模块
modprobe mailbox-mchp-ipc-sbi
# 检查模块是否正常加载
lsmod | grep mchp
```

## 安全考虑

### 信息泄露风险

1. **hart ID暴露**: `boot_cpu_hartid`包含硬件信息
2. **GPL限制**: 通过GPL导出限制了使用范围
3. **只读访问**: 模块只能读取，不能修改

### 最小权限原则

1. **必要导出**: 仅导出必需的符号
2. **GPL保护**: 限制在GPL兼容的模块中使用
3. **文档说明**: 明确使用场景和限制

## 结论

这个patch通过导出`boot_cpu_hartid`符号，解决了Microchip IPC驱动在非SMP配置下无法编译为模块的问题。修复方案简单直接，保持了与SMP配置的一致性，是一个必要且合理的修复。

### 关键要点

1. **问题根源**: 非SMP配置下`cpuid_to_hartid_map()`依赖未导出的`boot_cpu_hartid`
2. **解决方案**: 导出`boot_cpu_hartid`符号供模块使用
3. **影响范围**: 仅影响模块编译，不改变运行时行为
4. **设计原则**: 保持SMP和非SMP配置的一致性

这个修复确保了Microchip IPC驱动在所有RISC-V配置下都能正常编译和使用，提高了驱动的可用性和系统的灵活性。