# RISC-V Tagged Address ABI Ptrace控制支持分析

## Commit基本信息

- **Commit ID**: 78844482a1c9
- **作者**: Samuel Holland <samuel.holland@sifive.com>
- **提交日期**: Wed Oct 16 13:27:47 2024 -0700
- **标题**: riscv: Allow ptrace control of the tagged address ABI
- **审核者**: Charlie Jenkins <charlie@rivosinc.com>
- **测试者**: Charlie Jenkins <charlie@rivosinc.com>
- **链接**: https://lore.kernel.org/r/20241016202814.4061541-7-samuel.holland@sifive.com
- **维护者**: Palmer Dabbelt <palmer@rivosinc.com>

## 修改概述

这个patch为RISC-V架构添加了通过ptrace接口控制tagged address ABI的支持，类似于arm64架构的实现。该功能允许调试器和其他工具通过ptrace系统调用来查询和设置进程的tagged address控制状态。

## 修改的文件

1. **arch/riscv/kernel/ptrace.c** - 添加tagged address控制的ptrace支持
2. **include/uapi/linux/elf.h** - 定义新的ELF note类型

## 详细修改内容分析

### 1. ptrace.c中的修改

#### 1.1 新增REGSET_TAGGED_ADDR_CTRL

```c
#ifdef CONFIG_RISCV_ISA_SUPM
enum riscv_regset {
    REGSET_X,
#ifdef CONFIG_FPU
    REGSET_F,
#endif
#ifdef CONFIG_RISCV_ISA_V
    REGSET_V,
#endif
    REGSET_TAGGED_ADDR_CTRL,  // 新增
};
#endif
```

**作用**: 为tagged address控制添加新的寄存器集类型，使其能够通过ptrace的NT_RISCV_TAGGED_ADDR_CTRL note进行访问。

#### 1.2 tagged_addr_ctrl_get函数

```c
static int tagged_addr_ctrl_get(struct task_struct *target,
                               const struct user_regset *regset,
                               struct membuf *to)
{
    long ctrl = get_tagged_addr_ctrl(target);

    if (IS_ERR_VALUE(ctrl))
        return ctrl;

    return membuf_write(to, &ctrl, sizeof(ctrl));
}
```

**功能分析**:
- 调用`get_tagged_addr_ctrl()`获取目标进程的tagged address控制状态
- 将控制状态写入到ptrace的输出缓冲区
- 错误处理：如果获取失败则返回错误码

#### 1.3 tagged_addr_ctrl_set函数

```c
static int tagged_addr_ctrl_set(struct task_struct *target,
                               const struct user_regset *regset,
                               unsigned int pos, unsigned int count,
                               const void *kbuf, const void __user *ubuf)
{
    int ret;
    long ctrl;

    ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &ctrl, 0, sizeof(ctrl));
    if (ret)
        return ret;

    return set_tagged_addr_ctrl(target, ctrl);
}
```

**功能分析**:
- 从用户空间或内核空间复制新的控制值
- 调用`set_tagged_addr_ctrl()`设置目标进程的tagged address控制状态
- 错误处理：复制失败或设置失败都会返回相应错误码

#### 1.4 riscv_user_regset数组更新

```c
static const struct user_regset riscv_user_regset[] = {
    // ... 其他regset ...
#ifdef CONFIG_RISCV_ISA_SUPM
    [REGSET_TAGGED_ADDR_CTRL] = {
        .core_note_type = NT_RISCV_TAGGED_ADDR_CTRL,
        .n = 1,
        .size = sizeof(long),
        .align = sizeof(long),
        .regset_get = tagged_addr_ctrl_get,
        .set = tagged_addr_ctrl_set,
    },
#endif
};
```

**配置说明**:
- **core_note_type**: 使用新定义的`NT_RISCV_TAGGED_ADDR_CTRL` ELF note类型
- **n**: 1个寄存器（控制字）
- **size/align**: 都是`sizeof(long)`，在64位系统上是8字节
- **regset_get/set**: 分别指向上面定义的get和set函数

### 2. include/uapi/linux/elf.h中的修改

```c
#define NT_RISCV_TAGGED_ADDR_CTRL 0x902        /* RISC-V tagged address control (prctl()) */
```

**作用**: 定义RISC-V架构特定的ELF note类型，用于标识tagged address控制信息。

**技术细节**:
- **值0x902**: 在RISC-V架构保留的note类型范围内（0x900-0x9ff）
- **位置**: 位于NT_RISCV_CSR (0x900)和NT_RISCV_VECTOR (0x901)之后
- **用途**: 用于core dump和ptrace操作中标识tagged address控制状态
- **兼容性**: 与其他架构的类似定义保持一致的命名模式

## 技术原理分析

### 1. Ptrace接口集成

这个patch将tagged address控制功能集成到了Linux的ptrace框架中，使得：

- **调试器支持**: GDB等调试器可以查询和修改被调试进程的tagged address设置
- **进程监控**: 系统监控工具可以检查进程的pointer masking状态
- **动态控制**: 可以在运行时动态修改进程的tagged address行为

### 2. 与ARM64的一致性

该实现参考了ARM64的tagged address ptrace支持，保持了接口的一致性：

- 使用相同的regset模式
- 类似的get/set函数结构
- 统一的错误处理机制

### 3. 安全性考虑

- **权限检查**: ptrace操作需要适当的权限（通常是CAP_SYS_PTRACE）
- **进程状态验证**: 确保目标进程处于可被ptrace的状态
- **参数验证**: 在set操作中验证传入的控制值的有效性

## RISC-V SUPM扩展技术原理

### 1. SUPM扩展概述

**SUPM (Supervisor-mode User-mode Pointer Masking)** 是RISC-V的一个扩展，允许在用户模式下进行指针掩码操作。

### 2. Pointer Masking机制

#### 2.1 ENVCFG.PMM字段

```c
#define ENVCFG_PMM_PMLEN_0     0x0UL
#define ENVCFG_PMM_PMLEN_7     0x1UL  
#define ENVCFG_PMM_PMLEN_16    0x3UL
```

- **PMLEN_0**: 禁用pointer masking
- **PMLEN_7**: 掩码长度为7位（虚拟地址的高7位被忽略）
- **PMLEN_16**: 掩码长度为16位（虚拟地址的高16位被忽略）

#### 2.2 工作原理

1. **地址转换**: 当启用pointer masking时，CPU在地址转换前自动清除虚拟地址的高位
2. **标签保留**: 高位可以用作指针标签，不影响内存访问
3. **模式控制**: 通过ENVCFG CSR控制用户模式的pointer masking行为

### 3. Tagged Address ABI实现

#### 3.1 核心函数分析

**get_tagged_addr_ctrl()函数**:
```c
long get_tagged_addr_ctrl(struct task_struct *task)
{
    // 从task->thread.envcfg提取PMLEN设置
    switch (task->thread.envcfg & ENVCFG_PMM) {
    case ENVCFG_PMM_PMLEN_7:
        ret = FIELD_PREP(PR_PMLEN_MASK, PMLEN_7);
        break;
    case ENVCFG_PMM_PMLEN_16:
        ret = FIELD_PREP(PR_PMLEN_MASK, PMLEN_16);
        break;
    }
    
    // 检查是否启用tagged address ABI
    if (task->mm->context.pmlen)
        ret |= PR_TAGGED_ADDR_ENABLE;
        
    return ret;
}
```

**set_tagged_addr_ctrl()函数**:
```c
long set_tagged_addr_ctrl(struct task_struct *task, unsigned long arg)
{
    // 验证参数有效性
    if (arg & ~valid_mask)
        return -EINVAL;
        
    // 检查全局禁用标志
    if (tagged_addr_disabled)
        return -EINVAL;
        
    // 设置ENVCFG.PMM和mm->context.pmlen
    // ...
}
```

#### 3.2 系统控制

**Sysctl接口**:
```c
static struct ctl_table tagged_addr_sysctl_table[] = {
    {
        .procname = "tagged_addr_disabled",
        .data = &tagged_addr_disabled,
        .maxlen = sizeof(int),
        .proc_handler = proc_dointvec_minmax,
    },
};
```

- **路径**: `/proc/sys/abi/tagged_addr_disabled`
- **功能**: 全局禁用tagged address ABI
- **影响**: 仅阻止新的prctl()调用，不影响已启用的进程

## 依赖关系

这个patch依赖于以下前置提交：

1. **2e1743085887**: "riscv: Add support for the tagged address ABI" - 提供了基础的tagged address ABI支持和get/set函数实现
2. **09d6775f503b**: "riscv: Add support for userspace pointer masking" - 实现了用户空间pointer masking和PMLEN检测
3. **29eedc7d1587**: "riscv: Add CSR definitions for pointer masking" - 定义了相关的CSR寄存器常量

## Prctl接口扩展

### 1. RISC-V特定的Prctl参数

```c
/* RISC-V pointer masking tag length */
# define PR_PMLEN_SHIFT                24
# define PR_PMLEN_MASK                 (0x7fUL << PR_PMLEN_SHIFT)
```

**参数说明**:
- **PR_PMLEN_SHIFT**: PMLEN字段在prctl参数中的位移（第24位开始）
- **PR_PMLEN_MASK**: PMLEN字段的掩码（7位宽度，支持0-127的值）
- **PR_TAGGED_ADDR_ENABLE**: 启用tagged address ABI的标志位

### 2. 用户空间API使用示例

```c
#include <sys/prctl.h>

// 启用7位pointer masking
long ctrl = PR_TAGGED_ADDR_ENABLE | (7 << PR_PMLEN_SHIFT);
int ret = prctl(PR_SET_TAGGED_ADDR_CTRL, ctrl, 0, 0, 0);

// 查询当前设置
long current = prctl(PR_GET_TAGGED_ADDR_CTRL, 0, 0, 0, 0);
if (current & PR_TAGGED_ADDR_ENABLE) {
    int pmlen = (current & PR_PMLEN_MASK) >> PR_PMLEN_SHIFT;
    printf("Tagged address enabled with PMLEN=%d\n", pmlen);
}
```

## 使用场景

### 1. 调试和开发工具

- **GDB集成**: 调试器可以通过ptrace查询和修改被调试进程的tagged address设置
- **性能分析**: 分析工具可以监控pointer masking对性能的影响
- **内存调试**: 工具可以利用指针标签进行内存错误检测

### 2. 安全应用

- **CFI (Control Flow Integrity)**: 使用指针标签验证控制流转移的合法性
- **内存安全**: 标签可以用于标识不同类型的内存区域
- **沙箱技术**: 限制进程访问特定标记的内存区域

### 3. 系统管理

- **安全审计**: 安全工具可以检查进程是否启用了tagged address功能
- **策略控制**: 通过sysctl全局禁用tagged address功能
- **兼容性管理**: 为不支持tagged address的应用提供兼容模式

### 4. 测试和验证

- **自动化测试**: 验证tagged address功能的正确性
- **回归测试**: 确保新版本内核的兼容性
- **性能基准**: 测试pointer masking对系统性能的影响

## 与ARM64的对比

| 特性 | ARM64 | RISC-V |
|------|-------|--------|
| 扩展名称 | MTE/TBI | SUPM |
| 标签位数 | 4位(MTE)/8位(TBI) | 7位/16位 |
| 控制寄存器 | TCR_EL1 | ENVCFG |
| Prctl接口 | 相同 | 相同 |
| ELF Note | NT_ARM_TAGGED_ADDR_CTRL | NT_RISCV_TAGGED_ADDR_CTRL |

## 安全考虑

### 1. 权限控制

- **Ptrace权限**: 需要CAP_SYS_PTRACE能力或进程关系
- **进程状态**: 目标进程必须处于可ptrace状态
- **参数验证**: 严格验证传入的控制参数

### 2. 兼容性保护

- **Compat模式**: 32位进程不支持tagged address
- **扩展检测**: 运行时检查SUPM扩展支持
- **向后兼容**: 不影响现有应用程序

## 总结

这个patch是RISC-V tagged address ABI支持的重要组成部分，它提供了标准的ptrace接口来控制和查询tagged address功能。主要贡献包括：

1. **标准化接口**: 与ARM64保持一致的ptrace接口设计
2. **工具链支持**: 为调试器和分析工具提供必要的API
3. **安全增强**: 支持基于指针标签的安全机制
4. **系统集成**: 完善的错误处理和权限控制

该功能的加入使得RISC-V在支持现代内存管理特性方面更加完善，为安全应用和调试工具提供了强大的基础设施。