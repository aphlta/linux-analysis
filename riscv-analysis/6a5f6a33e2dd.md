# Patch Analysis: 6a5f6a33e2dd

## 基本信息

**Commit ID**: 6a5f6a33e2dd45c7fd7a9560b51d4448166d98b0  
**标题**: riscv: misaligned: declare misaligned_access_speed under CONFIG_RISCV_MISALIGNED  
**作者**: Clément Léger <cleger@rivosinc.com>  
**日期**: Fri May 23 12:19:25 2025 +0200  
**上游Commit**: 1317045a7d6f397904d105f6d40dc9787876a34b  

## 问题描述

这个patch修复了一个编译配置问题。`misaligned_access_speed`变量在一个使用`CONFIG_RISCV_MISALIGNED`编译的文件中定义，但其声明却在`CONFIG_RISCV_SCALAR_MISALIGNED`配置下。这导致在使用`CONFIG_RISCV_MISALIGNED`编译的文件中使用该变量时出现编译问题。

## 修改内容详细分析

### 1. 头文件修改 (arch/riscv/include/asm/cpufeature.h)

**修改前**:
```c
#if defined(CONFIG_RISCV_SCALAR_MISALIGNED)
void check_unaligned_access_emulated(struct work_struct *work __always_unused);
void unaligned_emulation_finish(void);
bool unaligned_ctl_available(void);
DECLARE_PER_CPU(long, misaligned_access_speed);  // 在这里声明
#else
static inline bool unaligned_ctl_available(void)
{
	return false;
}
#endif
```

**修改后**:
```c
#if defined(CONFIG_RISCV_SCALAR_MISALIGNED)
void check_unaligned_access_emulated(struct work_struct *work __always_unused);
void unaligned_emulation_finish(void);
bool unaligned_ctl_available(void);
#else
static inline bool unaligned_ctl_available(void)
{
	return false;
}
#endif

#if defined(CONFIG_RISCV_MISALIGNED)
DECLARE_PER_CPU(long, misaligned_access_speed);  // 移动到这里
#endif
```

### 2. 源文件修改 (arch/riscv/kernel/traps_misaligned.c)

**修改前**:
```c
static int handle_scalar_misaligned_load(struct pt_regs *regs)
{
	// ... 其他代码 ...
	perf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, regs, addr);

#ifdef CONFIG_RISCV_PROBE_UNALIGNED_ACCESS
	*this_cpu_ptr(&misaligned_access_speed) = RISCV_HWPROBE_MISALIGNED_SCALAR_EMULATED;
#endif

	if (!unaligned_enabled)
		return -1;
	// ... 其他代码 ...
}
```

**修改后**:
```c
static int handle_scalar_misaligned_load(struct pt_regs *regs)
{
	// ... 其他代码 ...
	perf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, regs, addr);

	*this_cpu_ptr(&misaligned_access_speed) = RISCV_HWPROBE_MISALIGNED_SCALAR_EMULATED;

	if (!unaligned_enabled)
		return -1;
	// ... 其他代码 ...
}
```

## 代码修改原理

### 1. 配置依赖关系

在RISC-V架构中，存在以下配置选项的层次关系：

- `CONFIG_RISCV_MISALIGNED`: 基础的misaligned访问支持配置
- `CONFIG_RISCV_SCALAR_MISALIGNED`: 标量misaligned访问支持，依赖于`CONFIG_RISCV_MISALIGNED`
- `CONFIG_RISCV_VECTOR_MISALIGNED`: 向量misaligned访问支持，也依赖于`CONFIG_RISCV_MISALIGNED`

### 2. 变量定义和使用

`misaligned_access_speed`变量在`arch/riscv/kernel/unaligned_access_speed.c`中定义：
```c
DEFINE_PER_CPU(long, misaligned_access_speed) = RISCV_HWPROBE_MISALIGNED_SCALAR_UNKNOWN;
```

这个文件是在`CONFIG_RISCV_MISALIGNED`配置下编译的，而不是`CONFIG_RISCV_SCALAR_MISALIGNED`。

### 3. 编译问题的根源

当`CONFIG_RISCV_MISALIGNED=y`但`CONFIG_RISCV_SCALAR_MISALIGNED=n`时：
- 变量`misaligned_access_speed`会被定义（因为unaligned_access_speed.c被编译）
- 但变量声明不可见（因为在`CONFIG_RISCV_SCALAR_MISALIGNED`条件下）
- 导致在traps_misaligned.c中使用该变量时出现编译错误

## 修复策略

1. **移动变量声明**: 将`DECLARE_PER_CPU(long, misaligned_access_speed)`从`CONFIG_RISCV_SCALAR_MISALIGNED`条件移动到`CONFIG_RISCV_MISALIGNED`条件下

2. **移除条件编译**: 在traps_misaligned.c中移除对`CONFIG_RISCV_PROBE_UNALIGNED_ACCESS`的检查，因为现在变量声明在正确的配置条件下总是可用

## 相关提交分析

这个patch是一个修复性提交，解决了配置系统中的不一致性。它确保了：

1. **配置一致性**: 变量的声明和定义都在相同的配置条件下
2. **编译兼容性**: 消除了特定配置组合下的编译错误
3. **代码简化**: 移除了不必要的条件编译检查

## 影响范围

- **正面影响**: 修复了编译错误，提高了配置系统的一致性
- **风险评估**: 低风险，只是重新组织了现有代码，没有改变功能逻辑
- **测试覆盖**: 经过了Charlie Jenkins的测试和Andrew Jones的审查

## 总结

这是一个典型的配置系统修复patch，解决了变量声明和定义在不同配置条件下的不一致问题。修复方法简洁有效，通过重新组织条件编译指令，确保了代码在所有有效配置组合下都能正确编译。这种类型的修复对于维护大型项目的配置系统一致性非常重要。