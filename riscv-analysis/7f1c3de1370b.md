# Patch Analysis: 7f1c3de1370b - riscv: Disallow PR_GET_TAGGED_ADDR_CTRL without Supm

## 基本信息

- **Commit ID**: 7f1c3de1370bc6a8ad5157336b258067dac0ae9c
- **标题**: riscv: Disallow PR_GET_TAGGED_ADDR_CTRL without Supm
- **修改文件**: arch/riscv/kernel/process.c
- **修改行数**: +3 -0

## 修改内容详细分析

### 1. 问题背景

在RISC-V架构中，pointer masking（指针掩码）功能通过Supm扩展提供支持。该功能允许用户空间程序使用tagged addresses，即在指针的高位存储额外的元数据信息。Linux内核通过`prctl()`系统调用的`PR_SET_TAGGED_ADDR_CTRL`和`PR_GET_TAGGED_ADDR_CTRL`选项来控制这一功能。

### 2. 具体修改

在`get_tagged_addr_ctrl()`函数中添加了对`RISCV_ISA_EXT_SUPM`扩展的检查：

```c
static int get_tagged_addr_ctrl(struct task_struct *task)
{
+	if (!riscv_has_extension_unlikely(RISCV_ISA_EXT_SUPM))
+		return -EINVAL;
+
	unsigned long ret = 0;
	// ... 其余代码
}
```

### 3. 修改原理分析

#### 3.1 RISCV_ISA_EXT_SUPM扩展

`RISCV_ISA_EXT_SUPM`在`arch/riscv/include/asm/hwcap.h`中定义：

```c
#ifdef CONFIG_RISCV_M_MODE
#define RISCV_ISA_EXT_SUPM		RISCV_ISA_EXT_SMNPM
#else
#define RISCV_ISA_EXT_SUPM		RISCV_ISA_EXT_SSNPM
#endif
```

- **SMNPM**: Supervisor-mode Pointer Masking for Next-level page tables, Machine mode
- **SSNPM**: Supervisor-mode Pointer Masking for Next-level page tables, Supervisor mode

根据当前运行模式（Machine mode或Supervisor mode），`RISCV_ISA_EXT_SUPM`会映射到相应的扩展。

#### 3.2 riscv_has_extension_unlikely()函数

该函数在`arch/riscv/include/asm/cpufeature-macros.h`中定义：

```c
static __always_inline bool riscv_has_extension_unlikely(const unsigned long ext)
{
	compiletime_assert(ext < RISCV_ISA_EXT_MAX, "ext must be < RISCV_ISA_EXT_MAX");

	if (IS_ENABLED(CONFIG_RISCV_ALTERNATIVE))
		return __riscv_has_extension_unlikely(STANDARD_EXT, ext);

	return __riscv_isa_extension_available(NULL, ext);
}
```

该函数使用了两种机制来检查扩展支持：
1. **Alternative机制**: 在编译时或运行时动态替换指令，提供更高效的检查
2. **传统ISA bitmap检查**: 通过`__riscv_isa_extension_available()`检查ISA位图

#### 3.3 `__riscv_has_extension_unlikely()`实现

```c
static __always_inline bool __riscv_has_extension_unlikely(const unsigned long vendor,
							   const unsigned long ext)
{
	asm goto(ALTERNATIVE("nop", "j\t%l[l_yes]", %[vendor], %[ext], 1)
	:
	: [vendor] "i" (vendor), [ext] "i" (ext)
	:
	: l_yes);

	return false;
l_yes:
	return true;
}
```

这个函数使用了RISC-V的Alternative机制：
- 如果扩展不支持：执行`nop`指令，返回`false`
- 如果扩展支持：跳转到`l_yes`标签，返回`true`

### 4. 修复的安全问题

#### 4.1 问题描述

在此修复之前，`get_tagged_addr_ctrl()`函数没有检查硬件是否真正支持Supm扩展，就直接读取和返回相关的控制寄存器状态。这可能导致：

1. **未定义行为**: 在不支持Supm的硬件上访问相关CSR寄存器
2. **信息泄露**: 返回可能包含敏感信息的寄存器内容
3. **系统不稳定**: 访问不存在的CSR可能导致异常

#### 4.2 修复效果

添加检查后：
- 如果硬件不支持Supm扩展，直接返回`-EINVAL`
- 确保只有在硬件真正支持的情况下才执行后续操作
- 提供了一致的错误处理机制

### 5. 相关代码分析

#### 5.1 set_tagged_addr_ctrl()函数

对应的设置函数`set_tagged_addr_ctrl()`在原始实现中已经包含了Supm扩展检查：

```c
static int set_tagged_addr_ctrl(struct task_struct *task, unsigned long arg)
{
	if (!riscv_has_extension_unlikely(RISCV_ISA_EXT_SUPM))
		return -EINVAL;
	// ... 其余代码
}
```

这个patch使得`get_tagged_addr_ctrl()`与`set_tagged_addr_ctrl()`保持一致的检查逻辑。

#### 5.2 tagged_addr_init()初始化

系统启动时，`tagged_addr_init()`函数会检测硬件支持的PMLEN值：

```c
static int __init tagged_addr_init(void)
{
	if (!riscv_has_extension_unlikely(RISCV_ISA_EXT_SUPM))
		return 0;

	/* 检测支持的PMLEN值 */
	csr_clear(CSR_ENVCFG, ENVCFG_PMM);
	have_user_pmlen_7 = try_to_set_pmm(ENVCFG_PMM_PMLEN_7);
	have_user_pmlen_16 = try_to_set_pmm(ENVCFG_PMM_PMLEN_16);

	return 0;
}
```

### 6. 配置选项

在`arch/riscv/Kconfig`中定义了相关配置：

```kconfig
config RISCV_ISA_SUPM
	bool "Pointer masking support"
	default y
	help
	  Add support for pointer masking in userspace (Supm) when the
	  underlying hardware extension (Smnpm or Ssnpm) is detected.
	  If you don't know what this is, say Y.

	  If disabled, the use of prctl(PR_{SET,GET}_TAGGED_ADDR_CTRL) will
	  be disabled.
```

### 7. 影响和意义

#### 7.1 安全性提升
- 防止在不支持的硬件上执行未定义操作
- 确保API的一致性和可靠性
- 避免潜在的信息泄露风险

#### 7.2 兼容性
- 保持了API的向后兼容性
- 提供了明确的错误返回值
- 与ARM64的tagged address实现保持一致

#### 7.3 性能考虑
- 使用`riscv_has_extension_unlikely()`暗示这是一个不太可能为真的条件
- 利用分支预测优化性能
- Alternative机制提供了高效的运行时检查

## 总结

这个patch是一个重要的安全修复，确保了`PR_GET_TAGGED_ADDR_CTRL`只在硬件真正支持Supm扩展时才能使用。修复内容简洁但关键，体现了内核开发中"防御性编程"的重要性。通过添加适当的硬件能力检查，避免了在不支持的平台上可能出现的未定义行为和安全风险。

这个修改也展示了RISC-V架构在扩展检测和Alternative机制方面的设计优势，能够在编译时和运行时高效地处理不同的硬件能力组合。