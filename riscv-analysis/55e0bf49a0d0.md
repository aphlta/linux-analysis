# RISC-V Patch 分析报告

## Commit 信息

**Commit ID:** 55e0bf49a0d0387d682d696e41cada071f516075  
**标题:** RISC-V: Probe misaligned access speed in parallel  
**作者:** Evan Green <evan@rivosinc.com>  
**日期:** Mon Nov 6 14:58:55 2023 -0800  
**修复的问题:** Fixes: 584ea6564bca ("RISC-V: Probe for unaligned access speed")  

## 问题背景

### 性能问题

在原始实现中，每个CPU的非对齐访问速度探测是在`smp_callin()`中串行执行的，这导致了严重的启动时间延迟：

- 单个CPU的探测时间：约0.06秒
- 64核系统的总延迟：3.8秒（64 × 0.06秒）
- 这是一个显著的启动时间开销

### 报告来源

问题由Jisheng Zhang报告，相关讨论链接：
https://lore.kernel.org/all/mhng-9359993d-6872-4134-83ce-c97debe1cf9a@palmer-ri-x1c9/T/#mae9b8f40016f9df428829d33360144dc5026bcbf

## 解决方案

### 核心思路

将串行的CPU探测改为并行执行，通过以下策略：

1. **分阶段并行执行**：
   - 阶段1：所有CPU（除了CPU 0）并行执行探测
   - 阶段2：CPU 0单独执行探测
   
2. **避免jiffies停止**：
   - 在所有CPU上禁用抢占会导致jiffies停止计时
   - 通过分阶段执行避免这个问题

3. **内存分配优化**：
   - 在`on_each_cpu()`调用之前完成所有内存分配
   - 避免在中断禁用状态下调用`alloc_pages()`

### 热插拔CPU支持

对于启动后热插拔的CPU：
- 注册CPU热插拔回调函数
- 在回调中执行探测（此时中断是启用的，可以安全调用`alloc_pages()`）

## 代码变更详细分析

### 文件修改统计

```
 arch/riscv/include/asm/cpufeature.h |  1 -
 arch/riscv/kernel/cpufeature.c      | 96 ++++++++++++++++++++++++++++++++++++++++++++++++++-------------
 arch/riscv/kernel/smpboot.c         |  1 -
 3 files changed, 77 insertions(+), 21 deletions(-
```

### 主要变更

#### 1. cpufeature.h
- 移除了`check_unaligned_access()`函数的导出声明
- 该函数现在仅在cpufeature.c内部使用

#### 2. cpufeature.c

**新增函数：**

```c
// 非启动CPU的探测包装函数
static void check_unaligned_access_nonboot_cpu(void *info)
{
    unsigned int cpu = smp_processor_id();
    struct page **bufs = info;
    
    check_unaligned_access(bufs[cpu]);
}

// 热插拔CPU的回调函数
static int riscv_online_cpu(unsigned int cpu)
{
    static struct page *buf;
    
    // 分配测试缓冲区
    buf = alloc_pages(GFP_KERNEL, MISALIGNED_BUFFER_ORDER);
    if (!buf) {
        pr_warn("Allocation failure, not measuring misaligned performance\n");
        return -ENOMEM;
    }
    
    check_unaligned_access(buf);
    __free_pages(buf, MISALIGNED_BUFFER_ORDER);
    return 0;
}
```

**重构的主函数：**

```c
// 原函数：check_unaligned_access_boot_cpu()
// 新函数：check_unaligned_access_all_cpus()
static int check_unaligned_access_all_cpus(void)
{
    unsigned int cpu;
    unsigned int cpu_count = num_possible_cpus();
    struct page **bufs = kzalloc(cpu_count * sizeof(struct page *), GFP_KERNEL);
    
    // 为每个CPU分配独立的缓冲区，避免缓存行竞争
    for_each_cpu(cpu, cpu_online_mask) {
        bufs[cpu] = alloc_pages(GFP_KERNEL, MISALIGNED_BUFFER_ORDER);
    }
    
    // 并行检测所有非0号CPU
    on_each_cpu(check_unaligned_access_nonboot_cpu, bufs, 1);
    
    // 单独检测0号CPU
    smp_call_on_cpu(0, check_unaligned_access, bufs[0], true);
    
    // 设置热插拔回调
    cpuhp_setup_state_nocalls(CPUHP_AP_ONLINE_DYN, "riscv:online",
                             riscv_online_cpu, NULL);
    
    // 清理资源
    // ...
}
```

#### 3. smpboot.c
- 移除了`check_unaligned_access(curr_cpuid)`调用
- 探测现在在启动时并行完成，不需要在每个CPU启动时单独调用

## 技术细节

### 内存管理

1. **缓冲区分配**：
   - 为每个CPU分配独立的页面缓冲区
   - 使用`MISALIGNED_BUFFER_ORDER`定义的页面大小
   - 避免CPU间的缓存行竞争

2. **错误处理**：
   - 分配失败时打印警告并继续
   - 确保所有已分配的缓冲区都被正确释放

### 并发控制

1. **分阶段执行**：
   - 使用`on_each_cpu()`并行执行非0号CPU
   - 使用`smp_call_on_cpu()`单独处理0号CPU
   - 避免所有CPU同时禁用抢占导致的jiffies停止

2. **热插拔处理**：
   - 使用`cpuhp_setup_state_nocalls()`注册回调
   - 在`CPUHP_AP_ONLINE_DYN`阶段执行
   - 确保新上线的CPU也能完成探测

## 相关提交分析

### 前置提交

**584ea6564bca** - "RISC-V: Probe for unaligned access speed"
- 引入了非对齐访问速度探测机制
- 在每个CPU启动时串行执行探测
- 导致了本patch要解决的性能问题

**c20d36cc2a20** - "riscv: don't probe unaligned access speed if already done"
- 避免重复探测已经完成的CPU
- 为热插拔场景提供了基础支持

### 后续修复

**6eb7a6445b76** - "RISC-V: Remove __init on unaligned_emulation_finish()"
- 修复了本patch引入的section mismatch警告
- `unaligned_emulation_finish()`在热插拔时被调用，不应标记为`__init`

### 相关的非对齐访问优化系列

这个patch是RISC-V非对齐访问优化系列的重要组成部分，相关提交包括：

1. **90b11b470b2e** - "riscv: annotate check_unaligned_access_boot_cpu() with __init"
   - 为原始函数添加__init注解的优化

2. **bc38f61313d3** - "riscv: add support for sysctl unaligned_enabled control"
   - 添加sysctl控制接口

3. **71c54b3d169d** - "riscv: report misaligned accesses emulation to hwprobe"
   - 向hwprobe报告非对齐访问模拟信息

4. **9f23a5d2f6b0** - "riscv: add support for PR_SET_UNALIGN and PR_GET_UNALIGN"
   - 添加进程级别的非对齐访问控制

## 性能影响

### 启动时间优化

- **优化前**：64核系统启动延迟3.8秒
- **优化后**：所有CPU并行探测，延迟降至约0.06秒
- **性能提升**：约63倍的启动时间改善

### 资源使用

- **内存开销**：临时增加（每CPU一个页面缓冲区）
- **CPU使用**：短时间内所有CPU并行工作
- **整体效果**：显著改善用户体验

## 兼容性和稳定性

### 向后兼容性

- 探测结果和行为保持不变
- 用户空间接口无变化
- hwprobe机制继续正常工作

### 错误处理

- 内存分配失败时优雅降级
- 不影响系统正常启动
- 保持原有的错误报告机制

## 实现亮点

### 1. 巧妙的分阶段设计

通过将CPU 0单独处理，避免了所有CPU同时禁用抢占导致jiffies停止的问题。这是一个非常聪明的设计，既实现了并行化，又保持了系统时钟的正常运行。

### 2. 完善的热插拔支持

使用CPU热插拔框架确保后续上线的CPU也能正确完成探测，体现了对系统完整性的考虑。

### 3. 资源管理的细致考虑

- 预先分配所有缓冲区，避免在中断禁用状态下分配内存
- 为每个CPU分配独立缓冲区，避免缓存行竞争
- 完善的错误处理和资源清理

## 总结

这个patch是一个典型的性能优化补丁，通过将串行操作改为并行操作，显著改善了多核RISC-V系统的启动时间。主要优点包括：

1. **显著的性能提升**：64核系统启动时间减少3.7+秒
2. **良好的工程实践**：
   - 合理的错误处理
   - 完善的资源管理
   - 考虑了热插拔场景
3. **向后兼容**：不影响现有功能和接口
4. **设计巧妙**：通过分阶段执行解决了并行化中的技术难题

这个patch展示了在内核开发中如何通过重新设计算法来解决性能瓶颈，是一个很好的并行化优化案例。它不仅解决了实际的性能问题，还为RISC-V架构的非对齐访问处理机制奠定了更好的基础。