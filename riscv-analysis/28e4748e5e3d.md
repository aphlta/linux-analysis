# Patch Analysis: 28e4748e5e3d

## 基本信息

- **Commit ID:** 28e4748e5e3d313056ed38abeff4b455abd02c1b
- **作者:** Erick Archer <erick.archer@gmx.com>
- **提交日期:** 2024年1月20日 14:54:00 +0100
- **标题:** riscv: Use kcalloc() instead of kzalloc()
- **维护者:** Palmer Dabbelt <palmer@rivosinc.com>
- **审查者:** 
  - Alexandre Ghiti <alexghiti@rivosinc.com>
  - Andrew Jones <ajones@ventanamicro.com>
  - Gustavo A. R. Silva <gustavoars@kernel.org>

## 1. 修改内容详细分析

### 1.1 修改的文件
- **文件路径:** `arch/riscv/kernel/unaligned_access_speed.c`
- **修改行数:** 1个文件，1行插入，2行删除

### 1.2 具体代码修改

**修改前:**
```c
struct page **bufs = kzalloc(cpu_count * sizeof(struct page *),
                             GFP_KERNEL);
```

**修改后:**
```c
struct page **bufs = kcalloc(cpu_count, sizeof(*bufs), GFP_KERNEL);
```

### 1.3 修改位置上下文

修改发生在 `check_unaligned_access_speed_all_cpus()` 函数中，该函数的作用是：
- 在所有启动时存在的CPU上并行测量非对齐访问速度
- 为每个CPU分配独立的缓冲区以避免缓存行竞争
- 分配一个指向页面指针的数组，数组大小等于可能的CPU数量

## 2. 修改原理和技术背景

### 2.1 安全性改进

这个修改主要解决了**整数溢出安全问题**：

1. **问题描述:**
   - 在内存分配器参数中进行大小计算（特别是乘法运算）存在溢出风险
   - `cpu_count * sizeof(struct page *)` 可能导致整数溢出
   - 溢出会导致值回绕，分配的内存比调用者期望的要小
   - 使用这些分配可能导致堆内存的线性溢出和其他错误行为

2. **解决方案:**
   - 使用专门的 `kcalloc()` 函数替代在 `kzalloc()` 参数中的开放式算术运算
   - `kcalloc()` 内部会检查乘法溢出，提供更安全的内存分配

### 2.2 代码风格改进

1. **类型安全性:**
   - 从 `sizeof(struct page *)` 改为 `sizeof(*bufs)`
   - 这样当变量类型改变时，不需要修改sizeof表达式
   - 提高了代码的可维护性和类型安全性

2. **内核编码规范:**
   - 符合Linux内核的最佳实践
   - 遵循KSPP（Kernel Self Protection Project）的安全编码指南

### 2.3 函数对比

| 函数 | 原型 | 安全性 | 用途 |
|------|------|--------|------|
| `kzalloc()` | `void *kzalloc(size_t size, gfp_t flags)` | 无溢出检查 | 分配并清零单个对象 |
| `kcalloc()` | `void *kcalloc(size_t n, size_t size, gfp_t flags)` | 有溢出检查 | 分配并清零数组 |

## 3. 相关提交和背景

### 3.1 KSPP项目背景

这个修改是**Kernel Self Protection Project (KSPP)**的一部分：
- **项目目标:** 提高Linux内核的安全性
- **相关Issue:** https://github.com/KSPP/linux/issues/162
- **文档参考:** https://www.kernel.org/doc/html/next/process/deprecated.html#open-coded-arithmetic-in-allocator-arguments

### 3.2 类似修改的趋势

在2024年1月期间，内核中有多个类似的修改：
- `2b703fbe4e3d` platform/x86/amd/hsmp: Change devm_kzalloc() to devm_kcalloc()
- `f6f62a9a931f` pinctrl: pinctrl-zynqmp: Use devm_kcalloc() instead of devm_kzalloc()
- `4da3bc65d218` crypto: qat - use kcalloc_node() instead of kzalloc_node()
- `1dc0c1389d6a` crypto: sun8i-ce - Use kcalloc() instead of kzalloc()
- `58dc02750fcc` staging: rtl8723bs: Use kcalloc() instead of kzalloc()

这表明这是一个系统性的内核安全加固工作。

### 3.3 RISC-V架构相关

修改的文件 `unaligned_access_speed.c` 是RISC-V架构特有的：
- **功能:** 测量和优化非对齐内存访问性能
- **重要性:** RISC-V处理器对非对齐访问的处理方式影响系统性能
- **实现:** 通过动态测试确定每个CPU的非对齐访问能力

## 4. 影响分析

### 4.1 功能影响
- **无功能变化:** 修改不改变代码的功能逻辑
- **内存分配行为:** 分配的内存大小和初始化行为完全相同
- **性能影响:** 微不足道，`kcalloc()` 增加的溢出检查开销极小

### 4.2 安全性提升
- **防止整数溢出:** 消除了潜在的整数溢出漏洞
- **内存安全:** 避免了可能的堆溢出攻击向量
- **符合安全编码标准:** 遵循现代内核安全开发实践

### 4.3 代码质量
- **可维护性提升:** `sizeof(*bufs)` 比 `sizeof(struct page *)` 更安全
- **类型安全:** 减少了类型变更时的维护负担
- **代码审查:** 更容易通过静态分析工具检查

## 5. 技术细节

### 5.1 内存分配上下文

```c
// 函数：check_unaligned_access_speed_all_cpus()
// 目的：为每个可能的CPU分配页面指针数组
unsigned int cpu_count = num_possible_cpus();

// 修改前：可能溢出的分配
struct page **bufs = kzalloc(cpu_count * sizeof(struct page *), GFP_KERNEL);

// 修改后：安全的分配
struct page **bufs = kcalloc(cpu_count, sizeof(*bufs), GFP_KERNEL);
```

### 5.2 溢出场景分析

虽然在实际的RISC-V系统中，CPU数量不太可能导致溢出，但这种修改：
1. **预防性安全措施:** 防止未来可能的问题
2. **代码一致性:** 与内核其他部分保持一致的安全标准
3. **静态分析友好:** 避免工具报告潜在问题

### 5.3 编译和运行时影响

- **编译时:** 无影响，两种方式生成相似的代码
- **运行时:** `kcalloc()` 会进行溢出检查，但开销极小
- **内存使用:** 完全相同的内存分配模式

## 6. 总结

这是一个典型的**安全加固型修改**，具有以下特点：

1. **安全性优先:** 消除潜在的整数溢出风险
2. **最佳实践:** 遵循内核安全编码标准
3. **零功能影响:** 不改变任何功能行为
4. **系统性改进:** 是内核范围内安全加固工作的一部分
5. **代码质量提升:** 提高代码的可维护性和类型安全性

这种修改体现了现代内核开发中**安全第一**的理念，即使在实际风险较低的情况下，也要采用最安全的编码实践。对于RISC-V架构的发展和内核安全性都具有积极意义。