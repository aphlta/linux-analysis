# Patch Analysis: c97bf629963e - riscv: Fix text patching when IPI are used

## 基本信息

- **Commit ID**: c97bf629963e52b205ed5fbaf151e5bd342f9c63
- **作者**: Alexandre Ghiti <alexghiti@rivosinc.com>
- **提交日期**: Thu Feb 29 13:10:56 2024 +0100
- **标题**: riscv: Fix text patching when IPI are used
- **Co-developed-by**: Björn Töpel <bjorn@rivosinc.com>
- **Reviewed-by**: Andrea Parri <parri.andrea@gmail.com>
- **Signed-off-by**: Palmer Dabbelt <palmer@rivosinc.com>

## 问题描述

当前RISC-V架构在使用IPI（Inter-Processor Interrupt）进行远程icache刷新时，text patching机制存在系统挂起的问题。具体表现为：

1. 系统使用`stop_machine()`来进行text patching
2. 在`patch_text_nosync()`中会发出IPI进行远程icache刷新
3. 这种组合导致系统挂起

## 修改内容分析

### 1. 头文件修改 (arch/riscv/include/asm/patch.h)

```c
+int patch_insn_write(void *addr, const void *insn, size_t len);
```

- 将`patch_insn_write`函数从static改为全局可见
- 为ftrace模块提供直接的指令写入接口

### 2. ftrace.c文件修改

#### 新增头文件包含
```c
+#include <linux/stop_machine.h>
```

#### 修改函数调用
原来的实现：
```c
-       ret = patch_text_nosync(hook_pos, enable ? call : nops, MCOUNT_INSN_SIZE);
+       if (patch_insn_write((void *)hook_pos, enable ? call : nops, MCOUNT_INSN_SIZE))
```

- 直接使用`patch_insn_write`替代`patch_text_nosync`
- 避免了`patch_text_nosync`中的`flush_icache_range`调用
- `flush_icache_range`内部可能使用IPI，这是导致死锁的根源

#### 新增stop_machine机制

```c
struct ftrace_modify_param {
    int command;
    atomic_t cpu_count;
};

static int __ftrace_modify_code(void *data)
{
    struct ftrace_modify_param *param = data;

    if (atomic_inc_return(&param->cpu_count) == num_online_cpus()) {
        ftrace_modify_all_code(param->command);
        atomic_inc_return_release(&param->cpu_count);
    } else {
        while (atomic_read(&param->cpu_count) <= num_online_cpus())
            cpu_relax();
    }

    local_flush_icache_all();
    return 0;
}

void arch_ftrace_update_code(int command)
{
    struct ftrace_modify_param param = { command, ATOMIC_INIT(0) };
    stop_machine(__ftrace_modify_code, &param, cpu_online_mask);
}
```

### 3. patch.c文件修改

#### 函数可见性修改
```c
-static int patch_insn_write(void *addr, const void *insn, size_t len)
+int patch_insn_write(void *addr, const void *insn, size_t len)
```

#### patch_text_cb函数优化

原来的实现：
```c
if (atomic_inc_return(&patch->cpu_count) == num_online_cpus()) {
    for (i = 0; ret == 0 && i < patch->ninsns; i++) {
        len = GET_INSN_LENGTH(patch->insns[i]);
-       ret = patch_text_nosync(patch->addr + i * len,
-                               &patch->insns[i], len);
+       ret = patch_insn_write(patch->addr + i * len, &patch->insns[i], len);
    }
-   atomic_inc(&patch->cpu_count);
+   atomic_inc_return_release(&patch->cpu_count);
} else {
    while (atomic_read(&patch->cpu_count) <= num_online_cpus())
        cpu_relax();
}

+local_flush_icache_all();
```

关键改进：
1. 使用`patch_insn_write`替代`patch_text_nosync`
2. 使用`atomic_inc_return_release`确保内存屏障语义
3. 所有CPU都执行`local_flush_icache_all()`，避免IPI

## 技术原理分析

### 1. 问题根源

原来的实现中存在以下问题链：
1. `stop_machine()`禁用了中断和抢占
2. `patch_text_nosync()`调用`flush_icache_range()`
3. `flush_icache_range()`在SMP系统中使用IPI通知其他CPU刷新icache
4. 由于中断被禁用，IPI无法被处理，导致死锁

### 2. 解决方案原理

新的实现采用了以下策略：
1. **避免IPI使用**：直接使用`patch_insn_write`而不是`patch_text_nosync`
2. **本地icache刷新**：每个CPU在`stop_machine`上下文中执行`local_flush_icache_all()`
3. **内存屏障优化**：使用`atomic_inc_return_release`确保写入操作在释放等待CPU之前完成
4. **同步机制**：通过原子计数器确保所有CPU都参与patching过程

### 3. 内存一致性保证

```c
/*
 * Make sure the patching store is effective *before* we
 * increment the counter which releases all waiting CPUs
 * by using the release variant of atomic increment. The
 * release pairs with the call to local_flush_icache_all()
 * on the waiting CPU.
 */
atomic_inc_return_release(&patch->cpu_count);
```

这个注释说明了关键的内存屏障语义：
- `release`语义确保patching操作在计数器递增之前完成
- 与等待CPU上的`local_flush_icache_all()`形成acquire-release对

## 相关提交分析

这个patch是解决RISC-V架构text patching问题的重要修复，相关的提交包括：

1. **29cee75fb66e**: "riscv: Remove superfluous smp_mb()" - 移除了多余的内存屏障
2. 该patch是针对v6.8-rc1之后的修复

## 影响和意义

### 1. 功能影响
- 修复了ftrace在多核RISC-V系统上的死锁问题
- 提高了动态代码修改的可靠性
- 确保了text patching的正确性和性能

### 2. 性能影响
- 避免了IPI开销，提高了patching效率
- 通过本地icache刷新减少了跨CPU通信
- 优化了内存屏障使用

### 3. 架构意义
- 为RISC-V架构提供了可靠的动态代码修改机制
- 支持了ftrace等重要的内核调试功能
- 为后续的代码热补丁等功能奠定了基础

## 总结

这个patch通过重新设计text patching的同步机制，解决了RISC-V架构在使用IPI进行icache刷新时的死锁问题。主要改进包括：

1. 避免在`stop_machine`上下文中使用IPI
2. 采用本地icache刷新策略
3. 优化内存屏障和同步机制
4. 提供更可靠的动态代码修改能力

这是一个重要的架构级修复，确保了RISC-V平台上ftrace等动态代码修改功能的正确性和稳定性。