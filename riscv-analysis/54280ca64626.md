# RISC-V cmpxchg patch 分析报告

## Commit 信息
- **Commit ID**: 54280ca64626f73ce39ba8f7befa9139a6786ffd
- **作者**: Leonardo Bras <leobras@redhat.com>
- **提交日期**: 2024年1月3日
- **标题**: riscv/cmpxchg: Implement cmpxchg for variables of size 1 and 2
- **邮件列表链接**: https://lore.kernel.org/r/20240103163203.72768-6-leobras@redhat.com
- **维护者**: Palmer Dabbelt <palmer@rivosinc.com>
- **测试者**: Guo Ren <guoren@kernel.org>

## 问题背景

RISC-V架构在此patch之前缺少对1字节和2字节变量的原子比较交换(cmpxchg)操作支持，而其他主流架构如ARM64和x86都已经支持这些操作。这种缺失可能导致：

1. 无法实现某些锁机制
2. 需要额外的代码重构来适配RISC-V架构
3. 与其他架构的功能不对等

## 修改内容详细分析

### 1. 新增 `__arch_cmpxchg_masked` 宏定义

这是patch的核心实现，用于处理小于4字节的cmpxchg操作：

```c
#define __arch_cmpxchg_masked(sc_sfx, cas_sfx,					\
			      sc_prepend, sc_append,				\
			      cas_prepend, cas_append,				\
			      r, p, o, n)					\
({											\
	if (IS_ENABLED(CONFIG_RISCV_ISA_ZABHA) &&				\
	    IS_ENABLED(CONFIG_RISCV_ISA_ZACAS) &&				\
	    riscv_has_extension_unlikely(RISCV_ISA_EXT_ZABHA) &&		\
	    riscv_has_extension_unlikely(RISCV_ISA_EXT_ZACAS)) {		\
		r = o;								\
										\
		__asm__ __volatile__ (						\
			cas_prepend							\
			"	amocas" cas_sfx " %0, %z2, %1\n"		\
			cas_append							\
			: "+&r" (r), "+A" (*(p))				\
			: "rJ" (n)						\
			: "memory");						\
	} else {								\
		u32 *__ptr32b = (u32 *)((ulong)(p) & ~0x3);			\
		ulong __s = ((ulong)(p) & (0x4 - sizeof(*p))) * BITS_PER_BYTE;	\
		ulong __mask = GENMASK(((sizeof(*p)) * BITS_PER_BYTE) - 1, 0)	\
			       << __s;						\
		ulong __newx = (ulong)(n) << __s;				\
		ulong __oldx = (ulong)(o) << __s;				\
		ulong __retx;							\
		ulong __rc;							\
										\
		__asm__ __volatile__ (						\
			sc_prepend							\
			"0:	lr.w %0, %2\n"					\
			"	and  %1, %0, %z5\n"					\
			"	bne  %1, %z3, 1f\n"					\
			"	and  %1, %0, %z6\n"					\
			"	or   %1, %1, %z4\n"					\
			"	sc.w" sc_sfx " %1, %1, %2\n"			\
			"	bnez %1, 0b\n"					\
			sc_append							\
			"1:\n"							\
			: "=&r" (__retx), "=&r" (__rc), "+A" (*(__ptr32b))	\
			: "rJ" ((long)__oldx), "rJ" (__newx),			\
			  "rJ" (__mask), "rJ" (~__mask)				\
			: "memory");						\
										\
		r = (__typeof__(*(p)))((__retx & __mask) >> __s);		\
	}										\
})
```

### 2. 修改 `_arch_cmpxchg` 宏的switch语句

在原有的switch语句中新增了对1字节和2字节的支持：

```c
switch (sizeof(*__ptr)) {
case 1:
	__arch_cmpxchg_masked(sc_sfx, ".b" cas_sfx,
			      sc_prepend, sc_append,
			      cas_prepend, cas_append,
			      __ret, __ptr, __old, __new);
	break;
case 2:
	__arch_cmpxchg_masked(sc_sfx, ".h" cas_sfx,
			      sc_prepend, sc_append,
			      cas_prepend, cas_append,
			      __ret, __ptr, __old, __new);
	break;
// 原有的case 4和case 8保持不变
}
```

## 技术实现原理

### 1. 掩码操作原理

由于RISC-V的原子操作指令只支持32位和64位操作，对于1字节和2字节的cmpxchg需要使用"掩码"技术：

1. **地址对齐**: `u32 *__ptr32b = (u32 *)((ulong)(p) & ~0x3)` - 将目标地址对齐到4字节边界
2. **偏移计算**: `ulong __s = ((ulong)(p) & (0x4 - sizeof(*p))) * BITS_PER_BYTE` - 计算目标数据在32位字中的位偏移
3. **掩码生成**: `ulong __mask = GENMASK(...) << __s` - 生成用于提取目标数据的位掩码
4. **数据移位**: 将新值和旧值左移到正确的位置

### 2. 原子操作序列

使用Load-Reserved/Store-Conditional (LR/SC) 指令对实现原子性：

```assembly
0: lr.w %0, %2          # 加载保留32位数据
   and  %1, %0, %z5     # 提取目标字节/半字
   bne  %1, %z3, 1f     # 比较是否等于期望值
   and  %1, %0, %z6     # 清除目标位置
   or   %1, %1, %z4     # 设置新值
   sc.w %1, %1, %2      # 条件存储
   bnez %1, 0b          # 如果失败则重试
1:                      # 结束标签
```

### 3. ZACAS扩展支持

Patch还考虑了未来的RISC-V扩展支持：
- **ZABHA扩展**: 提供字节和半字的原子操作支持
- **ZACAS扩展**: 提供原子比较交换指令

当这些扩展可用时，可以直接使用`amocas`指令，避免复杂的掩码操作。

## 相关提交分析

这个patch是一个更大的重构系列的一部分，相关提交包括：

1. **300ce44cbe29**: "Merge patch series 'Rework & improve riscv cmpxchg.h and atomic.h'"
   - 整个系列的合并提交

2. **a8ed2b7a2c13**: "riscv/cmpxchg: Implement xchg for variables of size 1 and 2"
   - 实现1字节和2字节的xchg操作，与本patch配套

3. **906123739272**: "riscv/atomic.h : Deduplicate arch_atomic.*"
   - 去重atomic.h中的重复代码

4. **07a0a41cb77d**: "riscv/cmpxchg: Deduplicate cmpxchg() asm and macros"
   - 去重cmpxchg相关的汇编代码和宏定义

5. **4bfa185fe3f0**: "riscv/cmpxchg: Deduplicate xchg() asm functions"
   - 去重xchg相关的汇编函数

## 影响和意义

### 1. 架构完整性
- 使RISC-V架构在原子操作方面与ARM64、x86等主流架构保持一致
- 提供了完整的1、2、4、8字节原子操作支持

### 2. 内核子系统支持
- 使得依赖小尺寸原子操作的内核子系统能够在RISC-V上正常工作
- 减少了移植其他架构代码到RISC-V时的适配工作

### 3. 性能考虑
- 虽然1字节和2字节操作需要额外的掩码处理，但提供了正确的语义
- 为未来的硬件扩展(ZABHA/ZACAS)预留了优化空间

### 4. 向前兼容性
- 代码设计考虑了未来RISC-V扩展的支持
- 当硬件支持原生的字节/半字原子操作时，可以自动使用更高效的实现

## 测试和验证

- **测试者**: Guo Ren，RISC-V社区的重要贡献者
- **测试范围**: 确保新实现的cmpxchg操作在各种场景下的正确性
- **兼容性**: 验证与现有代码的兼容性

## 总结

这个patch填补了RISC-V架构在小尺寸原子操作方面的空白，通过巧妙的掩码技术实现了1字节和2字节的cmpxchg操作。虽然实现相对复杂，但为RISC-V提供了与其他主流架构相当的原子操作能力，对于内核的完整性和可移植性具有重要意义。同时，代码设计也为未来的硬件扩展预留了优化空间。