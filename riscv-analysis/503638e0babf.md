# RISC-V Patch 分析: 503638e0babf

## 基本信息

**Commit ID**: 503638e0babf364061bc50fca5103b00a56cc50a  
**作者**: Alexandre Ghiti <alexghiti@rivosinc.com>  
**日期**: Wed Jul 17 08:01:24 2024 +0200  
**标题**: riscv: Stop emitting preventive sfence.vma for new vmalloc mappings

## 1. Patch 概述

这个patch解决了RISC-V架构中vmalloc映射的TLB刷新性能问题。在6.5内核版本中，由于移除了vmalloc fault path，为了确保新的页表条目能被页表遍历器看到，内核需要在所有hart上预防性地发出sfence.vma指令，但这种解决方案代价很高，因为它依赖于IPI（Inter-Processor Interrupt）。

## 2. 问题背景

### 2.1 历史问题

1. **6.5版本移除vmalloc fault path**: 因为该机制无法正常工作
2. **预防性sfence.vma的引入**: 为确保新页表条目可见性，在所有hart上发出sfence.vma
3. **性能问题**: 依赖IPI的解决方案代价高昂
4. **潜在死锁**: 如果在IPI路径中进行vmalloc分配（例如被trace），可能导致vmalloc fault循环，最终导致内核栈溢出

### 2.2 技术原理

预防性sfence.vma需要发出的原因：

- **微架构缓存无效条目**: 如果微架构缓存无效条目，新映射可能不会被页表遍历器观察到，需要无效化
- **微架构不缓存无效条目**: 如果微架构不缓存无效条目，重排序的访问可能"错过"新映射并陷入trap，这种情况下只需要重试访问，不需要sfence.vma

## 3. 解决方案

### 3.1 核心思路

这个patch移除了预防性sfence.vma，转而实际处理可能（且不太可能）发生的异常。由于内核栈映射位于vmalloc区域，这种处理必须在trap发生时的很早期进行，即在handle_exception的最开始，这也排除了在fault路径中进行vmalloc分配的可能性。

### 3.2 实现机制

#### 3.2.1 新增全局变量

```c
// arch/riscv/mm/init.c
u64 new_vmalloc[NR_CPUS / sizeof(u64) + 1];
```

这个数组用于跟踪每个CPU是否有新的vmalloc映射需要处理。使用位图的方式，每个CPU对应一个bit。

#### 3.2.2 异常处理入口检查

在`arch/riscv/kernel/entry.S`中添加了`new_vmalloc_check`宏，该宏在异常处理的最早期执行：

```assembly
.macro new_vmalloc_check
    REG_S   a0, TASK_TI_A0(tp)
    csrr    a0, CSR_CAUSE
    /* Exclude IRQs */
    blt     a0, zero, _new_vmalloc_restore_context_a0

    REG_S   a1, TASK_TI_A1(tp)
    /* Only check new_vmalloc if we are in page/protection fault */
    li      a1, EXC_LOAD_PAGE_FAULT
    beq     a0, a1, _new_vmalloc_kernel_address
    li      a1, EXC_STORE_PAGE_FAULT
    beq     a0, a1, _new_vmalloc_kernel_address
    li      a1, EXC_INST_PAGE_FAULT
    bne     a0, a1, _new_vmalloc_restore_context_a1
```

#### 3.2.3 检查逻辑

1. **异常类型过滤**: 只处理页面错误（LOAD/STORE/INST_PAGE_FAULT），排除中断
2. **地址检查**: 确认是内核地址（负数地址）
3. **CPU位图检查**: 检查当前CPU是否有新的vmalloc映射
4. **原子操作**: 使用`amoxor.d`原子地重置当前CPU的bit
5. **条件性sfence.vma**: 只有在微架构缓存无效条目时才发出sfence.vma

```assembly
/* Check if a new vmalloc mapping appeared that could explain the trap */
REG_S   a2, TASK_TI_A2(tp)
/*
 * Computes:
 * a0 = &new_vmalloc[BIT_WORD(cpu)]
 * a1 = BIT_MASK(cpu)
 */
REG_L   a2, TASK_TI_CPU(tp)
/* Compute the new_vmalloc element position */
srli    a1, a2, 6
slli    a1, a1, 3
la      a0, new_vmalloc
add     a0, a0, a1
/* Compute the bit position */
slli    a1, a1, 3
sub     a1, a2, a1
li      a2, 1
sll     a1, a2, a1

/* Check if there is a new_vmalloc for this cpu */
REG_L   a2, 0(a0)
and     a2, a2, a1
beq     a2, zero, _new_vmalloc_restore_context

/* Atomically reset the current cpu bit in new_vmalloc */
amoxor.d        a0, a1, (a0)

/* Only emit a sfence.vma if the uarch caches invalid entries */
ALTERNATIVE("sfence.vma", "nop", 0, RISCV_ISA_EXT_SVVPTC, 1)
```

#### 3.2.4 ALTERNATIVE机制

使用ALTERNATIVE机制根据硬件特性决定是否发出sfence.vma：
- 如果硬件支持SVVPTC扩展（不缓存无效条目），则使用nop
- 否则使用sfence.vma指令

## 4. 代码修改详细分析

### 4.1 arch/riscv/kernel/asm-offsets.c

```c
#ifdef CONFIG_64BIT
    OFFSET(TASK_TI_A0, task_struct, thread_info.a0);
    OFFSET(TASK_TI_A1, task_struct, thread_info.a1);
    OFFSET(TASK_TI_A2, task_struct, thread_info.a2);
#endif
```

为64位RISC-V添加了寄存器保存位置的偏移量定义，用于在异常处理早期保存寄存器状态。

### 4.2 arch/riscv/kernel/entry.S

1. **new_vmalloc_check宏**: 实现了完整的检查逻辑
2. **集成到handle_exception**: 在内核态异常处理路径中调用检查

```assembly
.Lrestore_kernel_tpsp:
    csrr tp, CSR_SCRATCH

#ifdef CONFIG_64BIT
    /*
     * The RISC-V kernel does not eagerly emit a sfence.vma after each
     * new vmalloc mapping, which may result in exceptions:
     * - if the uarch caches invalid entries, the new mapping would not be
     *   observed by the page table walker and an invalidation is needed.
     * - if the uarch does not cache invalid entries, a reordered access
     *   could "miss" the new mapping and traps: in that case, we only need
     *   to retry the access, no sfence.vma is required.
     */
    new_vmalloc_check
#endif
```

### 4.3 arch/riscv/mm/init.c

添加了全局的new_vmalloc数组，用于跟踪每个CPU的新vmalloc映射状态。

## 5. 性能优化原理

### 5.1 从主动到被动

- **之前**: 每次vmalloc映射后主动在所有CPU上发出IPI执行sfence.vma
- **现在**: 只在实际发生页面错误时才处理，且只在当前CPU上处理

### 5.2 硬件特性适配

通过ALTERNATIVE机制，根据硬件是否缓存无效TLB条目来决定是否需要sfence.vma：
- **SVVPTC扩展**: 硬件不缓存无效条目，只需重试访问
- **传统硬件**: 可能缓存无效条目，需要sfence.vma

### 5.3 减少IPI开销

- **消除预防性IPI**: 不再需要在每次vmalloc后向所有CPU发送IPI
- **按需处理**: 只有在实际访问新映射时才处理
- **局部化处理**: 每个CPU独立处理自己的TLB

## 6. 相关技术背景

### 6.1 RISC-V TLB管理

- **sfence.vma**: RISC-V的TLB刷新指令
- **ASID**: 地址空间标识符，用于区分不同进程的TLB条目
- **全局映射**: 内核映射在所有地址空间中都可见

### 6.2 vmalloc区域特点

- **动态映射**: 运行时创建的内核虚拟地址映射
- **全局可见**: 所有CPU都需要能访问
- **内核栈**: RISC-V的内核栈位于vmalloc区域

### 6.3 微架构差异

不同的RISC-V实现对TLB的处理策略不同：
- **缓存无效条目**: 需要显式无效化
- **不缓存无效条目**: 自然重试即可

## 7. 潜在影响和风险

### 7.1 性能提升

- **减少IPI开销**: 显著减少跨CPU通信
- **按需处理**: 只在必要时进行TLB操作
- **硬件优化**: 充分利用硬件特性

### 7.2 复杂性增加

- **异常处理路径**: 在关键路径中增加了检查逻辑
- **状态管理**: 需要维护per-CPU的vmalloc状态
- **硬件依赖**: 依赖ALTERNATIVE机制和硬件特性检测

### 7.3 兼容性考虑

- **向后兼容**: 支持不同的RISC-V硬件实现
- **配置依赖**: 只在64位RISC-V上启用
- **扩展支持**: 正确处理SVVPTC等扩展

## 8. 总结

这个patch通过将vmalloc TLB管理从主动预防性刷新改为被动异常处理，显著提升了RISC-V内核的性能。主要创新点包括：

1. **异常驱动的TLB管理**: 只在实际需要时处理TLB
2. **硬件特性适配**: 根据硬件能力选择最优策略
3. **per-CPU状态跟踪**: 精确跟踪每个CPU的vmalloc状态
4. **早期异常处理**: 在异常处理的最早期进行检查

这种设计既保证了正确性，又大幅提升了性能，是RISC-V内核优化的一个重要里程碑。

## 9. 相关链接

- [1] https://lore.kernel.org/linux-riscv/20230531093817.665799-1-bjorn@kernel.org/
- [2] https://lore.kernel.org/linux-riscv/20230801090927.2018653-1-dylan@andestech.com
- [3] https://lore.kernel.org/linux-riscv/20230725132246.817726-1-alexghiti@rivosinc.com/
- [4] https://lore.kernel.org/lkml/20200508144043.13893-1-joro@8bytes.org/