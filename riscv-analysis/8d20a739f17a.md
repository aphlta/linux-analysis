# RISC-V Patch 分析: 8d20a739f17a

## 基本信息

**Commit ID:** 8d20a739f17a2de9e269db72330f5655d6545dd4  
**标题:** RISC-V: Check scalar unaligned access on all CPUs  
**作者:** Jesse Taube <jesse@rivosinc.com>  
**提交者:** Palmer Dabbelt <palmer@rivosinc.com>  
**提交日期:** 2024年10月18日  
**修复的问题:** Fixes: 71c54b3d169d ("riscv: report misaligned accesses emulation to hwprobe")  
**稳定版标记:** Cc: stable@vger.kernel.org  

## 问题描述

原始的 `check_unaligned_access_emulated_all_cpus` 函数只检查了启动hart（硬件线程），而没有检查系统中的所有CPU核心。这个patch修复了这个问题，确保对所有CPU核心进行标量非对齐访问检测。

## 修改的文件

1. `arch/riscv/include/asm/cpufeature.h` - 头文件修改
2. `arch/riscv/kernel/traps_misaligned.c` - 主要实现修改

## 详细修改内容

### 1. 头文件修改 (cpufeature.h)

```c
// 新增包含
+#include <linux/workqueue.h>

// 函数声明修改
+void check_unaligned_access_emulated(struct work_struct *work __always_unused);
```

**修改说明:**
- 添加了workqueue头文件包含，支持工作队列机制
- 将 `check_unaligned_access_emulated` 函数从静态内部函数改为公开函数
- 函数签名从 `bool check_unaligned_access_emulated(int cpu)` 改为 `void check_unaligned_access_emulated(struct work_struct *work)`

### 2. 主要实现修改 (traps_misaligned.c)

#### 函数签名和参数变化

```c
// 修改前
-static bool check_unaligned_access_emulated(int cpu)
{
    long *mas_ptr = per_cpu_ptr(&misaligned_access_speed, cpu);
    bool misaligned_emu_detected;
    
// 修改后  
+void check_unaligned_access_emulated(struct work_struct *work __always_unused)
{
+   int cpu = smp_processor_id();
    long *mas_ptr = per_cpu_ptr(&misaligned_access_speed, cpu);
```

**关键变化:**
- 函数从静态改为全局可见
- 返回类型从 `bool` 改为 `void`
- 参数从 `int cpu` 改为 `struct work_struct *work`
- 通过 `smp_processor_id()` 获取当前CPU ID
- 移除了 `misaligned_emu_detected` 局部变量

#### 检测逻辑简化

```c
// 修改前
-misaligned_emu_detected = (*mas_ptr == RISCV_HWPROBE_MISALIGNED_SCALAR_EMULATED);
-if (unlikely(unaligned_ctl && !misaligned_emu_detected)) {

// 修改后
+if (unlikely(unaligned_ctl && (*mas_ptr != RISCV_HWPROBE_MISALIGNED_SCALAR_EMULATED))) {
```

**优化说明:**
- 直接在条件判断中检查状态，无需中间变量
- 逻辑更加直接和高效

#### 调用方式的根本性改变

```c
// 修改前 - 在主调用函数中
for_each_online_cpu(cpu)
-   if (!check_unaligned_access_emulated(cpu))
        return false;

// 修改后
+schedule_on_each_cpu(check_unaligned_access_emulated);
+
for_each_online_cpu(cpu)
+   if (per_cpu(misaligned_access_speed, cpu)
+       != RISCV_HWPROBE_MISALIGNED_SCALAR_EMULATED)
        return false;
```

## 技术原理分析

### 1. 工作队列机制 (Work Queue)

**原理:**
- `schedule_on_each_cpu()` 是Linux内核提供的工作队列API
- 它会在系统的每个在线CPU上调度执行指定的工作函数
- 每个CPU会在其本地上下文中执行 `check_unaligned_access_emulated` 函数

**优势:**
- **真正的并行执行:** 每个CPU在自己的上下文中执行检测
- **准确的CPU特定检测:** 通过 `smp_processor_id()` 确保在正确的CPU上执行
- **避免跨CPU访问:** 每个CPU直接访问自己的per-cpu变量

### 2. Per-CPU变量机制

**核心概念:**
```c
DECLARE_PER_CPU(long, misaligned_access_speed);
```

- 每个CPU都有自己独立的 `misaligned_access_speed` 变量副本
- 避免了缓存行竞争和同步开销
- 提供了CPU特定的配置存储

### 3. 非对齐访问检测原理

**检测机制:**
```c
*mas_ptr = RISCV_HWPROBE_MISALIGNED_SCALAR_UNKNOWN;

__asm__ __volatile__ (
    "       "REG_L" %[tmp], 1(%[ptr])\n"
    : [tmp] "=r" (tmp_val) : [ptr] "r" (&tmp_var) : "memory");
```

**工作原理:**
1. 初始化状态为 `UNKNOWN`
2. 执行非对齐内存访问（地址+1的加载操作）
3. 如果CPU不支持硬件非对齐访问，会触发异常
4. 异常处理程序会将状态设置为 `EMULATED`
5. 如果CPU支持硬件非对齐访问，状态保持 `UNKNOWN`

### 4. 异构CPU支持检查

```c
if (unlikely(unaligned_ctl && (*mas_ptr != RISCV_HWPROBE_MISALIGNED_SCALAR_EMULATED))) {
    pr_crit("CPU misaligned accesses non homogeneous (expected all emulated)\n");
    while (true)
        cpu_relax();
}
```

**安全机制:**
- 检测CPU间非对齐访问能力的一致性
- 如果发现异构情况（某些CPU支持硬件非对齐，某些需要模拟），系统会进入死循环
- 这确保了系统行为的一致性和可预测性

## 修复的问题分析

### 原始问题

**问题根源:** 原始实现中，`check_unaligned_access_emulated_all_cpus` 函数的循环：

```c
// 原始有问题的实现
for_each_online_cpu(cpu)
    if (!check_unaligned_access_emulated(cpu))
        return false;
```

**问题分析:**
1. **跨CPU访问:** 函数可能在CPU A上运行，但检测CPU B的能力
2. **上下文错误:** `smp_processor_id()` 返回的是当前执行CPU，而不是参数指定的CPU
3. **检测不准确:** 非对齐访问检测需要在目标CPU上执行才能得到准确结果

### 修复方案

**解决策略:**
1. **使用工作队列:** `schedule_on_each_cpu()` 确保每个CPU在自己的上下文中执行检测
2. **简化函数接口:** 移除CPU参数，直接使用 `smp_processor_id()`
3. **分离检测和验证:** 先执行检测，再统一验证结果

## 相关提交分析

### 被修复的原始提交: 71c54b3d169d

**提交信息:**
- 标题: "riscv: report misaligned accesses emulation to hwprobe"
- 引入了非对齐访问检测机制
- 添加了 `check_unaligned_access_emulated` 函数
- 实现了hwprobe接口支持

**原始实现的局限性:**
- 只在单个CPU上下文中检测所有CPU
- 没有考虑多CPU系统的复杂性
- 检测结果可能不准确

### 修复的重要性

**影响范围:**
- **多核RISC-V系统:** 确保所有CPU核心的非对齐访问能力被正确检测
- **异构系统:** 防止不同CPU核心能力不一致导致的系统不稳定
- **用户空间程序:** 提供准确的硬件能力信息，帮助优化内存访问策略

**稳定性标记:**
- 包含 `Cc: stable@vger.kernel.org` 标记
- 表明这是一个需要回移到稳定版本的重要修复
- 影响系统的基础功能和稳定性

## 技术影响和意义

### 1. 系统可靠性提升
- 确保多核系统中所有CPU的非对齐访问能力被正确识别
- 防止因CPU能力检测错误导致的系统崩溃或性能问题

### 2. 性能优化支持
- 为用户空间程序提供准确的硬件能力信息
- 帮助编译器和运行时库选择最优的内存访问策略
- 支持memcpy等关键函数的性能优化

### 3. 硬件兼容性
- 支持异构RISC-V系统的正确检测
- 为未来的RISC-V硬件变化提供了可扩展的检测框架

## 总结

这个patch解决了RISC-V架构中一个重要的多核系统兼容性问题。通过引入工作队列机制，确保每个CPU在自己的上下文中执行非对齐访问检测，从而获得准确的硬件能力信息。这个修复对于多核RISC-V系统的稳定性和性能优化具有重要意义，特别是在异构CPU配置的系统中。

修复的核心思想是将原来的"远程检测"改为"本地检测"，通过工作队列机制确保每个CPU都能准确报告自己的非对齐访问能力，这是一个典型的分布式系统设计原则在内核中的应用。