# Patch Analysis: 08fb07d6dcf7

## 基本信息

**Commit ID:** 08fb07d6dcf7101c1c98782f2b4e27aca7f855c3  
**标题:** RISC-V: KVM: Support 64 bit firmware counters on RV32  
**作者:** Atish Patra <atishp@rivosinc.com>  
**提交日期:** 2024年4月20日  
**合并日期:** 2024年4月26日  
**维护者:** Anup Patel <anup@brainfault.org>  

## Patch概述

这个patch为RISC-V 32位平台的KVM虚拟化环境添加了对64位固件计数器的支持。主要是为了实现SBI v2.0规范中新引入的`fw_read_hi`功能，该功能允许在32位系统上读取64位固件计数器的高32位。

## 修改文件统计

- `arch/riscv/include/asm/kvm_vcpu_pmu.h`: +4 -1 行
- `arch/riscv/kvm/vcpu_pmu.c`: +44 -1 行  
- `arch/riscv/kvm/vcpu_sbi_pmu.c`: +6 行
- **总计:** +52 -2 行

## 详细修改内容分析

### 1. 头文件修改 (kvm_vcpu_pmu.h)

**新增函数声明:**
```c
int kvm_riscv_vcpu_pmu_fw_ctr_read_hi(struct kvm_vcpu *vcpu, unsigned long cidx,
                                      struct kvm_vcpu_sbi_return *retdata);
```

这个声明为新的固件计数器高位读取功能提供了接口。

### 2. PMU核心实现 (vcpu_pmu.c)

**新增静态函数 `pmu_fw_ctr_read_hi`:**
```c
static int pmu_fw_ctr_read_hi(struct kvm_vcpu *vcpu, unsigned long cidx, unsigned long *out_val)
{
    struct kvm_pmu *kvpmu = vcpu_to_pmu(vcpu);
    struct kvm_pmc *pmc;
    unsigned long fevent_code;

    if (!kvm_pmu_is_fw_event(cidx))
        return -EINVAL;

    fevent_code = get_event_code(cidx);
    if (fevent_code >= SBI_PMU_FW_MAX)
        return -EINVAL;

    pmc = &kvpmu->pmc[cidx];
    *out_val = pmc->counter_val >> 32;

    return 0;
}
```

**关键实现原理:**
- 验证计数器索引是否为固件事件
- 检查事件代码是否在有效范围内
- 通过右移32位操作获取64位计数器的高32位
- 将结果存储在输出参数中

**新增公共接口函数:**
```c
int kvm_riscv_vcpu_pmu_fw_ctr_read_hi(struct kvm_vcpu *vcpu, unsigned long cidx,
                                     struct kvm_vcpu_sbi_return *retdata)
{
    int ret;

    ret = pmu_fw_ctr_read_hi(vcpu, cidx, &retdata->out_val);
    if (ret == -EINVAL)
        retdata->err_val = SBI_ERR_INVALID_PARAM;

    return 0;
}
```

**重要修改 - 固件计数器宽度:**
```c
// 修改前
pmc->cinfo.width = BITS_PER_LONG - 1;
// 修改后  
pmc->cinfo.width = 63;
```

这个修改确保了固件计数器在32位和64位平台上都报告为63位宽度，保持了一致性。

### 3. SBI接口处理 (vcpu_sbi_pmu.c)

**新增SBI调用处理:**
```c
case SBI_EXT_PMU_COUNTER_FW_READ_HI:
    if (IS_ENABLED(CONFIG_32BIT))
        ret = kvm_riscv_vcpu_pmu_fw_ctr_read_hi(vcpu, cp->a0, retdata);
    else
        retdata->out_val = 0;
    break;
```

**处理逻辑:**
- 仅在32位配置下调用实际的读取函数
- 在64位系统上直接返回0，因为64位系统可以直接读取完整的64位值

## 技术原理分析

### 1. 64位计数器在32位系统上的挑战

在32位RISC-V系统上，寄存器和内存访问都是32位的，但性能计数器需要支持64位以避免频繁溢出。SBI v2.0通过引入配对的读取函数解决了这个问题：
- `SBI_EXT_PMU_COUNTER_FW_READ`: 读取低32位
- `SBI_EXT_PMU_COUNTER_FW_READ_HI`: 读取高32位

### 2. 实现策略

**存储方式:**
- 计数器值存储在`pmc->counter_val`中，这是一个64位值
- 通过位移操作分离高低32位

**平台兼容性:**
- 32位平台：实现完整的高位读取功能
- 64位平台：高位读取直接返回0（因为可以一次性读取64位）

### 3. 错误处理

- 验证计数器索引的有效性
- 确保只有固件事件才能使用此接口
- 将内部错误码转换为SBI标准错误码

## 相关提交分析

这个patch是一个更大的PMU功能增强系列的一部分：

1. **16b0bde9a37c** - "RISC-V: KVM: Add perf sampling support for guests"
2. **c2f41ddbcdd7** - "RISC-V: KVM: Implement SBI PMU Snapshot feature"  
3. **a8625217a054** - "drivers/perf: riscv: Implement SBI PMU snapshot function"
4. **b994cdfcdf7b** - "drivers/perf: riscv: Fix counter mask iteration for RV32"

这些提交共同构成了RISC-V KVM PMU功能的完整实现，特别关注32位平台的兼容性。

## 影响和意义

### 1. 功能完整性
- 使32位RISC-V KVM环境完全支持SBI v2.0 PMU规范
- 提供了与64位平台一致的PMU接口

### 2. 性能监控
- 允许客户机在32位环境下进行准确的64位性能计数
- 支持长时间运行的性能分析而不会因计数器溢出丢失数据

### 3. 标准兼容性
- 严格遵循SBI v2.0规范
- 确保不同RISC-V实现之间的兼容性

## 潜在问题和注意事项

1. **原子性**: 在32位系统上，读取64位计数器的高低位不是原子操作，可能存在竞态条件
2. **性能开销**: 额外的SBI调用可能带来轻微的性能影响
3. **向后兼容**: 需要确保旧版本的客户机软件仍能正常工作

## 总结

这个patch是RISC-V虚拟化PMU支持的重要补充，特别是为32位平台提供了完整的64位计数器支持。实现简洁高效，严格遵循SBI规范，为RISC-V生态系统的性能监控提供了坚实的基础。