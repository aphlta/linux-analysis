# RISC-V KVM Perf Sampling Support Patch 分析

## Commit 信息

- **Commit ID**: 16b0bde9a37c0af404318ca3cf64a11edccb8777
- **作者**: Atish Patra <atishp@rivosinc.com>
- **提交日期**: 2024年4月20日
- **标题**: RISC-V: KVM: Add perf sampling support for guests
- **Reviewed-by**: Anup Patel <anup@brainfault.org>, Andrew Jones <ajones@ventanamicro.com>

## 1. Patch 概述

这个patch为RISC-V KVM添加了guest虚拟机的性能采样(perf sampling)支持。由于RISC-V ISA目前还没有机制来启用trap/emulate scountovf，因此依赖SBI PMU snapshot功能通过共享内存提供计数器溢出数据。

### 主要特性

1. **性能采样支持**: 为guest虚拟机启用perf sampling功能
2. **中断注入机制**: 使用AIA规范定义的IRQ过滤机制注入LCOFI中断
3. **共享内存机制**: 通过SBI PMU snapshot在host和guest之间共享溢出数据
4. **AIA依赖**: 需要host启用ssaia扩展才能使用perf sampling

## 2. 修改的文件列表

```
arch/riscv/include/asm/csr.h          |  3 ++-
arch/riscv/include/asm/kvm_vcpu_pmu.h |  3 +++
arch/riscv/include/uapi/asm/kvm.h     |  1 +
arch/riscv/kvm/aia.c                  |  5 +++++
arch/riscv/kvm/vcpu.c                 | 15 ++++++++++++---
arch/riscv/kvm/vcpu_onereg.c          |  6 ++++++
arch/riscv/kvm/vcpu_pmu.c             | 68 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++----
```

## 3. 详细代码修改分析

### 3.1 CSR定义修改 (arch/riscv/include/asm/csr.h)

```c
#define VSIP_VALID_MASK                ((_AC(1, UL) << IRQ_S_SOFT) | \
                                (_AC(1, UL) << IRQ_S_TIMER) | \
-                                (_AC(1, UL) << IRQ_S_EXT))
+                                (_AC(1, UL) << IRQ_S_EXT) | \
+                                (_AC(1, UL) << IRQ_PMU_OVF))
```

**分析**: 在VSIP_VALID_MASK中添加了IRQ_PMU_OVF位，使得PMU溢出中断成为有效的虚拟化中断源。

### 3.2 PMU数据结构扩展 (arch/riscv/include/asm/kvm_vcpu_pmu.h)

```c
struct kvm_pmc {
    u8 idx;
    struct perf_event *perf_event;
    u64 counter_val;
    union sbi_pmu_ctr_info cinfo;
    bool started;
    unsigned long event_idx;
+   struct kvm_vcpu *vcpu;  // 新增vcpu指针
};

struct kvm_pmu {
    // ... 其他字段
+   DECLARE_BITMAP(pmc_overflown, RISCV_KVM_MAX_COUNTERS);  // 新增溢出位图
};
```

**分析**: 
- 在`kvm_pmc`结构中添加了`vcpu`指针，用于在溢出处理函数中访问VCPU上下文
- 在`kvm_pmu`结构中添加了`pmc_overflown`位图，用于跟踪哪些计数器发生了溢出

### 3.3 核心溢出处理函数 (arch/riscv/kvm/vcpu_pmu.c)

```c
static void kvm_riscv_pmu_overflow(struct perf_event *perf_event,
                                   struct perf_sample_data *data,
                                   struct pt_regs *regs)
{
    struct kvm_pmc *pmc = perf_event->overflow_handler_context;
    struct kvm_vcpu *vcpu = pmc->vcpu;
    struct kvm_pmu *kvpmu = vcpu_to_pmu(vcpu);
    struct riscv_pmu *rpmu = to_riscv_pmu(perf_event->pmu);
    u64 period;

    // 停止事件计数
    rpmu->pmu.stop(perf_event, PERF_EF_UPDATE);

    // 重新设置采样周期
    period = -(local64_read(&perf_event->count));
    local64_set(&perf_event->hw.period_left, 0);
    perf_event->attr.sample_period = period;
    perf_event->hw.sample_period = period;

    // 设置溢出标志并注入中断
    set_bit(pmc->idx, kvpmu->pmc_overflown);
    kvm_riscv_vcpu_set_interrupt(vcpu, IRQ_PMU_OVF);

    // 重新启动事件
    rpmu->pmu.start(perf_event, PERF_EF_RELOAD);
}
```

**分析**: 这是新增的核心溢出处理函数，当perf事件溢出时被调用：
1. **停止计数**: 直接访问perf_event停止计数，避免通过工作队列延迟处理
2. **重置周期**: 重新设置采样周期，确保下次溢出的正确性
3. **标记溢出**: 在`pmc_overflown`位图中设置对应位
4. **注入中断**: 向guest注入PMU溢出中断(IRQ_PMU_OVF)
5. **重启计数**: 重新启动perf事件继续计数

### 3.4 perf事件创建修改

```c
static long kvm_pmu_create_perf_event(struct kvm_pmc *pmc, struct perf_event_attr *attr,
                                      unsigned long flags, unsigned long eidx,
                                      unsigned long evtdata)
{
    // ... 现有代码
    
    // 设置默认采样周期
    attr->sample_period = kvm_pmu_get_sample_period(pmc);

-   event = perf_event_create_kernel_counter(attr, -1, current, NULL, NULL);
+   event = perf_event_create_kernel_counter(attr, -1, current, kvm_riscv_pmu_overflow, pmc);
    
    // ... 其余代码
}
```

**分析**: 修改perf事件创建，将新的溢出处理函数`kvm_riscv_pmu_overflow`注册为回调函数，并将`pmc`作为上下文传递。

### 3.5 计数器停止和重置逻辑增强

```c
if (flags & SBI_PMU_STOP_FLAG_RESET) {
    pmc->event_idx = SBI_PMU_EVENT_IDX_INVALID;
    clear_bit(pmc_index, kvpmu->pmc_in_use);
+   clear_bit(pmc_index, kvpmu->pmc_overflown);  // 清除溢出标志
+   if (snap_flag_set) {
+       kvpmu->sdata->ctr_overflow_mask &= ~BIT(i);
+       shmem_needs_update = true;
+   }
}
```

**分析**: 在计数器重置时，同时清除溢出标志和共享内存中的溢出掩码。

### 3.6 初始化和清理函数更新

```c
void kvm_riscv_vcpu_pmu_init(struct kvm_vcpu *vcpu)
{
    // ... 现有代码
    for (i = 0; i < kvm_pmu_num_counters(kvpmu); i++) {
        pmc = &kvpmu->pmc[i];
        pmc->idx = i;
        pmc->event_idx = SBI_PMU_EVENT_IDX_INVALID;
+       pmc->vcpu = vcpu;  // 设置vcpu指针
        // ... 其余代码
    }
}

void kvm_riscv_vcpu_pmu_deinit(struct kvm_vcpu *vcpu)
{
    // ... 现有代码
    bitmap_zero(kvpmu->pmc_in_use, RISCV_KVM_MAX_COUNTERS);
+   bitmap_zero(kvpmu->pmc_overflown, RISCV_KVM_MAX_COUNTERS);  // 清零溢出位图
    // ... 其余代码
}
```

**分析**: 
- 初始化时设置每个PMC的vcpu指针
- 清理时清零溢出位图

### 3.7 AIA中断支持 (arch/riscv/kvm/aia.c)

```c
+bool kvm_riscv_aia_inject_msi_by_id(struct kvm *kvm, u32 hart_index,
+                                   u32 guest_index, u32 iid)
+{
+    // 根据hart_index查找对应的VCPU并注入MSI中断
+}
```

**分析**: 添加了通过hart索引注入MSI中断的功能，支持PMU溢出中断的注入。

## 4. 技术原理分析

### 4.1 RISC-V PMU虚拟化架构

```
Guest OS
   ↓ (SBI PMU调用)
KVM SBI PMU Handler
   ↓
kvm_riscv_vcpu_pmu_*() 函数
   ↓
Linux perf子系统
   ↓
物理PMU硬件
```

### 4.2 溢出处理流程

1. **物理溢出**: 物理PMU计数器溢出
2. **Host处理**: Linux perf子系统检测到溢出，调用注册的回调函数
3. **KVM处理**: `kvm_riscv_pmu_overflow()`函数被调用
4. **状态更新**: 设置溢出位图，更新共享内存
5. **中断注入**: 向guest注入PMU溢出中断
6. **Guest处理**: Guest OS的PMU驱动处理溢出中断

### 4.3 共享内存机制

通过SBI PMU snapshot功能，host和guest共享一块内存区域：

```c
struct riscv_pmu_snapshot_data {
    u64 ctr_overflow_mask;  // 溢出计数器掩码
    u64 ctr_values[];       // 计数器值数组
};
```

### 4.4 中断注入机制

使用RISC-V AIA (Advanced Interrupt Architecture)规范：
- **LCOFI中断**: Local Counter Overflow Interrupt
- **IRQ过滤**: 通过AIA的IRQ过滤机制注入到guest
- **ssaia依赖**: 需要host支持ssaia扩展

## 5. 相关提交分析

从git log可以看到，这个patch是一个PMU功能开发系列的一部分：

1. **c2f41ddbcdd7**: "RISC-V: KVM: Implement SBI PMU Snapshot feature" - 实现SBI PMU快照功能
2. **2196c066f138**: "RISC-V: KVM: No need to exit to the user space if perf event failed" - 优化perf事件失败处理
3. **98ce906bd0a6**: "RISC-V: KVM: No need to update the counter value during reset" - 优化重置时的计数器处理
4. **57990ab90ce3**: "RISC-V: KVM: Fix the initial sample period value" - 修复初始采样周期值
5. **a8625217a054**: "drivers/perf: riscv: Implement SBI PMU snapshot function" - 在perf驱动中实现SBI PMU快照

## 6. 影响和意义

### 6.1 功能增强

1. **完整的PMU虚拟化**: 为RISC-V KVM提供了完整的性能监控虚拟化支持
2. **采样支持**: guest可以进行性能采样分析，提升调试和优化能力
3. **标准兼容**: 遵循SBI PMU规范，确保与标准的兼容性

### 6.2 技术创新

1. **共享内存方案**: 由于硬件限制，创新性地使用共享内存传递溢出信息
2. **中断注入优化**: 利用AIA规范实现高效的中断注入
3. **零拷贝设计**: 通过直接内存访问避免数据拷贝开销

### 6.3 性能考虑

1. **低延迟**: 直接停止/启动perf事件，避免工作队列延迟
2. **精确计数**: 通过精确的周期重置确保计数准确性
3. **最小开销**: 只在必要时更新共享内存

## 7. 潜在问题和限制

### 7.1 硬件依赖

1. **ssaia扩展**: 需要host支持ssaia扩展才能使用采样功能
2. **sscofpmf扩展**: 需要特权模式过滤支持
3. **AIA支持**: 依赖于AIA硬件或软件实现

### 7.2 兼容性考虑

1. **向后兼容**: 在不支持的硬件上会优雅降级
2. **迁移支持**: 需要确保虚拟机迁移时状态的正确性
3. **版本兼容**: 需要与不同版本的SBI规范兼容

## 8. 总结

这个patch为RISC-V KVM添加了重要的性能采样支持，通过创新的共享内存机制和AIA中断注入，在硬件限制下实现了完整的PMU虚拟化功能。该实现不仅技术上先进，而且考虑了性能、兼容性和标准符合性，为RISC-V虚拟化生态系统的发展做出了重要贡献。

主要技术亮点：
- 创新的溢出处理机制
- 高效的中断注入方案  
- 完整的状态管理
- 标准规范兼容性

这个patch标志着RISC-V KVM在性能监控虚拟化方面达到了新的成熟度水平。