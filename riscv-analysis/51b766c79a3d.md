# Patch 分析报告: 51b766c79a3d

## 基本信息

**Commit ID:** 51b766c79a3d741fb97419c3da1c58fce5e66f0e  
**作者:** Samuel Holland <samuel.holland@sifive.com>  
**提交者:** Palmer Dabbelt <palmer@rivosinc.com>  
**提交日期:** 2024年10月26日  
**标题:** riscv: Support CONFIG_RELOCATABLE on NOMMU

## 1. Patch 概述

这个patch的主要目的是为RISC-V架构的NOMMU（无内存管理单元）配置添加CONFIG_RELOCATABLE支持。通过这个修改，可重定位的NOMMU内核可以加载到任何物理内存地址，不再依赖于CONFIG_PAGE_OFFSET。

## 2. 文件修改列表

### 修改的文件：
1. `arch/riscv/Kconfig` - 修改CONFIG_RELOCATABLE的依赖条件
2. `arch/riscv/include/asm/pgtable.h` - 为NOMMU配置添加KERNEL_LINK_ADDR定义
3. `arch/riscv/mm/init.c` - 重构relocate_kernel函数的位置和调用

## 3. 详细代码修改分析

### 3.1 arch/riscv/Kconfig 修改

```diff
 config RELOCATABLE
        bool "Build a relocatable kernel"
-       depends on MMU && 64BIT && !XIP_KERNEL
+       depends on 64BIT && !XIP_KERNEL
        select MODULE_SECTIONS if MODULES
        help
           This builds a kernel as a Position Independent Executable (PIE),
```

**修改原理：**
- 移除了对MMU的依赖要求
- 这使得NOMMU配置也可以启用CONFIG_RELOCATABLE选项
- 保留了对64BIT的要求和对XIP_KERNEL的排除

### 3.2 arch/riscv/include/asm/pgtable.h 修改

```diff
 #ifndef CONFIG_MMU
+#ifdef CONFIG_RELOCATABLE
+#define KERNEL_LINK_ADDR       UL(0)
+#else
 #define KERNEL_LINK_ADDR       _AC(CONFIG_PAGE_OFFSET, UL)
+#endif
 #define KERN_VIRT_SIZE         (UL(-1))
 #else
```

**修改原理：**
- 在NOMMU且启用RELOCATABLE的情况下，将KERNEL_LINK_ADDR设置为0
- 这允许内核在任何物理地址加载，而不依赖于固定的PAGE_OFFSET
- 在非RELOCATABLE的NOMMU配置中，仍然使用CONFIG_PAGE_OFFSET

### 3.3 arch/riscv/mm/init.c 修改

#### 3.3.1 relocate_kernel函数的移动

**原位置：** 在CONFIG_MMU块内部（约第1300行附近）  
**新位置：** 移动到CONFIG_MMU块外部（约第320行附近）

```c
#ifdef CONFIG_RELOCATABLE
extern unsigned long __rela_dyn_start, __rela_dyn_end;

static void __init relocate_kernel(void)
{
    Elf_Rela *rela = (Elf_Rela *)&__rela_dyn_start;
    /*
     * This holds the offset between the linked virtual address and the
     * relocated virtual address.
     */
    uintptr_t reloc_offset = kernel_map.virt_addr - KERNEL_LINK_ADDR;
    /*
     * This holds the offset between kernel linked virtual address and
     * physical address.
     */
    uintptr_t va_kernel_link_pa_offset = KERNEL_LINK_ADDR - kernel_map.phys_addr;

    for ( ; rela < (Elf_Rela *)&__rela_dyn_end; rela++) {
        Elf_Addr addr = (rela->r_offset - va_kernel_link_pa_offset);
        Elf_Addr relocated_addr = rela->r_addend;

        if (rela->r_info != R_RISCV_RELATIVE)
            continue;

        /*
         * Make sure to not relocate vdso symbols like rt_sigreturn
         * which are linked from the address 0 in vmlinux since
         * vdso symbol addresses are actually used as an offset from
         * mm->context.vdso in VDSO_OFFSET macro.
         */
        if (relocated_addr >= KERNEL_LINK_ADDR)
            relocated_addr += reloc_offset;

        *(Elf_Addr *)addr = relocated_addr;
    }
}
#endif /* CONFIG_RELOCATABLE */
```

#### 3.3.2 NOMMU版本的setup_vm函数修改

```diff
 asmlinkage void __init setup_vm(uintptr_t dtb_pa)
 {
        dtb_early_va = (void *)dtb_pa;
        dtb_early_pa = dtb_pa;
+
+#ifdef CONFIG_RELOCATABLE
+       kernel_map.virt_addr = (uintptr_t)_start;
+       kernel_map.phys_addr = (uintptr_t)_start;
+       relocate_kernel();
+#endif
 }
```

**修改原理：**
- 在NOMMU的setup_vm函数中添加了对relocate_kernel的调用
- 设置kernel_map.virt_addr和kernel_map.phys_addr为_start的地址
- 这确保了在NOMMU环境下也能正确进行内核重定位

## 4. 技术原理分析

### 4.1 内核重定位机制

内核重定位是通过处理ELF重定位表（.rela.dyn段）来实现的：

1. **重定位表遍历：** 遍历__rela_dyn_start到__rela_dyn_end之间的所有重定位条目
2. **地址计算：** 计算每个需要重定位的地址的新值
3. **符号更新：** 更新内存中的地址引用

### 4.2 地址计算逻辑

```c
uintptr_t reloc_offset = kernel_map.virt_addr - KERNEL_LINK_ADDR;
uintptr_t va_kernel_link_pa_offset = KERNEL_LINK_ADDR - kernel_map.phys_addr;
```

- `reloc_offset`: 链接时虚拟地址与运行时虚拟地址的偏移
- `va_kernel_link_pa_offset`: 链接时虚拟地址与物理地址的偏移

### 4.3 NOMMU特殊处理

在NOMMU环境下：
- 虚拟地址等于物理地址
- kernel_map.virt_addr = kernel_map.phys_addr = (uintptr_t)_start
- KERNEL_LINK_ADDR在RELOCATABLE模式下为0

## 5. 影响和意义

### 5.1 功能增强
- **灵活部署：** NOMMU内核可以加载到任意物理内存地址
- **引导简化：** 不再需要固定的内存布局要求
- **兼容性提升：** 支持更多样化的硬件配置

### 5.2 应用场景
- 嵌入式系统中的NOMMU RISC-V处理器
- 内存布局受限的系统
- 需要动态加载地址的引导场景

## 6. 相关提交分析

这个patch是RISC-V NOMMU支持改进系列的一部分，相关的提交包括：
- 改进NOMMU内存管理
- 优化NOMMU启动流程
- 增强NOMMU配置选项

## 7. 潜在风险和注意事项

### 7.1 兼容性考虑
- 需要确保引导加载器正确设置内核加载地址
- 可能影响某些依赖固定地址的代码

### 7.2 性能影响
- 重定位过程会增加启动时间
- 对运行时性能影响微乎其微

## 8. 总结

这个patch成功地将CONFIG_RELOCATABLE支持扩展到RISC-V的NOMMU配置，通过重构relocate_kernel函数的位置和调用方式，使得NOMMU内核具备了位置无关的能力。这是一个重要的功能增强，提高了RISC-V NOMMU系统的灵活性和适用性。

修改的核心思想是将原本仅在MMU环境下可用的内核重定位功能，通过适当的地址映射和函数重组，扩展到NOMMU环境中，从而实现了更好的硬件兼容性和部署灵活性。