# Patch Analysis: 4a73aff8c5e2

## 基本信息

**Commit ID:** 4a73aff8c5e2a156bb841f022df51c27e8104ac8  
**作者:** Charlie Jenkins <charlie@rivosinc.com>  
**提交日期:** Wed Jan 8 18:36:16 2025 -0800  
**标题:** perf tools: Create generic syscall table support  

## 修改概述

这个patch为perf工具创建了通用的系统调用表支持框架，统一了各架构在perf中独立生成系统调用头文件的方式。该框架首先在RISC-V架构中引入，使RISC-V的perf工具不再依赖外部的libaudit库。

## 详细修改内容

### 1. 文件变更统计

- **新增文件:** 5个
- **修改文件:** 8个  
- **删除文件:** 1个
- **总计:** 588行新增，77行删除

### 2. 主要修改文件分析

#### 2.1 tools/build/Build.include
```diff
+empty   :=
+space   := $(empty) $(empty)
```
- 添加了Makefile变量定义，用于处理空格和空字符串

#### 2.2 tools/perf/Makefile.config
```diff
+  # architectures that use the generic syscall table scripts
+  ifeq ($(SRCARCH),riscv)
+    NO_SYSCALL_TABLE := 0
+    CFLAGS += -DGENERIC_SYSCALL_TABLE
+    CFLAGS += -I$(OUTPUT)arch/$(SRCARCH)/include/generated
+  endif
```
- 为RISC-V架构启用通用系统调用表支持
- 添加GENERIC_SYSCALL_TABLE宏定义
- 设置包含路径指向生成的头文件目录

#### 2.3 tools/perf/Makefile.perf
```diff
+# architectures that use the generic syscall table
+ifeq ($(SRCARCH),riscv)
+include $(srctree)/tools/perf/scripts/Makefile.syscalls
+endif
```
- 为RISC-V架构包含新的系统调用表构建脚本

#### 2.4 tools/perf/arch/riscv/Makefile
- 移除了原有的RISC-V特定的系统调用表生成逻辑
- 删除了对libaudit的依赖

#### 2.5 新增核心文件

**tools/perf/scripts/Makefile.syscalls**
- 新的通用系统调用表构建脚本（61行Makefile）
- 定义了如何从syscall.tbl生成头文件的规则
- 核心特性：
  - 支持32位和64位ABI：`syscall_abis_32 := common,32` 和 `syscall_abis_64 := common,64`
  - 自动清理过时的头文件
  - 使用模式规则生成 `$(obj)/syscalls_%.h` 文件
  - 支持架构特定的覆盖配置
  - 集成到perf构建系统中

**tools/perf/scripts/syscalltbl.sh**
- 系统调用表生成脚本（86行shell脚本）
- 解析syscall.tbl文件并生成C头文件
- 支持ABI过滤功能（--abis参数）
- 核心功能：
  - 从syscall.tbl提取指定ABI的系统调用
  - 生成静态数组：`static const char *const syscalltbl[]`
  - 定义最大系统调用ID：`#define SYSCALLTBL_MAX_ID`
  - 使用临时文件进行排序处理
  - 支持多ABI组合（用逗号分隔）

**tools/scripts/syscall.tbl**
- 通用系统调用表文件
- 包含了所有系统调用的定义（467个系统调用，从0到466）
- 格式：NR ABI NAME [NATIVE] [COMPAT]
- 文件结构分析：
  - 系统调用号从0开始（io_setup）到466结束（removexattrat）
  - 最新添加的系统调用包括：landlock系列、futex新接口、LSM相关、mseal等
  - 支持时间相关的32位兼容性（time32、time64）
  - 包含最新的安全特性：landlock、LSM、mseal等

**tools/perf/arch/riscv/entry/syscalls/Kbuild**
- RISC-V架构的构建配置

**tools/perf/arch/riscv/entry/syscalls/Makefile.syscalls**
- RISC-V特定的系统调用表构建规则

**tools/perf/arch/riscv/include/syscall_table.h**
- RISC-V系统调用表头文件

### 3. 删除的文件

**tools/perf/arch/riscv/entry/syscalls/mksyscalltbl**
- 移除了RISC-V特定的系统调用表生成脚本（47行）

## 技术原理分析

### 1. 统一化设计

这个patch的核心思想是将内核中已经统一的系统调用头文件实现方式适配到perf工具中。之前每个架构都有自己独立的系统调用表生成方式，现在通过引入通用框架来统一处理。

### 2. 构建流程

1. **源文件:** `tools/scripts/syscall.tbl` - 包含所有系统调用定义
2. **生成脚本:** `tools/perf/scripts/syscalltbl.sh` - 解析syscall.tbl
3. **构建规则:** `tools/perf/scripts/Makefile.syscalls` - 定义构建过程
4. **输出文件:** 生成的C头文件包含系统调用表数组

### 3. ABI支持

脚本支持多种ABI：
- `common`: 通用系统调用
- `64`: 64位特定
- `32`: 32位特定  
- `time32`: 32位时间相关
- `stat64`: 64位stat相关
- `memfd_secret`: 特殊系统调用

### 4. 兼容性处理

- 支持native和compat两种入口点
- 处理不同架构的系统调用号差异
- 保持向后兼容性

## 影响分析

### 1. 正面影响

- **减少依赖:** RISC-V perf工具不再需要libaudit库
- **统一维护:** 所有架构可以共享相同的系统调用表
- **易于扩展:** 新架构可以更容易地采用这个框架
- **减少重复:** 避免每个架构重复实现相同功能

### 2. 潜在风险

- **架构特异性:** 某些架构可能有特殊的系统调用需求
- **构建复杂性:** 增加了构建系统的复杂度
- **调试难度:** 通用化可能使问题定位更困难

## 相关提交分析

### 1. 当前提交背景

这个patch是一个系列patch的第一个，从commit信息可以看出：
- Link: https://lore.kernel.org/r/20250108-perf_syscalltbl-v6-1-7543b5293098@rivosinc.com
- 这是v6版本的第1个patch，说明经过了多轮review和改进

### 2. 历史相关提交

通过git log分析，发现perf工具的系统调用表支持经历了多次演进：

- **16ab5c708d99** - "perf build: Remove Makefile.syscalls": 移除了旧的Makefile.syscalls
- **1470eaa57487** - "perf syscalltbl: Use lookup table containing multiple architectures": 使用包含多架构的查找表
- **0fb641f0a1e7** - "perf trace beauty: Add syscalltbl.sh generating all system call tables": 添加生成所有系统调用表的脚本
- **95b802ca9def** - "perf syscalltbl: Mask off ABI type for MIPS system calls": 为MIPS系统调用屏蔽ABI类型
- **ccc60dce3e2d** - "perf trace: Make syscall table stable": 使系统调用表稳定

### 3. 演进趋势

从这些提交可以看出，perf工具的系统调用表支持正在朝着统一化、通用化的方向发展：
1. 从架构特定实现转向通用框架
2. 提高系统调用表的稳定性和可维护性
3. 减少外部依赖（如libaudit）
4. 支持多架构统一管理

## 总结

这个patch是perf工具架构优化的重要一步，通过引入通用系统调用表支持框架，实现了代码的统一化和简化。虽然首先在RISC-V架构中实现，但为其他架构的后续迁移奠定了基础。这种设计符合内核开发中"不要重复造轮子"的原则，有助于长期维护和扩展。