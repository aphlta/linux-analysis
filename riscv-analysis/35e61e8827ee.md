# RISC-V ftrace优化patch分析报告

## Commit信息
- **Commit ID**: 35e61e8827ee8ea09e6093ab4d8ba45efd537e36
- **标题**: riscv: ftrace: Make function graph use ftrace directly
- **作者**: Song Shuai <suagrfillet@gmail.com>
- **日期**: Thu Nov 30 13:15:29 2023 +0100
- **签名者**: Palmer Dabbelt <palmer@rivosinc.com>

## 1. Patch概述

这个patch是对RISC-V架构ftrace子系统的重要优化，主要目标是简化function graph tracer的实现，使其直接使用ftrace机制而不需要特殊的graph tracer hook。这个优化参考了x86 (commit 0c0593b45c9b) 和 arm64 (commit c4a0ebf87ceb) 的类似实现。

### 修改文件统计
- `arch/riscv/include/asm/ftrace.h`: +11 -1
- `arch/riscv/kernel/ftrace.c`: +30 -30  
- `arch/riscv/kernel/mcount-dyn.S`: +190 -56
- **总计**: +175 -56

## 2. 技术原理分析

### 2.1 Function Graph Tracer工作原理

Function Graph Tracer是Linux内核中用于跟踪函数调用图的机制，它能够：
- 记录函数的进入和退出
- 测量函数执行时间
- 构建完整的函数调用关系图

传统实现需要两个独立的hook点：
1. **函数入口hook**: 记录函数调用
2. **专用graph hook**: 处理返回地址替换

### 2.2 优化原理

新的实现通过`graph_ops::func`函数直接安装return_hooker，消除了对专用graph tracer hook的需求：

```c
// 新增的ftrace_graph_func函数
void ftrace_graph_func(unsigned long ip, unsigned long parent_ip,
                      struct ftrace_ops *op, struct ftrace_regs *fregs)
{
    struct pt_regs *regs = arch_ftrace_get_regs(fregs);
    unsigned long *parent = (unsigned long *)&regs->ra;
    
    prepare_ftrace_return(parent, ip, frame_pointer(regs));
}
```

## 3. 详细代码修改分析

### 3.1 头文件修改 (arch/riscv/include/asm/ftrace.h)

```c
+#ifdef CONFIG_DYNAMIC_FTRACE_WITH_REGS
+struct ftrace_ops;
+struct ftrace_regs;
+void ftrace_graph_func(unsigned long ip, unsigned long parent_ip,
+                      struct ftrace_ops *op, struct ftrace_regs *fregs);
+#define ftrace_graph_func ftrace_graph_func
+#endif /* CONFIG_DYNAMIC_FTRACE_WITH_REGS */
```

**分析**:
- 新增`ftrace_graph_func`函数声明
- 仅在`CONFIG_DYNAMIC_FTRACE_WITH_REGS`配置下生效
- 通过宏定义确保函数可见性

### 3.2 核心逻辑修改 (arch/riscv/kernel/ftrace.c)

#### 3.2.1 新增ftrace_graph_func实现

```c
+#ifdef CONFIG_DYNAMIC_FTRACE_WITH_REGS
+void ftrace_graph_func(unsigned long ip, unsigned long parent_ip,
+                      struct ftrace_ops *op, struct ftrace_regs *fregs)
+{
+       struct pt_regs *regs = arch_ftrace_get_regs(fregs);
+       unsigned long *parent = (unsigned long *)&regs->ra;
+
+       prepare_ftrace_return(parent, ip, frame_pointer(regs));
+}
+#else /* CONFIG_DYNAMIC_FTRACE_WITH_REGS */
```

**技术要点**:
- 直接从`ftrace_regs`中提取寄存器状态
- 操作返回地址寄存器(`regs->ra`)
- 调用`prepare_ftrace_return`完成graph tracing设置

#### 3.2.2 简化enable/disable函数

**修改前**:
```c
int ftrace_enable_ftrace_graph_caller(void)
{
    int ret;
    ret = __ftrace_modify_call((unsigned long)&ftrace_graph_call,
                               (unsigned long)&prepare_ftrace_return, true, true);
    if (ret)
        return ret;
    
    return __ftrace_modify_call((unsigned long)&ftrace_graph_regs_call,
                               (unsigned long)&prepare_ftrace_return, true, true);
}
```

**修改后**:
```c
int ftrace_enable_ftrace_graph_caller(void)
{
    return __ftrace_modify_call((unsigned long)&ftrace_graph_call,
                               (unsigned long)&prepare_ftrace_return, true, true);
}
```

**优化效果**:
- 消除了对`ftrace_graph_regs_call`的处理
- 简化了错误处理逻辑
- 减少了代码复杂度

### 3.3 汇编代码重构 (arch/riscv/kernel/mcount-dyn.S)

#### 3.3.1 新增寄存器保存/恢复宏

```assembly
+       .macro SAVE_ABI_REGS, save_ret
+       addi    sp, sp, -PT_SIZE_ON_STACK
+       
+       REG_S   x1,  PT_RA(sp)
+       REG_S   x5,  PT_T0(sp)
+       REG_S   x6,  PT_T1(sp)
+       REG_S   x7,  PT_T2(sp)
+       REG_S   x10, PT_A0(sp)
+       REG_S   x11, PT_A1(sp)
+       REG_S   x12, PT_A2(sp)
+       REG_S   x13, PT_A3(sp)
+       REG_S   x14, PT_A4(sp)
+       REG_S   x15, PT_A5(sp)
+       REG_S   x16, PT_A6(sp)
+       REG_S   x17, PT_A7(sp)
+       REG_S   x28, PT_T3(sp)
+       REG_S   x29, PT_T4(sp)
+       REG_S   x30, PT_T5(sp)
+       REG_S   x31, PT_T6(sp)
```

**技术分析**:
- 实现了条件性寄存器保存
- `save_ret`参数控制是否保存额外寄存器
- 遵循RISC-V ABI调用约定

#### 3.3.2 统一参数准备宏

```assembly
+       .macro PREPARE_ARGS
+       addi    a0, t0, -FENTRY_RA_OFFSET
+       la      a1, function_trace_op
+       REG_L   a2, 0(a1)
+       mv      a1, ra
+       mv      a3, sp
+       .endm
```

**功能说明**:
- 标准化ftrace函数调用参数准备
- `a0`: 调整后的指令指针
- `a1`: 返回地址
- `a2`: ftrace操作结构
- `a3`: 栈指针

#### 3.3.3 重构ftrace_regs_caller

**修改前的复杂实现**:
```assembly
SYM_FUNC_START(ftrace_regs_caller)
    SAVE_ALL
    
    addi    a0, t0, -FENTRY_RA_OFFSET
    la      a1, function_trace_op
    REG_L   a2, 0(a1)
    mv      a1, ra
    mv      a3, sp
    
    # 复杂的graph tracer处理
    #ifdef CONFIG_FUNCTION_GRAPH_TRACER
    addi    a0, sp, PT_RA
    REG_L   a1, PT_EPC(sp)
    addi    a1, a1, -FENTRY_RA_OFFSET
    #ifdef HAVE_FUNCTION_GRAPH_FP_TEST
    mv      a2, s0
    #endif
    SYM_INNER_LABEL(ftrace_graph_regs_call, SYM_L_GLOBAL)
    call    ftrace_stub
    #endif
    
    RESTORE_ALL
    jr t0
SYM_FUNC_END(ftrace_regs_caller)
```

**修改后的简化实现**:
```assembly
SYM_FUNC_START(ftrace_regs_caller)
    SAVE_ABI_REGS 1
    PREPARE_ARGS
    
SYM_INNER_LABEL(ftrace_regs_call, SYM_L_GLOBAL)
    call    ftrace_stub
    
    RESTORE_ABI_REGS 1
    jr      t0
SYM_FUNC_END(ftrace_regs_caller)
```

**优化效果**:
- 消除了专用的graph tracer汇编代码
- 使用统一的宏简化代码
- 减少了条件编译复杂度

## 4. 架构对比分析

### 4.1 与x86实现对比

x86的优化 (commit 0c0593b45c9b) 主要特点：
- 引入了`FTRACE_OPS_GRAPH_STUB`标志
- 修改了通用ftrace框架
- 简化了架构特定代码

### 4.2 与arm64实现对比

arm64的优化 (commit c4a0ebf87ceb) 特点：
- 类似的`ftrace_graph_func`实现
- 消除了`ftrace_graph_caller`汇编函数
- 简化了enable/disable逻辑

### 4.3 RISC-V特有优化

RISC-V实现的独特之处：
- 更细粒度的寄存器保存策略
- 条件性寄存器保存机制
- 统一的参数准备宏

## 5. 性能影响分析

### 5.1 性能优势

1. **减少代码路径**
   - 消除了专用graph hook
   - 简化了函数调用链
   - 减少了分支预测失败

2. **内存访问优化**
   - 减少了不必要的寄存器保存/恢复
   - 优化了栈操作
   - 改善了缓存局部性

3. **维护成本降低**
   - 代码复杂度降低
   - 减少了条件编译
   - 统一了处理逻辑

### 5.2 兼容性考虑

- **仅影响FTRACE_WITH_REGS实现**
- **保持mcount-based实现不变**
- **向后兼容现有接口**

## 6. 相关提交分析

### 6.1 参考提交

1. **x86优化**: commit 0c0593b45c9b "x86/ftrace: Make function graph use ftrace directly"
   - 建立了优化模式的基础框架
   - 引入了通用的ftrace graph机制

2. **arm64优化**: commit c4a0ebf87ceb "arm64/ftrace: Make function graph use ftrace directly"
   - 提供了架构特定实现的参考
   - 验证了优化方案的可行性

### 6.2 测试和验证

- **测试者**: Guo Ren <guoren@kernel.org>
- **审核者**: Björn Töpel <bjorn@rivosinc.com>
- **邮件列表**: https://lore.kernel.org/r/20231130121531.1178502-3-bjorn@kernel.org

## 7. 技术要点总结

### 7.1 关键技术创新

1. **统一的ftrace处理机制**
   - 通过`ftrace_graph_func`统一处理
   - 消除了架构特定的复杂性

2. **优化的寄存器管理**
   - 条件性寄存器保存
   - 减少了不必要的开销

3. **简化的汇编实现**
   - 宏化的通用操作
   - 减少了代码重复

### 7.2 设计原则

1. **性能优先**: 减少运行时开销
2. **代码简化**: 降低维护复杂度
3. **架构统一**: 与其他架构保持一致
4. **向后兼容**: 不破坏现有功能

## 8. 影响和意义

### 8.1 对RISC-V生态的影响

- **提升调试效率**: 更高效的函数跟踪
- **降低性能开销**: 优化的实现减少了运行时成本
- **改善开发体验**: 简化的代码便于理解和维护

### 8.2 对内核社区的贡献

- **架构统一性**: 与主流架构保持一致
- **最佳实践**: 为其他架构提供参考
- **代码质量**: 提升了整体代码质量

## 9. 结论

这个patch是RISC-V架构ftrace子系统的重要优化，通过借鉴x86和arm64的成功经验，实现了function graph tracer的简化和性能提升。主要成就包括：

1. **消除了专用graph tracer hook的需求**
2. **简化了汇编代码实现**
3. **提升了运行时性能**
4. **降低了维护复杂度**
5. **保持了完整的向后兼容性**

这个优化不仅提升了RISC-V架构的ftrace性能，也为RISC-V在生产环境中的应用提供了更好的调试和性能分析能力。