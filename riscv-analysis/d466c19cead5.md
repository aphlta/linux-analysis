# RISC-V KVM NACL (Nested Acceleration) 支持补丁分析

## 1. 补丁基本信息

**Commit ID:** d466c19cead5904d4d5d92adb2b213b411d3b849  
**作者:** Anup Patel <apatel@ventanamicro.com>  
**提交者:** Anup Patel <anup@brainfault.org>  
**提交日期:** 2024年10月28日  
**标题:** RISC-V: KVM: Add common nested acceleration support

**修改文件统计:**
- arch/riscv/include/asm/kvm_nacl.h: 新增文件，239行
- arch/riscv/kvm/Makefile: 修改，添加nacl.o编译目标
- arch/riscv/kvm/main.c: 修改，51行新增，2行删除
- arch/riscv/kvm/nacl.c: 新增文件，152行
- 总计: 441行新增，2行删除

## 2. 补丁详细分析

### 2.1 补丁目的

本补丁为RISC-V KVM添加了通用的嵌套加速(Nested Acceleration)支持，该功能将被KVM RISC-V的所有部分共享使用。嵌套加速支持检测并启用SBI NACL扩展的使用，基于静态键(static keys)实现，确保对非嵌套场景的影响最小。

### 2.2 NACL技术背景

NACL (Nested Acceleration)是RISC-V SBI规范中的一个扩展，专门用于优化嵌套虚拟化场景。当KVM运行在另一个hypervisor之上时，NACL提供了更高效的虚拟化操作实现，主要包括：

1. **CSR同步优化** - 通过共享内存机制优化控制状态寄存器访问
2. **HFENCE操作优化** - 提供更高效的TLB刷新操作
3. **SRET操作优化** - 优化特权级返回操作
4. **CSR自动交换** - 支持CSR的自动交换机制

## 3. 代码修改详细分析

### 3.1 新增头文件: arch/riscv/include/asm/kvm_nacl.h

#### 3.1.1 静态键定义
```c
DECLARE_STATIC_KEY_FALSE(kvm_riscv_nacl_available);
DECLARE_STATIC_KEY_FALSE(kvm_riscv_nacl_sync_csr_available);
DECLARE_STATIC_KEY_FALSE(kvm_riscv_nacl_sync_hfence_available);
DECLARE_STATIC_KEY_FALSE(kvm_riscv_nacl_sync_sret_available);
DECLARE_STATIC_KEY_FALSE(kvm_riscv_nacl_autoswap_csr_available);
```

这些静态键用于运行时检测NACL功能的可用性，采用unlikely分支优化，确保在非嵌套场景下的性能开销最小。

#### 3.1.2 Per-CPU数据结构
```c
struct kvm_riscv_nacl {
    void *shmem;           // 共享内存虚拟地址
    phys_addr_t shmem_phys; // 共享内存物理地址
};
DECLARE_PER_CPU(struct kvm_riscv_nacl, kvm_riscv_nacl);
```

每个CPU都有独立的共享内存区域，用于与底层hypervisor进行高效的数据交换。

#### 3.1.3 CSR访问宏定义
```c
#define ncsr_read(__csr) \
({ \
    unsigned long __r; \
    if (kvm_riscv_nacl_available()) \
        __r = nacl_csr_read(nacl_shmem(), __csr); \
    else \
        __r = csr_read(__csr); \
    __r; \
})
```

提供了统一的CSR访问接口，根据NACL可用性自动选择最优的访问方式。

#### 3.1.4 HFENCE操作宏定义
```c
#define nacl_hfence_gvma_vmid_all(__shmem, __vmid) \
__kvm_riscv_nacl_hfence(__shmem, \
    nacl_hfence_mkconfig(SBI_NACL_SHMEM_HFENCE_TYPE_GVMA_VMID_ALL, \
                       0, __vmid, 0), 0, 0)
```

定义了各种HFENCE操作的宏，支持不同类型的TLB刷新操作。

### 3.2 新增实现文件: arch/riscv/kvm/nacl.c

#### 3.2.1 静态键实现
```c
DEFINE_STATIC_KEY_FALSE(kvm_riscv_nacl_available);
DEFINE_STATIC_KEY_FALSE(kvm_riscv_nacl_sync_csr_available);
DEFINE_STATIC_KEY_FALSE(kvm_riscv_nacl_sync_hfence_available);
DEFINE_STATIC_KEY_FALSE(kvm_riscv_nacl_sync_sret_available);
DEFINE_STATIC_KEY_FALSE(kvm_riscv_nacl_autoswap_csr_available);
```

#### 3.2.2 HFENCE操作实现
```c
void __kvm_riscv_nacl_hfence(void *shmem,
                 unsigned long control,
                 unsigned long page_num,
                 unsigned long page_count)
{
    int i, ent = -1, try_count = 5;
    unsigned long *entp;

    // 查找空闲的HFENCE条目
    for (i = 0; i < SBI_NACL_SHMEM_HFENCE_ENTRY_MAX; i++) {
        entp = shmem + SBI_NACL_SHMEM_HFENCE_ENTRY_CONFIG(i);
        if (lelong_to_cpu(*entp) & SBI_NACL_SHMEM_HFENCE_CONFIG_PEND)
            continue;
        ent = i;
        break;
    }
    
    // 如果没有空闲条目，同步等待
    if (ent < 0) {
        if (try_count) {
            nacl_sync_hfence(-1UL);
            goto again;
        }
    }
    
    // 设置HFENCE参数
    entp = shmem + SBI_NACL_SHMEM_HFENCE_ENTRY_CONFIG(i);
    *entp = cpu_to_lelong(control);
    // ...
}
```

该函数实现了通过共享内存进行HFENCE操作的核心逻辑。

#### 3.2.3 初始化函数
```c
int kvm_riscv_nacl_init(void)
{
    // 检查SBI版本和NACL扩展支持
    if (sbi_spec_version < sbi_mk_version(1, 0) ||
        sbi_probe_extension(SBI_EXT_NACL) <= 0)
        return -ENODEV;

    // 启用NACL支持
    static_branch_enable(&kvm_riscv_nacl_available);

    // 探测并启用各种NACL特性
    if (nacl_probe_feature(SBI_NACL_FEAT_SYNC_CSR))
        static_branch_enable(&kvm_riscv_nacl_sync_csr_available);
    // ...

    // 为每个CPU分配共享内存
    for_each_possible_cpu(cpu) {
        nacl = per_cpu_ptr(&kvm_riscv_nacl, cpu);
        shmem_page = alloc_pages(GFP_KERNEL | __GFP_ZERO,
                               get_order(SBI_NACL_SHMEM_SIZE));
        nacl->shmem = page_to_virt(shmem_page);
        nacl->shmem_phys = page_to_phys(shmem_page);
    }
}
```

### 3.3 主文件修改: arch/riscv/kvm/main.c

#### 3.3.1 虚拟化启用函数修改
```c
int kvm_arch_enable_virtualization_cpu(void)
{
    int rc;

    // 启用NACL支持
    rc = kvm_riscv_nacl_enable();
    if (rc)
        return rc;

    // 原有的虚拟化设置代码
    csr_write(CSR_HEDELEG, KVM_HEDELEG_DEFAULT);
    // ...
}
```

#### 3.3.2 虚拟化禁用函数修改
```c
void kvm_arch_disable_virtualization_cpu(void)
{
    // 原有的清理代码
    // ...
    
    // 禁用NACL支持
    kvm_riscv_nacl_disable();
}
```

#### 3.3.3 模块初始化修改
```c
static int __init riscv_kvm_init(void)
{
    // 初始化NACL支持
    rc = kvm_riscv_nacl_init();
    if (rc && rc != -ENODEV)
        return rc;
    
    // 原有的初始化代码
    // ...
}
```

## 4. 技术原理分析

### 4.1 静态键优化机制

本补丁大量使用了Linux内核的静态键(static keys)机制，这是一种运行时代码修补技术：

1. **编译时默认**: 所有NACL相关的分支默认为false，编译器生成直接跳转指令
2. **运行时检测**: 在初始化时检测NACL支持情况
3. **动态修补**: 如果支持NACL，则修补跳转指令，启用NACL代码路径
4. **零开销**: 在非嵌套场景下，NACL检查的开销为零

### 4.2 共享内存机制

#### 4.2.1 内存布局
共享内存区域包含以下部分：
- CSR数组区域: 存储虚拟化相关的控制状态寄存器值
- 脏位图区域: 标记哪些CSR被修改过
- HFENCE条目区域: 存储待执行的HFENCE操作
- 临时区域: 用于参数传递

#### 4.2.2 同步机制
- **异步操作**: CSR写入和HFENCE操作通过共享内存异步提交
- **同步点**: 在需要时通过SBI调用强制同步
- **批处理**: 多个操作可以批量提交，提高效率

### 4.3 字节序处理

```c
#ifdef CONFIG_32BIT
#define lelong_to_cpu(__x)  le32_to_cpu(__x)
#define cpu_to_lelong(__x)  cpu_to_le32(__x)
#else
#define lelong_to_cpu(__x)  le64_to_cpu(__x)
#define cpu_to_lelong(__x)  cpu_to_le64(__x)
#endif
```

共享内存中的数据使用小端序存储，确保与底层hypervisor的兼容性。

## 5. 相关提交分析

### 5.1 前置提交
- **5daf89e73d77**: "RISC-V: Add defines for the SBI nested acceleration extension" - 添加SBI NACL扩展的定义
- **8f57adac3916**: "RISC-V: KVM: Break down the __kvm_riscv_switch_to() into macros" - 为NACL集成准备代码结构

### 5.2 后续提交
- **5bdecd891e50**: "RISC-V: KVM: Use NACL HFENCEs for KVM request based HFENCEs" - 在KVM请求处理中使用NACL HFENCE
- **dab55604aec5**: "RISC-V: KVM: Use nacl_csr_xyz() for accessing AIA CSRs" - 在AIA中使用NACL CSR访问
- **e28e6b69767b**: "RISC-V: KVM: Use nacl_csr_xyz() for accessing H-extension CSRs" - 在H扩展中使用NACL CSR访问

## 6. 性能影响分析

### 6.1 非嵌套场景
- **零开销**: 通过静态键机制，在非嵌套场景下NACL检查的开销为零
- **代码大小**: 增加的代码在非嵌套场景下不会被执行

### 6.2 嵌套场景
- **CSR访问优化**: 通过共享内存减少陷入开销
- **HFENCE批处理**: 支持批量TLB刷新操作
- **异步操作**: 减少同步等待时间

## 7. 安全性考虑

### 7.1 内存安全
- **Per-CPU隔离**: 每个CPU有独立的共享内存区域
- **内存清零**: 分配时使用__GFP_ZERO标志清零内存
- **边界检查**: 在访问共享内存时进行适当的边界检查

### 7.2 特权级安全
- **SBI接口**: 通过标准SBI接口与底层hypervisor交互
- **权限检查**: 依赖底层hypervisor进行权限验证

## 8. 总结

本补丁为RISC-V KVM引入了NACL嵌套加速支持，这是一个重要的性能优化功能。主要特点包括：

1. **设计优雅**: 使用静态键确保对非嵌套场景零影响
2. **功能完整**: 支持CSR同步、HFENCE优化等多种加速特性
3. **实现高效**: 通过共享内存和批处理机制提高性能
4. **扩展性好**: 为后续的NACL功能集成奠定了基础

该补丁是RISC-V虚拟化技术发展的重要里程碑，为嵌套虚拟化场景提供了显著的性能提升。