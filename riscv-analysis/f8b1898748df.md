# RISC-V TASK_SIZE_MAX Revert Patch 分析

## Commit 信息

**Commit ID**: f8b1898748df  
**作者**: Nam Cao <namcao@linutronix.de>  
**日期**: Thu Jun 19 17:58:58 2025 +0200  
**标题**: Revert "riscv: Define TASK_SIZE_MAX for __access_ok()"  

## 修改内容概述

这个patch是一个revert操作，撤销了之前的commit ad5643cf2f69 ("riscv: Define TASK_SIZE_MAX for __access_ok()")。

### 具体代码修改

**文件**: `arch/riscv/include/asm/pgtable.h`

```diff
 #ifdef CONFIG_64BIT
 #define TASK_SIZE_64   (PGDIR_SIZE * PTRS_PER_PGD / 2)
-#define TASK_SIZE_MAX  LONG_MAX
 
 #ifdef CONFIG_COMPAT
 #define TASK_SIZE_32   (_AC(0x80000000, UL) - PAGE_SIZE)
```

## 原始Patch背景分析

### 被Revert的Commit (ad5643cf2f69)

**作者**: Samuel Holland <samuel.holland@sifive.com>  
**日期**: Wed Mar 27 07:38:13 2024 -0700  
**目的**: 优化 `__access_ok()` 函数的性能

#### 原始优化逻辑

1. **性能优化目标**: 将 `TASK_SIZE_MAX` 设置为常量 `LONG_MAX`，避免运行时计算 `TASK_SIZE` 的开销
2. **理论基础**: 
   - 所有用户地址都小于 `LONG_MAX`
   - 所有内核地址都大于 `LONG_MAX`
   - 因此 `access_ok()` 可以通过简单的符号位测试来过滤内核地址
3. **RISC-V特性**: 利用RISC-V要求所有虚拟地址必须进行符号扩展的特性

## 问题分析

### 核心问题

原始优化存在一个关键缺陷：**地址验证不完整**

#### 地址空间分析

1. **有效用户地址**: `[0, TASK_SIZE)`
2. **无效但被接受的地址**: `[TASK_SIZE, LONG_MAX]`
3. **内核地址**: `(LONG_MAX, ULONG_MAX]`

#### access_ok() 函数实现

```c
// include/asm-generic/access_ok.h
static inline int __access_ok(const void __user *ptr, unsigned long size)
{
    unsigned long limit = TASK_SIZE_MAX;  // 原来是 LONG_MAX
    unsigned long addr = (unsigned long)ptr;
    
    return (size <= limit) && (addr <= (limit - size));
}
```

### 问题场景

#### get_user_pages_fast() 的漏洞

1. **函数调用链**:
   ```
   futex() -> get_user_pages_fast() -> gup_fast_fallback()
   ```

2. **地址检查逻辑**:
   ```c
   // mm/gup.c: gup_fast_fallback()
   if (end > TASK_SIZE_MAX)  // 使用 LONG_MAX 时检查失效
       return -EFAULT;
   ```

3. **问题**: `get_user_pages_fast()` 会接受 `[TASK_SIZE, LONG_MAX]` 范围内的地址，这些地址在硬件层面无效，但软件层面被错误接受

### 实际影响

1. **数据完整性**: 可能访问到无效的内存区域
2. **系统稳定性**: 在某些情况下可能导致系统异常
3. **安全性**: 潜在的内存访问越界风险

## 修复方案

### Revert决策

**选择revert而非修复的原因**:

1. **正确性优先**: "correctness first, we can think about optimization later"
2. **影响范围**: 问题可能影响多个子系统，revert是最安全的选择
3. **性能权衡**: 虽然性能有所下降，但确保了系统的正确性

### 修复后的行为

1. **TASK_SIZE_MAX**: 恢复为默认值 `TASK_SIZE`
2. **地址检查**: 更严格的地址验证，只接受 `[0, TASK_SIZE)` 范围内的地址
3. **性能影响**: `TASK_SIZE` 需要运行时计算，相比 `LONG_MAX` 有性能开销

## 技术原理深入分析

### RISC-V地址空间布局

```
64位RISC-V地址空间:
- 用户空间: 0x0000_0000_0000_0000 - TASK_SIZE
- 无效区域: TASK_SIZE - 0x7FFF_FFFF_FFFF_FFFF (LONG_MAX)
- 内核空间: 0x8000_0000_0000_0000 - 0xFFFF_FFFF_FFFF_FFFF
```

### access_ok() 优化原理

#### 原始优化 (有问题的版本)
```c
#define TASK_SIZE_MAX LONG_MAX

// 简化为符号位检查
static inline int __access_ok(const void __user *ptr, unsigned long size)
{
    // 当 limit = LONG_MAX 时，检查简化为:
    // return (addr >= 0);  // 符号位检查
}
```

#### 修复后的版本
```c
#define TASK_SIZE_MAX TASK_SIZE  // 运行时计算

static inline int __access_ok(const void __user *ptr, unsigned long size)
{
    unsigned long limit = TASK_SIZE;  // 需要运行时计算
    unsigned long addr = (unsigned long)ptr;
    
    return (size <= limit) && (addr <= (limit - size));
}
```

### TASK_SIZE 计算复杂性

```c
// arch/riscv/include/asm/pgtable.h
#ifdef CONFIG_64BIT
#define TASK_SIZE_64    (PGDIR_SIZE * PTRS_PER_PGD / 2)

#ifdef CONFIG_COMPAT
#define TASK_SIZE_32    (_AC(0x80000000, UL) - PAGE_SIZE)
#define TASK_SIZE       (is_compat_task() ? TASK_SIZE_32 : TASK_SIZE_64)
#else
#define TASK_SIZE       TASK_SIZE_64
#endif
#endif
```

**计算开销**:
- 需要检查当前任务是否为compat模式
- 可能涉及页表配置的运行时查询
- 相比常量 `LONG_MAX` 有明显的性能开销

## 相关提交分析

### 修复链

1. **ad5643cf2f69**: 引入优化 (2024-03-27)
2. **f8b1898748df**: Revert优化 (2025-06-19)

### 报告者

**Robert Morris** <rtm@csail.mit.edu> - MIT CSAIL  
发现并报告了这个问题，提供了具体的复现场景

### 审查者

**Alexandre Ghiti** <alexghiti@rivosinc.com> - 审查并确认了修复方案

## 影响评估

### 性能影响

1. **回退**: `access_ok()` 性能回到优化前水平
2. **频率**: 每次用户空间内存访问都会受影响
3. **量化**: 具体性能损失取决于 `TASK_SIZE` 计算的复杂度

### 稳定性提升

1. **内存安全**: 消除了无效地址访问的风险
2. **系统稳定**: 避免了潜在的系统异常
3. **兼容性**: 确保与现有代码的兼容性

## 总结

这个patch体现了内核开发中"正确性优先于性能"的重要原则。虽然revert了一个有意义的性能优化，但确保了系统的正确性和稳定性。这个案例也说明了:

1. **地址验证的重要性**: 即使是看似简单的优化也可能引入安全漏洞
2. **测试覆盖的必要性**: 需要覆盖边界情况和异常路径
3. **架构特性的双刃剑**: RISC-V的地址扩展特性既可以用于优化，也可能引入问题
4. **性能与安全的平衡**: 在追求性能的同时必须确保系统的正确性

未来如果要重新实现类似的优化，需要更仔细地分析所有可能的代码路径，确保不会引入安全漏洞。