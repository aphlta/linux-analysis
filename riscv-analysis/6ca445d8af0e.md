# Patch Analysis: 6ca445d8af0e - riscv: Fix early ftrace nop patching

## 基本信息

- **Commit ID**: 6ca445d8af0e
- **标题**: riscv: Fix early ftrace nop patching
- **作者**: Alexandre Ghiti <alexghiti@rivosinc.com>
- **提交日期**: Thu May 23 13:51:34 2024 +0200
- **修复的提交**: c97bf629963e ("riscv: Fix text patching when IPI are used")

## 问题背景

### 原始问题

在commit c97bf629963e中，`ftrace_make_nop()`函数被修改为使用`patch_insn_write()`函数，该函数不会发出任何icache flush操作，而是完全依赖`__ftrace_modify_code()`来执行icache flush。

### 遗漏的场景

但是开发者遗漏了一个重要场景：`ftrace_make_nop()`在系统启动早期会被直接调用，用于将mcount调用转换为nops（在RISC-V架构上，实际上是将编译器生成的2字节nops转换为4字节nops）。

### 导致的问题

这个遗漏导致了多个硬件平台上的崩溃，如Conor和Björn报告的那样。问题的根本原因是：
- 启动核心的icache中可能包含半修补的指令
- 这些半修补的指令会触发非法指令陷阱
- 导致系统崩溃

## 代码修改分析

### 修改的文件

1. `arch/riscv/include/asm/cacheflush.h` (+6行)
2. `arch/riscv/kernel/ftrace.c` (+3行)

### 具体修改内容

#### 1. cacheflush.h 新增函数

```c
static inline void local_flush_icache_range(unsigned long start,
                                           unsigned long end)
{
       local_flush_icache_all();
}
```

**分析**:
- 新增了`local_flush_icache_range()`函数
- 该函数内部调用`local_flush_icache_all()`
- `local_flush_icache_all()`使用RISC-V的`fence.i`指令来刷新icache
- 这是一个本地操作，只影响当前CPU核心

#### 2. ftrace.c 修改ftrace_init_nop函数

```c
int ftrace_init_nop(struct module *mod, struct dyn_ftrace *rec)
{
       int out;

       mutex_lock(&text_mutex);
       out = ftrace_make_nop(mod, rec, MCOUNT_ADDR);
       mutex_unlock(&text_mutex);

+      if (!mod)
+              local_flush_icache_range(rec->ip, rec->ip + MCOUNT_INSN_SIZE);

       return out;
}
```

**分析**:
- 在`ftrace_init_nop()`函数中添加了条件性的icache flush
- 条件`if (!mod)`表示只有在非模块代码（即内核核心代码）时才执行flush
- 这是因为模块代码的ftrace处理有不同的机制
- flush的范围是`rec->ip`到`rec->ip + MCOUNT_INSN_SIZE`，即被修补的指令范围

## 技术原理分析

### RISC-V指令缓存机制

1. **指令缓存一致性**: RISC-V架构要求在修改指令后显式刷新icache
2. **fence.i指令**: RISC-V提供`fence.i`指令来刷新当前CPU的指令缓存
3. **多核同步**: 在多核系统中，需要确保所有CPU核心的icache都得到更新

### Ftrace工作机制

1. **早期初始化**: 在系统启动早期，ftrace需要将编译器插入的mcount调用点转换为nops
2. **运行时修改**: 在系统运行时，ftrace可以动态地在这些点插入跟踪代码
3. **指令修补**: RISC-V上使用4字节的nop指令替换原有的2字节nop

### 问题的根本原因

1. **时序问题**: 在早期启动阶段，IPI机制可能还未完全初始化
2. **缓存不一致**: 修改指令后没有及时刷新icache，导致CPU执行过时的指令
3. **半修补状态**: 在多字节指令修改过程中，CPU可能看到部分修改的指令

## 修复方案的设计思路

### 1. 最小化影响
- 只在必要时（非模块代码）添加icache flush
- 使用本地flush而不是全局flush，减少性能影响

### 2. 精确范围
- 只flush被修改的指令范围
- 使用`MCOUNT_INSN_SIZE`确保覆盖完整的指令

### 3. 条件执行
- 通过`if (!mod)`条件，区分内核代码和模块代码
- 模块代码有自己的处理机制，不需要额外的flush

## 相关提交分析

### 被修复的提交: c97bf629963e

该提交的主要变化：
1. 将`ftrace_make_nop()`从使用`patch_text_nosync()`改为使用`patch_insn_write()`
2. `patch_insn_write()`不执行icache flush，依赖调用者处理
3. 在`patch_text_cb()`中添加了`local_flush_icache_all()`调用
4. 使用`atomic_inc_return_release()`确保内存序

### 问题的引入

c97bf629963e提交解决了IPI使用时的文本修补问题，但引入了早期ftrace nop修补的问题：
- 早期调用`ftrace_init_nop()`时，不会经过`patch_text_cb()`的代码路径
- 因此不会执行icache flush
- 导致指令缓存不一致

## 测试和验证

### 报告者和测试者
- **报告者**: Conor Dooley <conor.dooley@microchip.com>
- **测试者**: 
  - Conor Dooley <conor.dooley@microchip.com>
  - Björn Töpel <bjorn@rivosinc.com>
- **审查者**: Björn Töpel <bjorn@rivosinc.com>

### 测试场景
- 多种RISC-V硬件平台
- 系统启动过程中的ftrace初始化
- 验证不再出现非法指令陷阱

## 性能影响分析

### 正面影响
- 修复了系统崩溃问题
- 确保了指令缓存一致性

### 负面影响
- 在早期ftrace初始化时增加了icache flush开销
- 但这个开销只在系统启动时发生，对运行时性能影响很小

### 优化考虑
- 使用本地flush而不是全局flush
- 只在非模块代码时执行flush
- flush范围精确到被修改的指令

## 总结

这个patch是一个典型的缓存一致性修复，解决了RISC-V架构上ftrace早期初始化时的指令缓存不一致问题。修复方案简洁有效，通过在适当的时机添加本地icache flush操作，确保了指令修改的原子性和一致性。这个修复对于RISC-V平台的稳定性至关重要，特别是在使用ftrace功能时。

## 相关链接

- **邮件列表讨论**: https://lore.kernel.org/r/20240523115134.70380-1-alexghiti@rivosinc.com
- **修复的原始提交**: c97bf629963e ("riscv: Fix text patching when IPI are used")