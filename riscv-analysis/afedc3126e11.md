# Patch 分析报告: afedc3126e11

## 基本信息

**Commit ID:** afedc3126e11ff1404b32e538657b68022e933ca  
**作者:** Alexandre Ghiti <alexghiti@rivosinc.com>  
**提交日期:** Wed Oct 9 09:27:49 2024 +0200  
**标题:** riscv: Do not use fortify in early code  
**链接:** https://lore.kernel.org/r/20241009072749.45006-1-alexghiti@rivosinc.com  
**签署者:** Palmer Dabbelt <palmer@rivosinc.com>  

## 修改内容概述

这个patch解决了RISC-V架构中FORTIFY_SOURCE在早期代码(Pre-MMU execution)中导致内核panic的问题。通过在相关的Makefile中添加`-D__NO_FORTIFY`编译选项来禁用FORTIFY_SOURCE功能。

### 具体修改文件

1. **arch/riscv/errata/Makefile** (+6行)
2. **arch/riscv/kernel/Makefile** (+5行)  
3. **arch/riscv/kernel/pi/Makefile** (+6行, -1行)

## 详细修改分析

### 1. arch/riscv/errata/Makefile

```makefile
+ifdef CONFIG_RISCV_ALTERNATIVE_EARLY
+ifdef CONFIG_FORTIFY_SOURCE
+KBUILD_CFLAGS += -D__NO_FORTIFY
+endif
+endif
```

**作用:** 当启用了`CONFIG_RISCV_ALTERNATIVE_EARLY`和`CONFIG_FORTIFY_SOURCE`时，为errata处理代码禁用FORTIFY功能。

### 2. arch/riscv/kernel/Makefile

```makefile
+ifdef CONFIG_FORTIFY_SOURCE
+CFLAGS_alternative.o += -D__NO_FORTIFY
+CFLAGS_cpufeature.o += -D__NO_FORTIFY
+CFLAGS_sbi_ecall.o += -D__NO_FORTIFY
+endif
```

**作用:** 为以下关键的早期代码文件禁用FORTIFY:
- `alternative.o`: 处理CPU特性替换的代码
- `cpufeature.o`: CPU特性检测代码
- `sbi_ecall.o`: SBI调用接口代码

### 3. arch/riscv/kernel/pi/Makefile

```makefile
 CFLAGS_cmdline_early.o += -D__NO_FORTIFY
-CFLAGS_lib-fdt_ro.o += -D__NO_FORTIFY
 CFLAGS_fdt_early.o += -D__NO_FORTIFY
+# lib/string.c already defines __NO_FORTIFY
+CFLAGS_ctype.o += -D__NO_FORTIFY
+CFLAGS_lib-fdt.o += -D__NO_FORTIFY
+CFLAGS_lib-fdt_ro.o += -D__NO_FORTIFY
+CFLAGS_archrandom_early.o += -D__NO_FORTIFY
```

**作用:** 扩展了Position Independent (PI)代码中禁用FORTIFY的文件范围，包括:
- `ctype.o`: 字符类型处理
- `lib-fdt.o`: 设备树库函数
- `archrandom_early.o`: 早期随机数生成

## 问题背景分析

### 1. FORTIFY_SOURCE功能

FORTIFY_SOURCE是GCC提供的一个安全特性，用于:
- 检测缓冲区溢出
- 在编译时和运行时进行边界检查
- 替换不安全的字符串函数调用

### 2. 早期代码执行环境

根据`Documentation/arch/riscv/boot.rst`，RISC-V的早期代码(Pre-MMU execution)有以下限制:

- **MMU未启用**: 虚拟内存管理单元尚未初始化
- **编译限制**: 必须使用特殊的编译选项
  - `-fno-pie`: 避免GOT表重定位问题
  - `-mcmodel=medany`: 确保PC相对寻址
- **禁用所有instrumentation**: 包括KASAN、ftrace等

### 3. 冲突原因

FORTIFY_SOURCE在早期代码中导致问题的原因:

1. **内存访问限制**: 早期代码运行时系统内存布局尚未完全建立
2. **符号重定位**: FORTIFY可能引入需要重定位的符号引用
3. **运行时检查**: FORTIFY的运行时检查可能依赖尚未初始化的系统组件
4. **库函数依赖**: FORTIFY替换的安全函数可能有额外的依赖

## 修复的具体问题

### 1. 报告的Bug

- **报告者**: Jason Montleon <jmontleo@redhat.com>
- **问题**: 内核panic
- **触发条件**: 启用FORTIFY_SOURCE时在早期代码中发生

### 2. 相关的历史Commit

#### Fixes标记的Commit:

1. **a35707c3d850**: "riscv: add memory-type errata for T-Head"
   - 添加了T-Head CPU的内存类型errata处理
   - 引入了在早期阶段执行的errata代码

2. **26e7aacb83df**: "riscv: Allow to downgrade paging mode from the command line"
   - 允许从命令行降级分页模式
   - 引入了早期命令行解析代码

## 技术原理深入分析

### 1. RISC-V启动流程

```
启动流程:
Bootloader → Kernel Entry → setup_vm() → setup_vm_final() → 正常内核执行
                ↑
            早期代码执行阶段
            (MMU未启用)
```

### 2. 早期代码的特殊要求

#### 2.1 内存访问限制
- 只能访问物理地址
- 不能使用虚拟内存映射
- 不能进行动态内存分配

#### 2.2 编译器限制
- 必须生成位置无关代码
- 避免全局符号的GOT表访问
- 禁用所有instrumentation

#### 2.3 库函数限制
- 不能使用标准库函数
- 字符串操作必须使用简化版本
- 避免复杂的运行时检查

### 3. FORTIFY_SOURCE的工作机制

#### 3.1 编译时检查
```c
// FORTIFY会将这样的代码:
strcpy(dest, src);

// 替换为:
__builtin___strcpy_chk(dest, src, __builtin_object_size(dest, 0));
```

#### 3.2 运行时检查
- 检查目标缓冲区大小
- 验证源数据长度
- 在检测到溢出时调用`__fortify_panic()`

#### 3.3 早期代码中的问题
- `__builtin_object_size()`可能返回不准确的值
- `__fortify_panic()`可能依赖未初始化的系统组件
- 额外的函数调用可能破坏早期代码的执行环境

## 解决方案分析

### 1. 选择`-D__NO_FORTIFY`的原因

#### 1.1 精确控制
- 只在需要的文件中禁用FORTIFY
- 不影响其他内核代码的安全检查
- 保持编译时的灵活性

#### 1.2 兼容性
- 与现有的编译系统兼容
- 不需要修改源代码
- 可以通过配置选项控制

### 2. 影响范围分析

#### 2.1 禁用FORTIFY的文件
- **errata处理**: 硬件bug修复代码
- **CPU特性检测**: 处理器能力识别
- **SBI调用**: 与固件接口通信
- **早期设备树解析**: 系统配置读取
- **命令行解析**: 启动参数处理

#### 2.2 安全影响评估
- **风险等级**: 低
- **原因**: 早期代码通常较短且经过严格审查
- **缓解措施**: 代码审查和测试覆盖

## 相关技术背景

### 1. RISC-V Alternative机制

#### 1.1 工作原理
- 在运行时根据CPU特性替换指令序列
- 用于处理不同CPU实现的差异
- 在早期阶段进行patching

#### 1.2 T-Head Errata
- T-Head CPU的内存类型实现与标准不同
- 需要在早期阶段进行指令替换
- 涉及PTE位的特殊处理

### 2. Position Independent (PI) 代码

#### 2.1 目的
- 支持内核重定位
- 实现KASLR (Kernel Address Space Layout Randomization)
- 提高系统安全性

#### 2.2 实现挑战
- 不能使用GOT表
- 必须使用PC相对寻址
- 需要特殊的链接脚本

## 测试和验证

### 1. 测试场景

#### 1.1 基本功能测试
- 在启用FORTIFY_SOURCE的配置下编译内核
- 验证内核能够正常启动
- 确认早期代码不会panic

#### 1.2 特定硬件测试
- T-Head CPU平台测试
- 验证errata处理正常工作
- 确认内存类型设置正确

#### 1.3 回归测试
- 确保其他RISC-V平台不受影响
- 验证FORTIFY在非早期代码中仍然有效
- 检查性能影响

### 2. 验证方法

#### 2.1 编译验证
```bash
# 启用FORTIFY_SOURCE
make ARCH=riscv defconfig
echo "CONFIG_FORTIFY_SOURCE=y" >> .config
make ARCH=riscv olddefconfig
make ARCH=riscv
```

#### 2.2 运行时验证
- 在QEMU中测试启动
- 在真实硬件上验证
- 检查dmesg输出

## 影响评估

### 1. 正面影响

#### 1.1 稳定性提升
- 解决了内核panic问题
- 提高了系统启动的可靠性
- 支持更多的编译配置组合

#### 1.2 兼容性改善
- 支持启用FORTIFY_SOURCE的发行版
- 与主流编译选项兼容
- 减少了配置冲突

### 2. 潜在风险

#### 2.1 安全性考虑
- 早期代码失去了FORTIFY保护
- 需要通过其他方式确保代码安全
- 依赖代码审查和测试

#### 2.2 维护负担
- 需要维护禁用FORTIFY的文件列表
- 新增早期代码时需要考虑FORTIFY问题
- 需要定期审查禁用范围

## 最佳实践建议

### 1. 开发指导

#### 1.1 早期代码开发
- 尽量减少早期代码的复杂性
- 避免使用复杂的字符串操作
- 优先使用简单的内存操作

#### 1.2 安全考虑
- 对早期代码进行严格的代码审查
- 使用静态分析工具检查
- 编写充分的测试用例

### 2. 配置管理

#### 2.1 编译配置
- 在CI/CD中测试FORTIFY_SOURCE启用的配置
- 确保所有支持的平台都能正常编译
- 定期验证功能完整性

#### 2.2 文档维护
- 更新相关的开发文档
- 记录FORTIFY禁用的原因
- 提供故障排除指南

## 总结

这个patch是一个重要的稳定性修复，解决了RISC-V架构中FORTIFY_SOURCE与早期代码执行环境不兼容的问题。通过精确地在需要的文件中禁用FORTIFY功能，既保证了系统的稳定性，又最小化了对安全性的影响。

### 关键要点:

1. **问题根源**: FORTIFY_SOURCE的运行时检查与早期代码的执行环境不兼容
2. **解决方案**: 使用`-D__NO_FORTIFY`在特定文件中禁用FORTIFY
3. **影响范围**: 仅影响早期执行的关键系统代码
4. **安全考虑**: 通过代码审查和测试确保早期代码的安全性
5. **长期维护**: 需要在添加新的早期代码时考虑FORTIFY兼容性

这个修复对于支持现代Linux发行版的默认安全配置具有重要意义，确保了RISC-V内核在各种编译配置下的稳定运行。