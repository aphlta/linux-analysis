# RISC-V Patch Analysis: 14c3ec67236b

## 基本信息

**Commit ID**: 14c3ec67236b2d90c553d2575950369aa6fa43c5  
**作者**: Jesse Taube <jesse@rivosinc.com>  
**日期**: 2024年7月9日  
**标题**: RISC-V: pi: Force hidden visibility for all symbol references  

## 1. Patch修改内容

### 修改的文件
- `arch/riscv/kernel/pi/Makefile`

### 具体修改
```diff
@@ -5,6 +5,7 @@ KBUILD_CFLAGS   := $(subst $(CC_FLAGS_FTRACE),,$(KBUILD_CFLAGS)) -fpie \
                   -Os -DDISABLE_BRANCH_PROFILING $(DISABLE_STACKLEAK_PLUGIN) \
                   $(call cc-option,-mbranch-protection=none) \
                   -I$(srctree)/scripts/dtc/libfdt -fno-stack-protector \
+                  -include $(srctree)/include/linux/hidden.h \
                   -D__DISABLE_EXPORTS -ffreestanding \
                   -fno-asynchronous-unwind-tables -fno-unwind-tables \
                   $(call cc-option,-fno-addrsig)
```

这个patch在RISC-V的position-independent (PI) 代码编译选项中添加了一行：
```makefile
-include $(srctree)/include/linux/hidden.h
```

## 2. 技术背景与原理

### 2.1 Position Independent Code (PIC/PIE)

RISC-V内核的pi目录包含位置无关代码，主要用于：
- **KASLR (Kernel Address Space Layout Randomization)**: 内核地址空间布局随机化
- **早期启动代码**: 在MMU设置之前运行的代码
- **动态内核映射**: 支持内核在不同虚拟地址加载

### 2.2 GOT (Global Offset Table) 问题

当使用GCC的`-fPIC`或`-fPIE`选项编译位置无关代码时，编译器会假设：
1. 正在构建动态对象（共享库或可执行文件）
2. 符号引用只能在加载时解析
3. 所有外部符号引用都通过GOT表进行

GOT表的问题：
- **包含绝对地址**: 需要在运行时重定位
- **增加内存占用**: 额外的间接访问开销
- **CoW页面污染**: 加载器修改的页面影响写时复制

### 2.3 Hidden Visibility解决方案

通过给符号引用添加'hidden'可见性，可以告知编译器：
- 符号引用将在链接时而非加载时解析
- 不需要通过GOT表进行间接访问
- 可以使用直接的PC相对寻址

## 3. linux/hidden.h分析

```c
/* include/linux/hidden.h */
#pragma GCC visibility push(hidden)
```

这个头文件的作用：
1. **强制隐藏可见性**: 对所有后续符号声明应用hidden属性
2. **消除GOT条目**: 编译器不再为符号引用生成GOT条目
3. **优化代码生成**: 使用更高效的PC相对寻址

## 4. 与ARM64的对比

RISC-V的这个修改直接借鉴了ARM64的实现：

```makefile
# arch/arm64/kernel/pi/Makefile (已有的实现)
KBUILD_CFLAGS := $(subst $(CC_FLAGS_FTRACE),,$(KBUILD_CFLAGS)) -fpie \
                 -Os -DDISABLE_BRANCH_PROFILING $(DISABLE_STACKLEAK_PLUGIN) \
                 $(DISABLE_LATENT_ENTROPY_PLUGIN) \
                 $(call cc-option,-mbranch-protection=none) \
                 -I$(srctree)/scripts/dtc/libfdt -fno-stack-protector \
                 -include $(srctree)/include/linux/hidden.h \  # <-- 已存在
                 -D__DISABLE_EXPORTS -ffreestanding -D__NO_FORTIFY \
```

## 5. 相关提交历史

### 5.1 KASLR支持引入 (84fe419dc757)
- **标题**: "riscv: Introduce virtual kernel mapping KASLR"
- **作用**: 引入了RISC-V的KASLR支持
- **创建了pi目录**: 包含位置无关的早期启动代码

### 5.2 孤立段修复 (3b90b09af5be)
- **标题**: "riscv: Fix orphan section warnings caused by kernel/pi"
- **问题**: pi代码产生了大量孤立段
- **解决**: 使用`.init.pi`前缀统一处理

### 5.3 Fortify禁用 (afedc3126e11)
- **标题**: "riscv: Do not use fortify in early code"
- **原因**: 早期代码不能使用fortify检查

## 6. 技术影响分析

### 6.1 性能优化
- **减少间接访问**: 消除GOT表查找开销
- **更好的缓存局部性**: 直接PC相对寻址
- **减少内存占用**: 不需要GOT表空间

### 6.2 代码生成改进
```assembly
# 使用GOT (修改前)
la   t0, symbol@got
ld   t0, 0(t0)

# 直接寻址 (修改后)
la   t0, symbol
```

### 6.3 链接时优化
- **更好的死代码消除**: 链接器可以更准确地分析符号使用
- **减少重定位条目**: 不需要运行时重定位GOT表

## 7. 安全性考虑

### 7.1 KASLR增强
- **减少信息泄露**: 没有固定的GOT表地址
- **提高随机化效果**: 所有符号引用都是相对的

### 7.2 攻击面减少
- **消除GOT劫持**: 没有可修改的GOT表
- **减少ROP gadgets**: 更少的间接跳转指令

## 8. 潜在风险与注意事项

### 8.1 符号可见性
- **确保符号可访问**: hidden可见性要求符号在同一编译单元或静态链接
- **避免运行时链接**: 不能依赖动态符号解析

### 8.2 调试影响
- **符号表变化**: 某些调试工具可能需要适配
- **地址计算**: 调试器需要理解PC相对寻址

## 9. 测试与验证

### 9.1 编译验证
```bash
# 检查GOT表大小
readelf -S vmlinux | grep -E '\.got'

# 验证重定位条目
readelf -r vmlinux | grep -E 'GOT|PLT'
```

### 9.2 运行时测试
- **KASLR功能**: 确保内核可以在随机地址正常启动
- **早期启动**: 验证pi代码在MMU设置前正常工作
- **符号解析**: 确保所有符号引用正确解析

## 10. 总结

这个patch是RISC-V架构向ARM64看齐的重要一步，通过强制hidden可见性：

1. **消除了GOT依赖**: 提高了位置无关代码的效率
2. **优化了KASLR实现**: 减少了运行时开销
3. **增强了安全性**: 减少了潜在的攻击面
4. **统一了架构实现**: 与ARM64保持一致的设计

这是一个小而精准的优化，体现了内核开发中对性能和安全性的持续关注。虽然修改只有一行，但其背后的技术原理和影响是深远的。

## 参考链接

- **Patch链接**: https://lore.kernel.org/r/20240709173937.510084-2-jesse@rivosinc.com
- **相关文档**: Documentation/riscv/boot.rst
- **KASLR文档**: Documentation/admin-guide/kernel-parameters.txt (nokaslr参数)