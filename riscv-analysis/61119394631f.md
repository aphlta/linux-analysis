# RISC-V系统调用错误处理修复分析

## Commit信息
- **Commit ID**: 61119394631f219e23ce98bcc3eb993a64a8ea64
- **作者**: Celeste Liu <coelacanthushex@gmail.com>
- **日期**: 2024年6月27日 22:23:39 +0800
- **标题**: riscv: entry: always initialize regs->a0 to -ENOSYS
- **修复的问题**: Fixes: 52449c17bdd1 ("riscv: entry: set a0 = -ENOSYS only when syscall != -1")
- **报告者**: "Dmitry V. Levin" <ldv@strace.io>
- **审核者**: Björn Töpel <bjorn@rivosinc.com>
- **链接**: https://lore.kernel.org/r/20240627142338.5114-2-CoelacanthusHex@gmail.com

## 问题背景

### 1. 原始问题描述

这个patch修复了一个关键的系统调用错误处理问题：当tracer（如strace）将系统调用号修改为-1时，内核无法正确初始化a0寄存器为-ENOSYS，导致无法向用户空间返回正确的错误码。这个问题会破坏strace的系统调用篡改功能。

### 2. 问题的技术根源

在commit 52449c17bdd1中，为了修复seccomp相关的问题，开发者修改了系统调用错误处理逻辑：

**修改前的逻辑**（存在seccomp问题）:
```c
if (syscall < NR_syscalls)
    syscall_handler(regs, syscall);
else
    regs->a0 = -ENOSYS;
```

**52449c17bdd1的修改**（修复了seccomp但引入了新问题）:
```c
regs->orig_a0 = regs->a0;
// 没有初始化regs->a0 = -ENOSYS

if (syscall >= 0 && syscall < NR_syscalls)
    syscall_handler(regs, syscall);
else if (syscall != -1)
    regs->a0 = -ENOSYS;
```

### 3. 新问题的产生机制

当tracer使用ptrace修改系统调用号为-1时：
1. `syscall >= 0 && syscall < NR_syscalls` 条件为false（因为syscall = -1）
2. `syscall != -1` 条件也为false（因为syscall确实等于-1）
3. 结果：`regs->a0`没有被设置为-ENOSYS
4. 用户空间收到的是未初始化或错误的返回值

## 修改内容详细分析

### 1. 核心修改

**文件**: `arch/riscv/kernel/traps.c`

**修改前的代码**:
```c
void do_trap_ecall_u(struct pt_regs *regs)
{
    if (user_mode(regs)) {
        long syscall = regs->a7;

        regs->epc += 4;
        regs->orig_a0 = regs->a0;
        // 缺少: regs->a0 = -ENOSYS;

        riscv_v_vstate_discard(regs);
        syscall = syscall_enter_from_user_mode(regs, syscall);
        add_random_kstack_offset();

        if (syscall >= 0 && syscall < NR_syscalls)
            syscall_handler(regs, syscall);
        else if (syscall != -1)  // 问题所在
            regs->a0 = -ENOSYS;
```

**修改后的代码**:
```c
void do_trap_ecall_u(struct pt_regs *regs)
{
    if (user_mode(regs)) {
        long syscall = regs->a7;

        regs->epc += 4;
        regs->orig_a0 = regs->a0;
        regs->a0 = -ENOSYS;  // 新增：总是初始化为-ENOSYS

        riscv_v_vstate_discard(regs);
        syscall = syscall_enter_from_user_mode(regs, syscall);
        add_random_kstack_offset();

        if (syscall >= 0 && syscall < NR_syscalls)
            syscall_handler(regs, syscall);
        // 移除了else if条件判断
```

### 2. 修改原理

#### 2.1 新的处理逻辑

1. **总是初始化**: 在系统调用处理开始时，总是将`regs->a0`设置为`-ENOSYS`
2. **有效系统调用覆盖**: 如果是有效的系统调用（`syscall >= 0 && syscall < NR_syscalls`），`syscall_handler`会用正确的返回值覆盖`regs->a0`
3. **无效系统调用保持**: 对于无效的系统调用（包括syscall == -1），`regs->a0`保持为`-ENOSYS`

#### 2.2 解决的问题场景

**场景1: 正常系统调用**
- syscall = 有效号码（如1, 2, 3...）
- 初始化：`regs->a0 = -ENOSYS`
- 执行：`syscall_handler`设置正确返回值
- 结果：用户空间收到正确的系统调用返回值

**场景2: 无效系统调用**
- syscall = 无效号码（如999）
- 初始化：`regs->a0 = -ENOSYS`
- 执行：不调用`syscall_handler`
- 结果：用户空间收到`-ENOSYS`

**场景3: tracer修改为-1（修复的关键场景）**
- syscall = -1（由tracer设置）
- 初始化：`regs->a0 = -ENOSYS`
- 执行：不调用`syscall_handler`
- 结果：用户空间收到`-ENOSYS`（修复后正确）

## 相关技术背景

### 1. RISC-V系统调用约定

- **a7寄存器**: 存储系统调用号
- **a0寄存器**: 存储第一个参数，同时也是返回值寄存器
- **orig_a0**: 保存原始的a0值，用于系统调用重启等场景
- **ENOSYS**: 表示"功能未实现"的错误码（值为-38）

### 2. ptrace和strace工作原理

#### 2.1 strace的系统调用篡改

```c
// strace可以这样修改系统调用
struct user_regs_struct regs;
ptrace(PTRACE_GETREGS, pid, NULL, &regs);
regs.a7 = -1;  // 修改系统调用号为-1
ptrace(PTRACE_SETREGS, pid, NULL, &regs);
```

#### 2.2 期望的行为

当strace将系统调用号设置为-1时：
- 内核应该返回-ENOSYS
- strace可以检测到这个返回值
- 用户可以看到系统调用被"拒绝"的信息

### 3. seccomp相关背景

#### 3.1 原始的seccomp问题（52449c17bdd1修复的）

在52449c17bdd1之前，当seccomp规则返回`RET_ERRNO`时：
1. seccomp设置`regs->a0`为指定的错误码
2. seccomp返回-1给`syscall_enter_from_user_mode`
3. 内核检查`syscall < NR_syscalls`（-1转换为ULONG_MAX，总是false）
4. 内核执行`regs->a0 = -ENOSYS`，覆盖了seccomp设置的错误码
5. 用户空间总是收到ENOSYS而不是seccomp指定的错误码

#### 3.2 52449c17bdd1的修复

```c
// 修改syscall类型为long（支持负数）
long syscall = regs->a7;

// 修改条件判断
if (syscall >= 0 && syscall < NR_syscalls)
    syscall_handler(regs, syscall);
else if (syscall != -1)  // 不覆盖seccomp设置的-1情况
    regs->a0 = -ENOSYS;
```

这个修复解决了seccomp问题，但引入了tracer篡改的问题。

## 修复效果分析

### 1. 解决的问题

#### 1.1 strace系统调用篡改

**修复前**:
```bash
$ strace -e trace=write -e inject=write:error=EPERM ./test
# strace无法正确显示被拒绝的系统调用
```

**修复后**:
```bash
$ strace -e trace=write -e inject=write:error=EPERM ./test
write(1, "hello", 5) = -1 EPERM (Operation not permitted) (INJECTED)
```

#### 1.2 ptrace调试器

修复后，使用ptrace的调试器可以：
- 正确拦截和修改系统调用
- 获得预期的错误返回值
- 实现系统调用过滤和监控

### 2. 保持的兼容性

#### 2.1 seccomp功能

修复后的代码仍然正确支持seccomp：
- 当seccomp返回`RET_ERRNO`时，`syscall_enter_from_user_mode`返回-1
- `syscall >= 0 && syscall < NR_syscalls`为false，不调用`syscall_handler`
- `regs->a0`保持seccomp设置的错误码（因为已经在seccomp中设置）

#### 2.2 正常系统调用

- 有效系统调用：`syscall_handler`会覆盖初始的-ENOSYS
- 无效系统调用：保持-ENOSYS返回值

### 3. 性能影响

- **微小开销**: 每个系统调用多一次寄存器赋值操作
- **可忽略影响**: 相对于系统调用的整体开销，这个赋值操作的成本可以忽略
- **无功能影响**: 不影响系统调用的正常执行路径

## 相关提交分析

### 1. 修复链条

1. **f0bddf50586d**: "riscv: entry: Convert to generic entry" - 引入通用入口框架
2. **52449c17bdd1**: "riscv: entry: set a0 = -ENOSYS only when syscall != -1" - 修复seccomp问题
3. **61119394631f**: "riscv: entry: always initialize regs->a0 to -ENOSYS" - 修复tracer问题

### 2. 问题演进

这个修复展示了一个典型的内核开发场景：
- 修复一个问题（seccomp）可能引入另一个问题（tracer）
- 需要找到平衡点，同时支持多个功能
- 最终解决方案往往比较简单但需要深入理解各个子系统的交互

## 测试和验证

### 1. 测试场景

#### 1.1 strace测试
```bash
# 测试系统调用拦截
strace -e trace=write -e inject=write:error=EPERM echo "test"

# 测试系统调用修改
strace -e trace=openat -e inject=openat:retval=42 ls
```

#### 1.2 seccomp测试
```c
// 测试seccomp RET_ERRNO
struct sock_filter filter[] = {
    BPF_STMT(BPF_LD | BPF_W | BPF_ABS, offsetof(struct seccomp_data, nr)),
    BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, __NR_write, 0, 1),
    BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_ERRNO | EPERM),
    BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_ALLOW),
};
```

### 2. 回归测试

- 确保正常系统调用仍然工作
- 确保seccomp功能不受影响
- 确保ptrace/strace功能正常
- 确保性能没有显著下降

## 总结

这个patch是一个精确的修复，解决了RISC-V架构中系统调用错误处理的一个边缘情况。通过总是初始化`regs->a0`为`-ENOSYS`，它确保了：

1. **tracer兼容性**: strace等工具的系统调用篡改功能正常工作
2. **seccomp兼容性**: 保持了之前修复的seccomp功能
3. **系统调用正确性**: 不影响正常和异常系统调用的处理
4. **代码简洁性**: 通过简化逻辑减少了出错的可能性

这个修复体现了内核开发中的重要原则：在修复问题时要考虑所有相关的子系统和使用场景，确保修复不会引入新的问题。同时，它也展示了开源社区协作的价值：问题由strace维护者发现并报告，由RISC-V内核开发者修复，体现了不同项目之间的良好协作。