# RISC-V原子操作代码去重优化分析

## 1. Patch基本信息

**Commit ID**: 906123739272  
**完整Commit**: 9061237392721f0e9b399161876fa36ddb6c4226  
**标题**: riscv/atomic.h : Deduplicate arch_atomic.*  
**作者**: Leonardo Bras <leobras@redhat.com>  
**提交日期**: Wed Jan 3 13:32:01 2024 -0300  
**审核者**: 
- Guo Ren <guoren@kernel.org>
- Andrea Parri <parri.andrea@gmail.com>

**测试者**: Guo Ren <guoren@kernel.org>  
**合并者**: Palmer Dabbelt <palmer@rivosinc.com>  

## 2. Patch修改概述

### 2.1 修改统计
- **修改文件**: arch/riscv/include/asm/atomic.h
- **代码变更**: 164行修改，76行新增，88行删除
- **净减少**: 12行代码

### 2.2 修改目标
本patch的主要目标是消除RISC-V架构原子操作中32位和64位版本之间的代码重复，通过引入通用宏来简化代码结构，同时保持生成的汇编代码不变。

## 3. 详细技术分析

### 3.1 问题背景

在原始实现中，RISC-V的原子操作函数存在大量重复代码：
- 32位和64位版本的原子操作使用几乎相同的内联汇编代码
- 唯一的区别是指令后缀（"w" vs "d"）和数据类型
- 这种重复导致代码维护困难和潜在的不一致性

### 3.2 解决方案

#### 3.2.1 新增通用宏定义

Patch引入了四个新的通用宏来替代重复的内联汇编代码：

**1. `_arch_atomic_fetch_add_unless`宏**
```c
#define _arch_atomic_fetch_add_unless(_prev, _rc, counter, _a, _u, sfx)	\
({											\
	__asm__ __volatile__ (							\
		"0:	lr." sfx "     %[p],  %[c]\n"			\
		"	beq	       %[p],  %[u], 1f\n"		\
		"	add            %[rc], %[p], %[a]\n"		\
		"	sc." sfx ".rl  %[rc], %[rc], %[c]\n"		\
		"	bnez           %[rc], 0b\n"			\
		"	fence          rw, rw\n"			\
		"1:\n"							\
		: [p]"=&r" (_prev), [rc]"=&r" (_rc), [c]"+A" (counter)	\
		: [a]"r" (_a), [u]"r" (_u)				\
		: "memory");						\
})
```

**2. `_arch_atomic_inc_unless_negative`宏**
```c
#define _arch_atomic_inc_unless_negative(_prev, _rc, counter, sfx)	\
({											\
	__asm__ __volatile__ (							\
		"0:	lr." sfx "      %[p],  %[c]\n"			\
		"	bltz            %[p],  1f\n"			\
		"	addi            %[rc], %[p], 1\n"		\
		"	sc." sfx ".rl   %[rc], %[rc], %[c]\n"		\
		"	bnez            %[rc], 0b\n"			\
		"	fence           rw, rw\n"			\
		"1:\n"							\
		: [p]"=&r" (_prev), [rc]"=&r" (_rc), [c]"+A" (counter)	\
		:							\
		: "memory");						\
})
```

**3. `_arch_atomic_dec_unless_positive`宏**
```c
#define _arch_atomic_dec_unless_positive(_prev, _rc, counter, sfx)	\
({											\
	__asm__ __volatile__ (							\
		"0:	lr." sfx "      %[p],  %[c]\n"			\
		"	bgtz            %[p],  1f\n"			\
		"	addi            %[rc], %[p], -1\n"		\
		"	sc." sfx ".rl   %[rc], %[rc], %[c]\n"		\
		"	bnez            %[rc], 0b\n"			\
		"	fence           rw, rw\n"			\
		"1:\n"							\
		: [p]"=&r" (_prev), [rc]"=&r" (_rc), [c]"+A" (counter)	\
		:							\
		: "memory");						\
})
```

**4. `_arch_atomic_dec_if_positive`宏**
```c
#define _arch_atomic_dec_if_positive(_prev, _rc, counter, sfx)		\
({											\
	__asm__ __volatile__ (							\
		"0:	lr." sfx "     %[p],  %[c]\n"			\
		"	addi           %[rc], %[p], -1\n"		\
		"	bltz           %[rc], 1f\n"			\
		"	sc." sfx ".rl  %[rc], %[rc], %[c]\n"		\
		"	bnez           %[rc], 0b\n"			\
		"	fence          rw, rw\n"			\
		"1:\n"							\
		: [p]"=&r" (_prev), [rc]"=&r" (_rc), [c]"+A" (counter)	\
		:							\
		: "memory");						\
})
```

#### 3.2.2 函数实现简化

**原始实现示例（arch_atomic64_inc_unless_negative）**：
```c
static __always_inline bool arch_atomic64_inc_unless_negative(atomic64_t *v)
{
        s64 prev;
        long rc;
 
        __asm__ __volatile__ (
                "0:     lr.d      %[p],  %[c]\n"
                "       bltz      %[p],  1f\n"
                "       addi      %[rc], %[p], 1\n"
                "       sc.d.rl   %[rc], %[rc], %[c]\n"
                "       bnez      %[rc], 0b\n"
                "       fence     rw, rw\n"
                "1:\n"
                : [p]"=&r" (prev), [rc]"=&r" (rc), [c]"+A" (v->counter)
                :
                : "memory");
        return !(prev < 0);
}
```

**新实现**：
```c
static __always_inline bool arch_atomic64_inc_unless_negative(atomic64_t *v)
{
	s64 prev;
	long rc;

	_arch_atomic_inc_unless_negative(prev, rc, v->counter, "d");

	return !(prev < 0);
}
```

### 3.3 技术原理分析

#### 3.3.1 RISC-V原子操作指令

**Load-Reserved/Store-Conditional (LR/SC)机制**：
- `lr.w/lr.d`: 加载并保留（32位/64位）
- `sc.w.rl/sc.d.rl`: 条件存储并释放（32位/64位）
- `.rl`后缀表示release语义，提供内存排序保证

**内存屏障**：
- `fence rw, rw`: 确保读写操作的顺序性
- 在原子操作成功后提供完整的内存屏障

#### 3.3.2 宏参数化设计

**关键参数**：
- `sfx`: 指令后缀（"w"用于32位，"d"用于64位）
- `_prev`: 存储加载的原始值
- `_rc`: 存储条件存储的返回码
- `counter`: 原子变量的计数器

**通用性实现**：
- 通过参数化指令后缀，同一个宏可以生成32位和64位版本
- 保持了原有的内联汇编逻辑和性能特性

## 4. 相关提交分析

### 4.1 Patch系列背景

这个commit是一个更大的代码重构系列的一部分，该系列专注于RISC-V架构的原子操作和同步原语优化：

**相关提交**：
1. **4bfa185fe3f0**: "riscv/cmpxchg: Deduplicate xchg() asm functions"
   - 去重化xchg()汇编函数
   - 同样采用宏参数化方法

2. **07a0a41cb77d**: "riscv/cmpxchg: Deduplicate cmpxchg() asm and macros"
   - 去重化cmpxchg()汇编和宏
   - 引入`_arch_cmpxchg`通用宏

### 4.2 整体优化策略

**统一的重构方法**：
1. 识别32位和64位版本间的重复代码
2. 提取公共的汇编模板
3. 通过参数化宏消除重复
4. 保持生成代码的性能和正确性

## 5. 性能和正确性分析

### 5.1 性能影响

**零性能开销**：
- Patch明确声明"This did not cause any change in generated asm"
- 宏展开后生成的汇编代码与原始版本完全相同
- 编译时优化，运行时无额外开销

### 5.2 代码质量提升

**维护性改进**：
- 减少了88行重复代码
- 统一了原子操作的实现模式
- 降低了维护成本和出错概率

**可读性增强**：
- 函数实现更加简洁明了
- 宏定义集中管理汇编模板
- 32位和64位版本的一致性更明显

## 6. 测试和验证

### 6.1 审核流程

**多重审核**：
- **Guo Ren**: RISC-V维护者审核
- **Andrea Parri**: 内存模型专家审核
- **测试验证**: Guo Ren进行了实际测试

### 6.2 兼容性保证

**向后兼容**：
- 所有原有的API保持不变
- 生成的汇编代码完全一致
- 不影响现有的内核模块和驱动

## 7. 总结

### 7.1 技术贡献

1. **代码重构**: 成功消除了RISC-V原子操作中的重复代码
2. **维护性提升**: 通过宏参数化简化了代码结构
3. **性能保持**: 在优化代码结构的同时保持了原有性能
4. **一致性增强**: 统一了32位和64位原子操作的实现模式

### 7.2 工程意义

这个patch展示了优秀的内核代码重构实践：
- 在不影响性能的前提下改进代码质量
- 通过系统性的方法解决代码重复问题
- 严格的审核和测试流程确保了修改的安全性

### 7.3 影响范围

**直接影响**：
- RISC-V架构的原子操作实现
- 内核中所有使用原子操作的子系统

**间接影响**：
- 为其他架构的类似优化提供了参考
- 提升了RISC-V内核代码的整体质量

这个patch是一个典型的"无功能变更的代码质量改进"示例，体现了Linux内核开发中对代码质量和维护性的重视。