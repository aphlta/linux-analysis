# RISC-V内存热插拔支持：预分配PGD条目分析

## 1. Commit信息

- **Commit ID**: 66673099f734fd6512055fee353b5c81dafec216
- **标题**: riscv: mm: Pre-allocate vmemmap/direct map/kasan PGD entries
- **作者**: Björn Töpel <bjorn@rivosinc.com>
- **提交者**: Palmer Dabbelt <palmer@rivosinc.com>
- **提交日期**: 2024年6月26日
- **邮件列表链接**: https://lore.kernel.org/r/20240605114100.315918-3-bjorn@kernel.org

## 2. 修改概述

这个patch为RISC-V架构添加了内存热插拔支持的基础设施，通过预分配PGD级别的页表条目来避免运行时的页表同步问题。主要修改包括：

1. **arch/riscv/include/asm/kasan.h**: 重新组织KASAN相关宏定义的条件编译
2. **arch/riscv/mm/init.c**: 扩展`pgtable_cache_init()`函数，为内存热插拔相关区域预分配PGD条目

## 3. 技术原理分析

### 3.1 RISC-V页表同步问题

RISC-V架构的特殊性在于它将`init_mm/swapper_pg_dir`的PGD表复制到所有用户空间页表中。这意味着当PGD级别的页表发生变化时，所有其他页表都需要相应更新，这种同步机制在内存热插拔场景下会带来复杂性和性能开销。

### 3.2 预分配策略

为了避免运行时的页表同步，该patch采用了预分配策略：
- 在系统启动时预先分配所有可能用到的PGD条目
- 避免了运行时动态分配导致的同步问题
- 这种方法已经在BPF/modules和vmalloc区域中使用

### 3.3 内存开销

根据commit message，启用内存热插拔时大约会浪费：
- ~128个4K页面用于基本的vmemmap和direct map
- 额外32个4K页面（如果启用KASAN）
- 总计约640KB-832KB的内存开销

## 4. 代码修改详细分析

### 4.1 KASAN头文件重构 (arch/riscv/include/asm/kasan.h)

```c
// 修改前：KASAN_SHADOW_START和KASAN_SHADOW_END定义在CONFIG_KASAN条件内
#ifdef CONFIG_KASAN
#define KASAN_SHADOW_START     ((KASAN_SHADOW_END - KASAN_SHADOW_SIZE) & PGDIR_MASK)
#define KASAN_SHADOW_END       MODULES_LOWEST_VADDR
#define KASAN_SHADOW_OFFSET    _AC(CONFIG_KASAN_SHADOW_OFFSET, UL)
#endif

// 修改后：将KASAN_SHADOW_START和KASAN_SHADOW_END移到条件编译外
#define KASAN_SHADOW_START     ((KASAN_SHADOW_END - KASAN_SHADOW_SIZE) & PGDIR_MASK)
#define KASAN_SHADOW_END       MODULES_LOWEST_VADDR

#ifdef CONFIG_KASAN
#define KASAN_SHADOW_OFFSET    _AC(CONFIG_KASAN_SHADOW_OFFSET, UL)
#endif
```

**修改原因**: 即使在未启用KASAN的情况下，也需要访问`KASAN_SHADOW_START`来定义`PAGE_END`宏，用于direct map区域的边界计算。

### 4.2 页表预分配扩展 (arch/riscv/mm/init.c)

```c
// 添加的头文件包含
#include <asm/kasan.h>

// 新增的宏定义
#define PAGE_END KASAN_SHADOW_START

// 扩展的pgtable_cache_init函数
void __init pgtable_cache_init(void)
{
    preallocate_pgd_pages_range(VMALLOC_START, VMALLOC_END, "vmalloc");
    if (IS_ENABLED(CONFIG_MODULES))
        preallocate_pgd_pages_range(MODULES_VADDR, MODULES_END, "bpf/modules");
    
    // 新增的内存热插拔支持
    if (IS_ENABLED(CONFIG_MEMORY_HOTPLUG)) {
        preallocate_pgd_pages_range(VMEMMAP_START, VMEMMAP_END, "vmemmap");
        preallocate_pgd_pages_range(PAGE_OFFSET, PAGE_END, "direct map");
        if (IS_ENABLED(CONFIG_KASAN))
            preallocate_pgd_pages_range(KASAN_SHADOW_START, KASAN_SHADOW_END, "kasan");
    }
}
```

**关键改进**:
1. **VMEMMAP区域**: 预分配`VMEMMAP_START`到`VMEMMAP_END`的PGD条目，支持稀疏内存模型的struct page映射
2. **Direct Map区域**: 预分配`PAGE_OFFSET`到`PAGE_END`(即`KASAN_SHADOW_START`)的PGD条目，支持物理内存的直接映射
3. **KASAN区域**: 如果启用KASAN，预分配KASAN shadow内存区域的PGD条目

### 4.3 preallocate_pgd_pages_range函数分析

该函数的工作原理：
```c
static void __init preallocate_pgd_pages_range(unsigned long start, unsigned long end,
                                               const char *area)
{
    unsigned long addr;
    const char *lvl;

    for (addr = start; addr < end && addr >= start; addr = ALIGN(addr + 1, PGDIR_SIZE)) {
        pgd_t *pgd = pgd_offset_k(addr);
        p4d_t *p4d;
        pud_t *pud;
        pmd_t *pmd;

        // 根据页表级别分配相应的页表页
        lvl = "p4d";
        p4d = p4d_alloc(&init_mm, pgd, addr);
        if (!p4d) goto failed;

        if (pgtable_l5_enabled) continue;

        lvl = "pud";
        pud = pud_alloc(&init_mm, p4d, addr);
        if (!pud) goto failed;

        if (pgtable_l4_enabled) continue;

        lvl = "pmd";
        pmd = pmd_alloc(&init_mm, pud, addr);
        if (!pmd) goto failed;
    }
}
```

该函数按`PGDIR_SIZE`对齐遍历指定的虚拟地址范围，为每个PGD条目预分配必要的中间页表页（p4d、pud、pmd），确保在内存热插拔时不需要动态分配这些页表页。

## 5. 内存布局影响

### 5.1 RISC-V 64位内存布局

```
地址空间布局（从高到低）：
┌─────────────────────────────────────┐
│  Kernel Space (KERNEL_LINK_ADDR)   │
├─────────────────────────────────────┤
│  Modules (MODULES_VADDR)            │
├─────────────────────────────────────┤ ← KASAN_SHADOW_START (PAGE_END)
│  KASAN Shadow (if enabled)          │
├─────────────────────────────────────┤ ← VMALLOC_START
│  VMALLOC Area                       │
├─────────────────────────────────────┤ ← VMEMMAP_START
│  VMEMMAP Area                       │
├─────────────────────────────────────┤
│  PCI I/O Space                      │
├─────────────────────────────────────┤
│  Fixed Mappings                     │
├─────────────────────────────────────┤ ← PAGE_OFFSET
│  Direct Mapping                     │
│  (Physical Memory)                  │
└─────────────────────────────────────┘
```

### 5.2 预分配区域

该patch为以下三个关键区域预分配PGD条目：

1. **VMEMMAP区域** (`VMEMMAP_START` - `VMEMMAP_END`)
   - 用于存储struct page结构
   - 支持稀疏内存模型(SPARSEMEM_VMEMMAP)
   - 大小：`BIT(VA_BITS - PAGE_SHIFT - 1 + STRUCT_PAGE_MAX_SHIFT)`

2. **Direct Map区域** (`PAGE_OFFSET` - `PAGE_END`)
   - 物理内存的直接映射
   - PAGE_END定义为KASAN_SHADOW_START
   - 覆盖所有可能的物理内存范围

3. **KASAN Shadow区域** (`KASAN_SHADOW_START` - `KASAN_SHADOW_END`)
   - 仅在启用KASAN时预分配
   - 用于内存错误检测的shadow内存

## 6. 相关提交分析

这个patch是RISC-V内存热插拔支持系列的一部分。从邮件列表链接可以看出，这是系列patch中的第3个（315918-3）。相关的工作可能包括：

1. **前置patch**: 可能包含基础的内存热插拔框架支持
2. **后续patch**: 可能包含实际的内存热插拔操作实现
3. **测试和验证**: 确保预分配策略的正确性和性能

## 7. 性能和安全考虑

### 7.1 性能优势
- **避免运行时同步**: 消除了内存热插拔时的页表同步开销
- **减少TLB刷新**: 预分配避免了频繁的TLB无效化操作
- **提高确定性**: 内存热插拔操作的延迟更加可预测

### 7.2 内存开销
- **固定开销**: 约640KB-832KB的内存预分配
- **权衡考虑**: 用少量内存换取更好的性能和简化的实现
- **配置依赖**: 只有在启用CONFIG_MEMORY_HOTPLUG时才会产生开销

### 7.3 安全性
- **KASAN支持**: 保持了内存错误检测能力
- **地址空间隔离**: 维护了内核和用户空间的隔离
- **页表完整性**: 预分配确保了页表结构的一致性

## 8. 总结

这个patch通过预分配PGD条目的策略，为RISC-V架构提供了高效的内存热插拔支持基础。主要贡献包括：

1. **解决架构特定问题**: 针对RISC-V的页表同步特性提供了优雅的解决方案
2. **性能优化**: 避免了运行时的复杂同步操作
3. **代码简化**: 使内存热插拔的实现更加直接和可靠
4. **向前兼容**: 为未来的内存管理功能奠定了基础

该patch展现了对RISC-V架构深入理解和精心设计，是内核内存管理子系统的一个重要改进。