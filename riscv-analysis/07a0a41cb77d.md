# RISC-V cmpxchg() 代码去重复化分析报告

## Commit 信息
- **Commit ID**: 07a0a41cb77d582e4db05bd9e79daa145d5d6ea4
- **作者**: Leonardo Bras <leobras@redhat.com>
- **提交日期**: 2024年1月3日
- **标题**: riscv/cmpxchg: Deduplicate cmpxchg() asm and macros
- **维护者**: Palmer Dabbelt <palmer@rivosinc.com>

## 问题背景

在此patch之前，RISC-V架构的 `arch/riscv/include/asm/cmpxchg.h` 头文件中存在严重的代码重复问题：

1. **重复的汇编代码**: 每个cmpxchg变体（_relaxed, _acquire, _release, vanilla）都包含自己的汇编实现
2. **多版本维护**: 针对4字节和8字节变量分别实现，总共有8个版本的基本相同的汇编代码
3. **维护困难**: 任何修改都需要在最多8个不同的地方进行，容易出错且维护成本高

## 修改内容详细分析

### 1. 删除的重复代码

#### 原有的 `__cmpxchg_relaxed` 宏
```c
#define __cmpxchg_relaxed(ptr, old, new, size)                         \
({                                                                     \
       __typeof__(ptr) __ptr = (ptr);                                  \
       __typeof__(*(ptr)) __old = (old);                               \
       __typeof__(*(ptr)) __new = (new);                               \
       __typeof__(*(ptr)) __ret;                                       \
       register unsigned int __rc;                                     \
       switch (size) {                                                 \
       case 4:                                                         \
               __asm__ __volatile__ (                                  \
                       "0:     lr.w %0, %2\n"                          \
                       "       bne  %0, %z3, 1f\n"                     \
                       "       sc.w %1, %z4, %2\n"                     \
                       "       bnez %1, 0b\n"                          \
                       "1:\n"                                          \
                       : "=&r" (__ret), "=&r" (__rc), "+A" (*__ptr)    \
                       : "rJ" ((long)__old), "rJ" (__new)              \
                       : "memory");                                    \
               break;                                                  \
       case 8:                                                         \
               __asm__ __volatile__ (                                  \
                       "0:     lr.d %0, %2\n"                          \
                       "       bne %0, %z3, 1f\n"                      \
                       "       sc.d %1, %z4, %2\n"                     \
                       "       bnez %1, 0b\n"                          \
                       "1:\n"                                          \
                       : "=&r" (__ret), "=&r" (__rc), "+A" (*__ptr)    \
                       : "rJ" (__old), "rJ" (__new)                    \
                       : "memory");                                    \
               break;                                                  \
       default:                                                        \
               BUILD_BUG();                                            \
       }                                                               \
       __ret;                                                          \
})
```

类似的重复代码还包括：
- `__cmpxchg_acquire`
- `__cmpxchg_release` 
- `__cmpxchg`

每个都有针对4字节和8字节的独立汇编实现。

### 2. 新的统一实现

#### 核心汇编宏 `__arch_cmpxchg`
```c
#define __arch_cmpxchg(lr_sfx, sc_sfx, cas_sfx,                \
               sc_prepend, sc_append,                \
               cas_prepend, cas_append,                \
               r, p, co, o, n)                    \
({                                    \
    if (IS_ENABLED(CONFIG_RISCV_ISA_ZACAS) &&            \
        riscv_has_extension_unlikely(RISCV_ISA_EXT_ZACAS)) {    \
        r = o;                            \
                                    \
        __asm__ __volatile__ (                    \
            cas_prepend                    \
            "    amocas" cas_sfx " %0, %z2, %1\n"    \
            cas_append                    \
            : "+&r" (r), "+A" (*(p))            \
            : "rJ" (n)                    \
            : "memory");                    \
    } else {                            \
        register unsigned int __rc;                \
                                    \
        __asm__ __volatile__ (                    \
            sc_prepend                    \
            "0:    lr" lr_sfx " %0, %2\n"            \
            "    bne  %0, %z3, 1f\n"            \
            "    sc" sc_sfx " %1, %z4, %2\n"        \
            "    bnez %1, 0b\n"                \
            sc_append                    \
            "1:\n"                        \
            : "=&r" (r), "=&r" (__rc), "+A" (*(p))        \
            : "rJ" (co o), "rJ" (n)                \
            : "memory");                    \
    }                                \
})
```

#### 通用分发宏 `_arch_cmpxchg`
```c
#define _arch_cmpxchg(ptr, old, new, sc_sfx, cas_sfx,            \
              sc_prepend, sc_append,                \
              cas_prepend, cas_append)                \
({                                    \
    __typeof__(ptr) __ptr = (ptr);                    \
    __typeof__(*(__ptr)) __old = (old);                \
    __typeof__(*(__ptr)) __new = (new);                \
    __typeof__(*(__ptr)) __ret;                    \
                                    \
    switch (sizeof(*__ptr)) {                    \
    case 1:                                \
        __arch_cmpxchg_masked(sc_sfx, ".b" cas_sfx,        \
                      sc_prepend, sc_append,        \
                      cas_prepend, cas_append,        \
                      __ret, __ptr, __old, __new);    \
        break;                            \
    case 2:                                \
        __arch_cmpxchg_masked(sc_sfx, ".h" cas_sfx,        \
                      sc_prepend, sc_append,        \
                      cas_prepend, cas_append,        \
                      __ret, __ptr, __old, __new);    \
        break;                            \
    case 4:                                \
        __arch_cmpxchg(".w", ".w" sc_sfx, ".w" cas_sfx,        \
                   sc_prepend, sc_append,            \
                   cas_prepend, cas_append,            \
                   __ret, __ptr, (long)(int)(long), __old, __new);    \
        break;                            \
    case 8:                                \
        __arch_cmpxchg(".d", ".d" sc_sfx, ".d" cas_sfx,        \
                   sc_prepend, sc_append,            \
                   cas_prepend, cas_append,            \
                   __ret, __ptr, /**/, __old, __new);    \
        break;                            \
    default:                            \
        BUILD_BUG();                        \
    }                                \
    (__typeof__(*(__ptr)))__ret;                    \
})
```

#### 简化的用户接口宏
```c
#define arch_cmpxchg_relaxed(ptr, o, n)                    \
    _arch_cmpxchg((ptr), (o), (n),                    \
              SC_SFX(""), CAS_SFX(""),                \
              SC_PREPEND(""), SC_APPEND(""),            \
              CAS_PREPEND(""), CAS_APPEND(""))

#define arch_cmpxchg_acquire(ptr, o, n)                    \
    _arch_cmpxchg((ptr), (o), (n),                    \
              SC_SFX(""), CAS_SFX(""),                \
              SC_PREPEND(""), SC_APPEND(RISCV_ACQUIRE_BARRIER),    \
              CAS_PREPEND(""), CAS_APPEND(RISCV_ACQUIRE_BARRIER))

#define arch_cmpxchg_release(ptr, o, n)                    \
    _arch_cmpxchg((ptr), (o), (n),                    \
              SC_SFX(""), CAS_SFX(""),                \
              SC_PREPEND(RISCV_RELEASE_BARRIER), SC_APPEND(""),    \
              CAS_PREPEND(RISCV_RELEASE_BARRIER), CAS_APPEND(""))

#define arch_cmpxchg(ptr, o, n)                        \
    _arch_cmpxchg((ptr), (o), (n),                    \
              SC_SFX(".rl"), CAS_SFX(".aqrl"),            \
              SC_PREPEND(""), SC_APPEND(RISCV_FULL_BARRIER),    \
              CAS_PREPEND(""), CAS_APPEND(""))

#define arch_cmpxchg_local(ptr, o, n)                    \
    arch_cmpxchg_relaxed((ptr), (o), (n))
```

## 技术原理分析

### 1. 内存序语义统一

新的实现通过参数化的方式统一处理不同的内存序要求：

- **Relaxed**: 无内存屏障
- **Acquire**: 在操作后添加acquire屏障 (`RISCV_ACQUIRE_BARRIER`)
- **Release**: 在操作前添加release屏障 (`RISCV_RELEASE_BARRIER`)
- **Full**: 使用`.rl`后缀和完整屏障 (`RISCV_FULL_BARRIER`)

### 2. 指令后缀参数化

通过 `lr_sfx` 和 `sc_sfx` 参数控制：
- `.w` 用于32位操作
- `.d` 用于64位操作
- `.rl` 用于release语义的store conditional

### 3. ZACAS扩展支持

新实现同时支持传统的LR/SC（Load-Reserved/Store-Conditional）和新的ZACAS（原子比较交换）扩展：

```c
if (IS_ENABLED(CONFIG_RISCV_ISA_ZACAS) &&
    riscv_has_extension_unlikely(RISCV_ISA_EXT_ZACAS)) {
    // 使用 amocas 指令
    __asm__ __volatile__ (
        cas_prepend
        "    amocas" cas_sfx " %0, %z2, %1\n"
        cas_append
        : "+&r" (r), "+A" (*(p))
        : "rJ" (n)
        : "memory");
} else {
    // 使用传统的 lr/sc 序列
}
```

### 4. 类型安全性

通过 `sizeof(*__ptr)` 在编译时确定操作大小，支持1、2、4、8字节的原子操作。

## 优化效果

### 1. 代码重复消除
- **删除行数**: 约190行重复的汇编代码
- **新增行数**: 约61行统一的参数化实现
- **净减少**: 约129行代码

### 2. 维护性提升
- 从8个独立的汇编实现减少到1个参数化实现
- 任何修改只需在一个地方进行
- 降低了引入bug的风险

### 3. 性能保证
Commit message明确说明："This did not cause any change in generated asm"，即生成的汇编代码完全相同，性能无影响。

## 相关提交分析

此patch是一个系列重构的一部分：

1. **前置提交** `4bfa185fe3f0`: "riscv/cmpxchg: Deduplicate xchg() asm functions"
   - 对xchg()函数进行了类似的去重复化处理
   - 为cmpxchg()的重构奠定了基础

2. **设计模式一致性**:
   - 两个提交使用了相同的参数化宏设计模式
   - 统一了RISC-V原子操作的代码风格

## 代码审查和测试

- **Reviewed-by**: Guo Ren <guoren@kernel.org>, Andrea Parri <parri.andrea@gmail.com>
- **Tested-by**: Guo Ren <guoren@kernel.org>
- **邮件列表讨论**: https://lore.kernel.org/r/20240103163203.72768-4-leobras@redhat.com

## 总结

这个patch是一个优秀的代码重构示例，它：

1. **解决了实际问题**: 消除了大量重复代码，提高了可维护性
2. **保持了功能等价性**: 生成的汇编代码完全相同
3. **提升了代码质量**: 使用参数化宏统一了不同变体的实现
4. **支持了新特性**: 为ZACAS扩展提供了统一的支持框架
5. **遵循了最佳实践**: 通过充分的代码审查和测试确保了质量

这种重构方法可以作为其他架构和子系统进行类似优化的参考模板。