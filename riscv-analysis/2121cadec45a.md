# Patch Analysis: 2121cadec45a

## 基本信息

- **Commit ID**: 2121cadec45a
- **标题**: RISCV: KVM: Introduce mp_state_lock to avoid lock inversion
- **作者**: Yong-Xuan Wang <yongxuan.wang@sifive.com>
- **日期**: 2024年4月17日
- **审核者**: Anup Patel <anup@brainfault.org>

## 问题背景

### 1. 锁顺序倒置问题

根据 `Documentation/virt/kvm/locking.rst` 的建议，KVM中的锁获取顺序应该是：
```
kvm->lock 应该在 vcpu->mutex 和 kvm->srcu 之外获取
```

但是在KVM/RISC-V处理 `SBI_EXT_HSM_HART_START` 时，实际的锁顺序是：
```
vcpu->mutex -> kvm->srcu -> kvm->lock
```

这违反了推荐的锁顺序，可能导致死锁问题。

### 2. RCU锁依赖问题

虽然在commit `f0f44752f5f6` ("rcu: Annotate SRCU's update-side lockdep dependencies") 之后，lockdep不再报告这个问题，但锁顺序问题依然存在。

## 详细修改内容

### 1. 头文件修改 (arch/riscv/include/asm/kvm_host.h)

#### 1.1 数据结构变更
```c
// 原来的实现
struct kvm_vcpu_arch {
    /* VCPU power-off state */
    bool power_off;
};

// 新的实现
struct kvm_vcpu_arch {
    /* VCPU power state */
    struct kvm_mp_state mp_state;
    spinlock_t mp_state_lock;
};
```

#### 1.2 函数声明更新
```c
// 新增函数
void __kvm_riscv_vcpu_power_off(struct kvm_vcpu *vcpu);
void __kvm_riscv_vcpu_power_on(struct kvm_vcpu *vcpu);
bool kvm_riscv_vcpu_stopped(struct kvm_vcpu *vcpu);
```

### 2. VCPU核心实现修改 (arch/riscv/kvm/vcpu.c)

#### 2.1 初始化修改
```c
// 在 kvm_arch_vcpu_create() 中添加
spin_lock_init(&vcpu->arch.mp_state_lock);
vcpu->arch.mp_state.mp_state = KVM_MP_STATE_STOPPED;
```

#### 2.2 电源管理函数重构

**原来的实现**:
```c
void kvm_riscv_vcpu_power_off(struct kvm_vcpu *vcpu)
{
    vcpu->arch.power_off = true;
    kvm_make_request(KVM_REQ_SLEEP, vcpu);
    kvm_vcpu_kick(vcpu);
}

void kvm_riscv_vcpu_power_on(struct kvm_vcpu *vcpu)
{
    vcpu->arch.power_off = false;
    kvm_vcpu_wake_up(vcpu);
}
```

**新的实现**:
```c
// 内部函数，不加锁
void __kvm_riscv_vcpu_power_off(struct kvm_vcpu *vcpu)
{
    WRITE_ONCE(vcpu->arch.mp_state.mp_state, KVM_MP_STATE_STOPPED);
    kvm_make_request(KVM_REQ_SLEEP, vcpu);
    kvm_vcpu_kick(vcpu);
}

void __kvm_riscv_vcpu_power_on(struct kvm_vcpu *vcpu)
{
    WRITE_ONCE(vcpu->arch.mp_state.mp_state, KVM_MP_STATE_RUNNABLE);
    kvm_vcpu_wake_up(vcpu);
}

// 外部接口，带锁保护
void kvm_riscv_vcpu_power_off(struct kvm_vcpu *vcpu)
{
    spin_lock(&vcpu->arch.mp_state_lock);
    __kvm_riscv_vcpu_power_off(vcpu);
    spin_unlock(&vcpu->arch.mp_state_lock);
}

void kvm_riscv_vcpu_power_on(struct kvm_vcpu *vcpu)
{
    spin_lock(&vcpu->arch.mp_state_lock);
    __kvm_riscv_vcpu_power_on(vcpu);
    spin_unlock(&vcpu->arch.mp_state_lock);
}

// 新增状态检查函数
bool kvm_riscv_vcpu_stopped(struct kvm_vcpu *vcpu)
{
    return READ_ONCE(vcpu->arch.mp_state.mp_state) == KVM_MP_STATE_STOPPED;
}
```

#### 2.3 状态检查更新
```c
// 原来的检查
if (vcpu->arch.power_off)

// 新的检查
if (kvm_riscv_vcpu_stopped(vcpu))
```

### 3. SBI HSM扩展修改 (arch/riscv/kvm/vcpu_sbi_hsm.c)

#### 3.1 HART启动函数修改

**原来的实现**:
```c
static int kvm_sbi_hsm_vcpu_start(struct kvm_vcpu *vcpu)
{
    // ... 参数检查 ...
    kvm_riscv_vcpu_power_on(target_vcpu);
    return 0;
}

static int kvm_sbi_ext_hsm_handler(...)
{
    switch (funcid) {
    case SBI_EXT_HSM_HART_START:
        mutex_lock(&kvm->lock);  // 问题所在
        ret = kvm_sbi_hsm_vcpu_start(vcpu);
        mutex_unlock(&kvm->lock);
        break;
    }
}
```

**新的实现**:
```c
static int kvm_sbi_hsm_vcpu_start(struct kvm_vcpu *vcpu)
{
    // ... 参数检查 ...
    
    spin_lock(&target_vcpu->arch.mp_state_lock);  // 使用新锁
    
    if (!kvm_riscv_vcpu_stopped(target_vcpu)) {
        ret = SBI_ERR_ALREADY_AVAILABLE;
        goto out;
    }
    
    // 设置重置上下文
    reset_cntx->sepc = cp->a1;
    reset_cntx->a0 = target_vcpuid;
    reset_cntx->a1 = cp->a2;
    kvm_make_request(KVM_REQ_VCPU_RESET, target_vcpu);
    
    __kvm_riscv_vcpu_power_on(target_vcpu);  // 使用内部函数
    
out:
    spin_unlock(&target_vcpu->arch.mp_state_lock);
    return ret;
}

static int kvm_sbi_ext_hsm_handler(...)
{
    switch (funcid) {
    case SBI_EXT_HSM_HART_START:
        ret = kvm_sbi_hsm_vcpu_start(vcpu);  // 移除kvm->lock
        break;
    }
}
```

#### 3.2 HART停止函数修改

**原来的实现**:
```c
static int kvm_sbi_hsm_vcpu_stop(struct kvm_vcpu *vcpu)
{
    if (vcpu->arch.power_off)
        return SBI_ERR_FAILURE;
    
    kvm_riscv_vcpu_power_off(vcpu);
    return 0;
}
```

**新的实现**:
```c
static int kvm_sbi_hsm_vcpu_stop(struct kvm_vcpu *vcpu)
{
    int ret = 0;
    
    spin_lock(&vcpu->arch.mp_state_lock);
    
    if (kvm_riscv_vcpu_stopped(vcpu)) {
        ret = SBI_ERR_FAILURE;
        goto out;
    }
    
    __kvm_riscv_vcpu_power_off(vcpu);
    
out:
    spin_unlock(&vcpu->arch.mp_state_lock);
    return ret;
}
```

### 4. SBI系统重置修改 (arch/riscv/kvm/vcpu_sbi.c)

```c
// 原来的实现
kvm_for_each_vcpu(i, tmp, vcpu->kvm)
    tmp->arch.power_off = true;

// 新的实现
kvm_for_each_vcpu(i, tmp, vcpu->kvm) {
    spin_lock(&tmp->arch.mp_state_lock);
    WRITE_ONCE(tmp->arch.mp_state.mp_state, KVM_MP_STATE_STOPPED);
    spin_unlock(&tmp->arch.mp_state_lock);
}
```

## 技术原理分析

### 1. 锁粒度细化

**原来的方案**:
- 使用全局的 `kvm->lock` 保护HART启动操作
- 锁粒度大，容易产生锁顺序问题

**新的方案**:
- 使用每个VCPU独有的 `mp_state_lock` 保护状态变更
- 锁粒度小，避免了与其他锁的冲突

### 2. 内存访问优化

使用 `READ_ONCE()` 和 `WRITE_ONCE()` 宏：
- 确保编译器不会对内存访问进行优化重排
- 提供内存屏障语义
- 避免在多核环境下的竞态条件

### 3. 函数分层设计

```
公共接口层: kvm_riscv_vcpu_power_on/off() - 带锁保护
     ↓
内部实现层: __kvm_riscv_vcpu_power_on/off() - 不带锁，供已持锁的代码调用
```

这种设计模式的优点：
- 避免重复加锁
- 提供灵活的调用接口
- 保持API的向后兼容性

### 4. 状态管理改进

**原来的布尔状态**:
```c
bool power_off;  // 只有开/关两种状态
```

**新的枚举状态**:
```c
struct kvm_mp_state mp_state;  // 支持多种状态
// KVM_MP_STATE_RUNNABLE
// KVM_MP_STATE_STOPPED
// 未来可扩展更多状态
```

## 相关提交分析

### 1. 前置提交: f0f44752f5f6
- **标题**: "rcu: Annotate SRCU's update-side lockdep dependencies"
- **作用**: 修复了SRCU锁依赖的lockdep注解
- **影响**: 使得原来的锁顺序问题不再被lockdep检测到，但问题依然存在

### 2. 后续提交: 9752fed8f67c
- **标题**: "RISCV: KVM: Introduce vcpu->reset_cntx_lock"
- **作用**: 引入了另一个专用锁来保护重置上下文
- **关系**: 延续了本patch的设计思路，进一步细化锁粒度

## 影响和意义

### 1. 解决的问题
- **锁顺序倒置**: 避免了潜在的死锁风险
- **竞态条件**: 通过细粒度锁保护，避免了HART状态的竞态条件
- **代码健壮性**: 提高了多核环境下的代码稳定性

### 2. 性能影响
- **正面影响**: 减少了锁竞争，提高了并发性能
- **开销**: 增加了少量的锁操作开销，但相比解决的问题微不足道

### 3. 维护性提升
- **代码清晰**: 状态管理更加明确
- **扩展性**: 为未来支持更多VCPU状态奠定了基础
- **一致性**: 与KVM通用的mp_state机制保持一致

## 总结

这个patch通过引入专用的 `mp_state_lock` 和重构VCPU状态管理，成功解决了KVM/RISC-V中的锁顺序倒置问题。主要改进包括：

1. **锁设计优化**: 用细粒度的per-VCPU锁替代全局锁
2. **状态管理重构**: 从简单布尔值升级到标准的mp_state结构
3. **API分层**: 提供带锁和不带锁的两套接口
4. **内存安全**: 使用READ_ONCE/WRITE_ONCE确保内存访问安全

这个修改不仅解决了当前的技术问题，还为未来的功能扩展和性能优化奠定了良好的基础。