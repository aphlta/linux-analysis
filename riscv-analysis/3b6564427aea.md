# RISC-V 非连续内存区域线性映射检查修复 Patch 分析

## Commit 信息

- **Commit ID**: 3b6564427aea
- **作者**: Stuart Menefy <stuart.menefy@codasip.com>
- **提交日期**: 2024年6月22日
- **标题**: riscv: Fix linear mapping checks for non-contiguous memory regions
- **签名者**: Palmer Dabbelt <palmer@rivosinc.com>
- **审核者**: David McKay <david.mckay@codasip.com>, Alexandre Ghiti <alexghiti@rivosinc.com>
- **修复**: c99127c45248 ("riscv: Make sure the linear mapping does not use the kernel mapping")

## Patch 概述

这个patch修复了RISC-V架构中处理非连续内存区域时线性映射检查的问题。主要解决了memblock在不知道某些物理内存无法使用的情况下，从内存顶部分配了超出线性映射区域的内存，导致内核panic的问题。

## 详细修改内容

### 修改的文件

**文件**: `arch/riscv/mm/init.c`

### 具体代码修改

#### 1. setup_bootmem() 函数修改

**移动 phys_ram_end 计算位置**:
```c
// 修改前
phys_ram_end = memblock_end_of_DRAM();
// ... 其他代码

// 修改后
// ... 其他代码
phys_ram_end = memblock_end_of_DRAM(); // 移动到函数末尾
```

**新增内存范围限制逻辑**:
```c
/*
 * The size of the linear page mapping may restrict the amount of
 * usable RAM.
 */
if (IS_ENABLED(CONFIG_64BIT)) {
    max_mapped_addr = __pa(PAGE_OFFSET) + KERN_VIRT_SIZE;
    memblock_cap_memory_range(phys_ram_base,
                              max_mapped_addr - phys_ram_base);
}
```

#### 2. create_linear_mapping_page_table() 函数修改

**移除内存限制检查**:
```c
// 修改前
if (end >= __pa(PAGE_OFFSET) + memory_limit)
    end = __pa(PAGE_OFFSET) + memory_limit;

// 修改后
// 完全移除这个检查
```

## 技术背景和原理分析

### 1. RISC-V 内存布局

#### 64位RISC-V内存布局

```
虚拟地址空间布局:
+------------------+ 0xFFFFFFFFFFFFFFFF
|   内核映射区     |
+------------------+ KERNEL_LINK_ADDR
|   线性映射区     | KERN_VIRT_SIZE
+------------------+ PAGE_OFFSET
|   用户空间       |
+------------------+ 0x0000000000000000
```

#### 关键常量定义

- **PAGE_OFFSET**: 线性映射区的起始虚拟地址
  - L3: `0xffffffd600000000`
  - L4: `0xffffaf8000000000` 
  - L5: `0xff60000000000000`

- **KERN_VIRT_SIZE**: 线性映射区的大小
  ```c
  #define KERN_VIRT_SIZE ((PTRS_PER_PGD / 2 * PGDIR_SIZE) / 2)
  ```

- **KERNEL_LINK_ADDR**: 内核链接地址
  ```c
  #define KERNEL_LINK_ADDR (ADDRESS_SPACE_END - SZ_2G + 1)
  ```

### 2. 问题根源分析

#### 原始问题场景

1. **非连续内存配置**: 系统具有非连续的物理内存区域
2. **memblock分配策略**: memblock从内存顶部分配内存
3. **线性映射限制**: 线性映射区域有大小限制(KERN_VIRT_SIZE)
4. **映射冲突**: 分配的内存超出了线性映射能够覆盖的范围

#### 错误堆栈分析

```
[    0.000000] Unable to handle kernel paging request at virtual address fffffffe7fff5350
[    0.000000] [<ffffffff805e88c8>] __memset+0x8c/0x104
[    0.000000] [<ffffffff8062349c>] early_init_dt_alloc_memory_arch+0x1e/0x48
[    0.000000] [<ffffffff8043e892>] __unflatten_device_tree+0x52/0x114
```

**错误分析**:
- 虚拟地址 `fffffffe7fff5350` 超出了线性映射区域
- memblock分配的物理内存无法通过线性映射访问
- 导致在设备树展开过程中发生页面错误

### 3. 修复原理

#### memblock_cap_memory_range() 函数作用

```c
void memblock_cap_memory_range(phys_addr_t base, phys_addr_t size)
```

**功能**: 限制memblock可用的内存范围，确保所有分配都在指定范围内

**参数**:
- `base`: 可用内存的起始物理地址
- `size`: 可用内存的大小

**工作原理**:
1. 移除超出指定范围的内存区域
2. 确保后续的memblock分配都在有效范围内
3. 防止分配超出线性映射能力的内存

#### 修复逻辑

```c
max_mapped_addr = __pa(PAGE_OFFSET) + KERN_VIRT_SIZE;
memblock_cap_memory_range(phys_ram_base, max_mapped_addr - phys_ram_base);
```

**计算过程**:
1. `__pa(PAGE_OFFSET)`: 线性映射区对应的物理地址起始
2. `+ KERN_VIRT_SIZE`: 加上线性映射区大小得到最大可映射物理地址
3. `max_mapped_addr - phys_ram_base`: 计算可用内存范围大小

### 4. 时序调整

#### phys_ram_end 计算时机调整

**修改前**: 在内存限制设置之前计算
**修改后**: 在内存限制设置之后计算

**原因**: 确保 `phys_ram_end` 反映经过限制后的实际可用内存范围

## 相关提交分析

### 1. 原始问题提交 (c99127c45248)

**标题**: "riscv: Make sure the linear mapping does not use the kernel mapping"
**作者**: Alexandre Ghiti <alex@ghiti.fr>
**日期**: 2021年6月29日

**原始修改**:
```c
if (end >= __pa(PAGE_OFFSET) + memory_limit)
    end = __pa(PAGE_OFFSET) + memory_limit;
```

**问题**: 这个修改只在页表创建时限制映射范围，但没有限制memblock的分配范围，导致memblock仍可能分配超出线性映射能力的内存。

### 2. 修复策略对比

| 方面 | 原始方案 | 当前修复 |
|------|----------|----------|
| 限制时机 | 页表创建时 | memblock初始化时 |
| 限制范围 | 映射范围 | 分配范围 |
| 问题解决 | 部分 | 完全 |
| 副作用 | 内存分配失败 | 无 |

## 技术影响和意义

### 1. 修复的问题

1. **内核panic**: 解决了非连续内存配置下的启动失败
2. **内存分配错误**: 防止memblock分配无法访问的内存
3. **设备树处理**: 确保设备树展开过程的内存访问安全

### 2. 系统稳定性提升

1. **启动可靠性**: 提高了复杂内存配置下的启动成功率
2. **内存管理**: 改善了早期内存管理的正确性
3. **架构兼容性**: 增强了对不同内存布局的支持

### 3. 性能影响

1. **内存利用**: 可能减少可用内存总量(在某些配置下)
2. **启动时间**: 对启动时间影响微小
3. **运行时性能**: 对运行时性能无影响

## 测试和验证

### 1. 测试场景

1. **非连续内存**: 具有内存空洞的系统配置
2. **大内存系统**: 内存大小接近或超过线性映射限制的系统
3. **不同页表级别**: L3/L4/L5页表配置的测试

### 2. 验证方法

1. **启动测试**: 确保系统能够正常启动
2. **内存检查**: 验证可用内存范围的正确性
3. **功能测试**: 确保内存相关功能正常工作

## 潜在风险和注意事项

### 1. 内存可用性

**风险**: 在某些配置下可能减少可用内存总量
**缓解**: 这是为了系统稳定性的必要权衡

### 2. 兼容性

**风险**: 可能影响依赖特定内存布局的代码
**缓解**: 修改遵循标准的内存管理原则

### 3. 性能考虑

**风险**: 理论上可能影响内存访问性能
**实际**: 对实际性能影响极小

## 总结

这个patch通过在memblock初始化阶段限制可用内存范围，从根本上解决了RISC-V架构中非连续内存区域导致的线性映射问题。修复策略简洁有效，通过调用 `memblock_cap_memory_range()` 确保所有内存分配都在线性映射能够覆盖的范围内，避免了后续的内存访问错误。

这个修复体现了内核开发中"预防胜于治疗"的原则，通过在问题源头(内存分配阶段)进行限制，而不是在问题表现(页表映射阶段)进行修补，提供了更加可靠和优雅的解决方案。

对于RISC-V架构的发展，这个patch增强了内核对复杂内存配置的支持能力，提高了系统的稳定性和可靠性，为RISC-V在服务器和高端应用场景的部署提供了更好的基础。