# Patch Analysis: 51781ce8f448

## Commit Information
- **Commit ID**: 51781ce8f4486c3738a6c85175b599ad1be71f89
- **Title**: riscv: Pass patch_text() the length in bytes
- **Author**: Samuel Holland <samuel.holland@sifive.com>
- **Date**: Wed Mar 27 09:04:44 2024 -0700
- **Reviewed-by**: Björn Töpel <bjorn@rivosinc.com>, Conor Dooley <conor.dooley@microchip.com>
- **Signed-off-by**: Palmer Dabbelt <palmer@rivosinc.com>
- **Link**: https://lore.kernel.org/r/20240327160520.791322-6-samuel.holland@sifive.com

## 修改概述

这个patch主要优化了RISC-V架构中指令修补的效率，通过向`patch_text()`函数传递正确的字节长度来减少不必要的循环和icache刷新次数。涉及两个核心文件：
1. `arch/riscv/kernel/probes/kprobes.c` - kprobes指令修补
2. `arch/riscv/net/bpf_jit_comp64.c` - BPF JIT指令修补

**核心改进**: `patch_text_nosync()`已经能够处理任意长度的代码，这个patch移除了多余的循环并减少了icache刷新次数。

## 详细修改内容

### 1. kprobes.c 修改

#### 修改前的问题
```c
// arch_arm_kprobe函数中
u32 insn = (p->opcode & __INSN_LENGTH_MASK) == __INSN_LENGTH_32 ?
           __BUG_INSN_32 : __BUG_INSN_16;
patch_text(p->addr, &insn, 1);  // 错误：总是传递1字节

// arch_disarm_kprobe函数中
patch_text(p->addr, &p->opcode, 1);  // 错误：总是传递1字节
```

#### 修改后的解决方案
```c
// arch_arm_kprobe函数中
size_t len = GET_INSN_LENGTH(p->opcode);
u32 insn = len == 4 ? __BUG_INSN_32 : __BUG_INSN_16;
patch_text(p->addr, &insn, len);  // 正确：传递实际指令长度

// arch_disarm_kprobe函数中
size_t len = GET_INSN_LENGTH(p->opcode);
patch_text(p->addr, &p->opcode, len);  // 正确：传递实际指令长度
```

### 2. bpf_jit_comp64.c 修改

#### 新增宏定义
```c
#define RV_FENTRY_NINSNS 2
+#define RV_FENTRY_NBYTES (RV_FENTRY_NINSNS * 4)  // 新增：8字节
```

#### 修改bpf_arch_text_poke函数
```c
// 修改前
if (memcmp(ip, old_insns, RV_FENTRY_NINSNS * 4))  // 硬编码计算
    return -EFAULT;
// ...
if (memcmp(ip, new_insns, RV_FENTRY_NINSNS * 4))
    ret = patch_text(ip, new_insns, RV_FENTRY_NINSNS);

// 修改后
if (memcmp(ip, old_insns, RV_FENTRY_NBYTES))  // 使用宏定义
    return -EFAULT;
// ...
if (memcmp(ip, new_insns, RV_FENTRY_NBYTES))
    ret = patch_text(ip, new_insns, RV_FENTRY_NBYTES);
```

## 技术原理分析

### 1. RISC-V指令长度机制

RISC-V架构支持两种指令长度：
- **16位压缩指令** (C扩展): 以`c.`开头的指令
- **32位标准指令**: 标准RISC-V指令

指令长度判断机制（在`asm/bug.h`中定义）：
```c
#define __INSN_LENGTH_MASK  _UL(0x3)
#define __INSN_LENGTH_32    _UL(0x3)

#define GET_INSN_LENGTH(insn) \
({ \
    unsigned long __len; \
    __len = ((insn & __INSN_LENGTH_MASK) == __INSN_LENGTH_32) ? \
        4UL : 2UL; \
    __len; \
})
```

**判断逻辑**：
- 指令的最低2位为`11`时，为32位指令（4字节）
- 指令的最低2位不为`11`时，为16位指令（2字节）

### 2. kprobes断点指令

```c
#define __BUG_INSN_32   _UL(0x00100073) /* ebreak */
#define __BUG_INSN_16   _UL(0x9002)     /* c.ebreak */
```

- `ebreak`: 32位断点指令
- `c.ebreak`: 16位压缩断点指令

### 3. patch_text函数的参数意义

`patch_text(addr, data, len)`函数的第三个参数`len`表示要修补的**字节数**，不是指令数量。

**修改前的问题**：
- 无论是16位还是32位指令，都传递`1`作为长度参数
- 这导致32位指令只修补了前1个字节，造成指令损坏

**修改后的解决**：
- 16位指令传递`2`字节
- 32位指令传递`4`字节
- 确保完整修补整个指令

## 性能影响分析

### 1. icache刷新优化
- **改进前**: 每次调用`patch_text()`都可能触发多次icache刷新
- **改进后**: 通过传递正确的字节长度，`patch_text_nosync()`可以一次性处理完整指令
- **性能提升**: 减少了不必要的icache刷新操作，提高了指令修补效率

### 2. 代码维护性提升
- **改进前**: 硬编码的字节数计算（如`RV_FENTRY_NINSNS * 4`）
- **改进后**: 使用宏定义`RV_FENTRY_NBYTES`，提高代码可读性和维护性
- **影响范围**: BPF JIT和kprobes的指令修补代码

## 修复验证

### 1. 指令长度计算验证
```c
// 16位指令示例: c.nop (0x0001)
u16 insn_16 = 0x0001;
size_t len_16 = GET_INSN_LENGTH(insn_16);  // 返回2

// 32位指令示例: nop (0x00000013)
u32 insn_32 = 0x00000013;
size_t len_32 = GET_INSN_LENGTH(insn_32);  // 返回4
```

### 2. 断点指令选择验证
```c
// 对于16位指令
if (len == 2) {
    insn = __BUG_INSN_16;  // 0x9002 (c.ebreak)
}
// 对于32位指令
if (len == 4) {
    insn = __BUG_INSN_32;  // 0x00100073 (ebreak)
}
```

## 相关提交分析

这个patch是Samuel Holland在2024年3月提交的RISC-V指令修补优化系列的一部分：

### 同一系列的相关提交

1. **b1756750a397** - "riscv: kprobes: Use patch_text_nosync() for insn slots"
   - 日期: Wed Mar 27 09:04:42 2024 -0700
   - 作用: 对于尚未对系统其他部分可见的指令，使用`patch_text_nosync()`避免不必要的`stop_machine()`操作
   - 影响文件: `arch/riscv/kernel/probes/kprobes.c`

2. **5080ca0fe9b5** - "riscv: Simplify text patching loops"
   - 日期: Wed Mar 27 09:04:43 2024 -0700
   - 作用: 简化文本修补循环，减少变量数量，使代码更易理解
   - 影响文件: `arch/riscv/kernel/patch.c`

3. **51781ce8f448** - "riscv: Pass patch_text() the length in bytes" (本patch)
   - 日期: Wed Mar 27 09:04:44 2024 -0700
   - 作用: 向`patch_text()`传递正确的字节长度，减少循环和icache刷新

4. **2aa30d19cfbb** - "riscv: jump_label: Simplify assembly syntax"
   - 日期: 后续提交，简化跳转标签的汇编语法

5. **652b56b18439** - "riscv: jump_label: Batch icache maintenance"
   - 日期: 后续提交，批量处理icache维护操作

### 系列优化的整体目标

这个提交系列的主要目标是优化RISC-V架构的指令修补性能：
- **减少icache刷新次数**: 通过批量处理和正确的长度参数
- **避免不必要的同步**: 使用`patch_text_nosync()`替代`patch_text()`
- **简化代码逻辑**: 减少变量和循环复杂度
- **提高修补效率**: 一次性处理完整指令而非逐字节处理

## 总结

这个patch是RISC-V架构指令修补性能优化系列的重要组成部分：

1. **核心改进**: 向`patch_text()`传递正确的字节长度而非指令数量，充分利用`patch_text_nosync()`的批量处理能力
2. **性能优化**: 减少了不必要的循环和icache刷新次数，提高了指令修补效率
3. **代码质量**: 用宏定义`RV_FENTRY_NBYTES`替换硬编码计算，提高代码可维护性
4. **影响范围**: 优化了kprobes和BPF JIT的指令修补性能

**技术意义**: 这个优化体现了对RISC-V架构特性的深入理解，通过正确使用现有API来提升系统性能，是一个典型的性能优化案例。

**实际效果**: 减少了指令修补过程中的系统开销，特别是在频繁使用kprobes和BPF tracing的场景下，能够显著提升系统响应性能。