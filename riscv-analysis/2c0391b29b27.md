# RISC-V NOMMU内核内存访问优化补丁分析

## 基本信息

**Commit ID:** 2c0391b29b27f315c1b4c29ffde66f50b29fab99  
**作者:** Samuel Holland <samuel.holland@sifive.com>  
**日期:** 2024年10月26日  
**标题:** riscv: Allow NOMMU kernels to access all of RAM  
**审核者:** Jesse Taube <mr.bossman075@gmail.com>  
**合并者:** Palmer Dabbelt <palmer@rivosinc.com>  

## 问题背景

在此补丁之前，RISC-V NOMMU（无内存管理单元）内核存在一个重要限制：**无法访问内核链接地址以下的内存区域**。这个限制严重影响了NOMMU系统的内存利用率，特别是在内存资源有限的嵌入式系统中。

### 原有问题

1. **内存访问限制**：NOMMU内核只能访问内核链接地址之上的内存
2. **内存浪费**：内核链接地址以下的RAM无法被利用
3. **系统效率低下**：在内存受限的嵌入式系统中，这种限制尤其严重

## 补丁修改内容详细分析

### 1. arch/riscv/include/asm/page.h 修改

#### 修改前的代码结构
```c
#ifdef CONFIG_64BIT
#ifdef CONFIG_MMU
#define PAGE_OFFSET            kernel_map.page_offset
#else
#define PAGE_OFFSET            _AC(CONFIG_PAGE_OFFSET, UL)
#endif
#else
#define PAGE_OFFSET            _AC(CONFIG_PAGE_OFFSET, UL)
#endif /* CONFIG_64BIT */
```

#### 修改后的代码结构
```c
#ifdef CONFIG_MMU
#ifdef CONFIG_64BIT
#define PAGE_OFFSET            kernel_map.page_offset
#else
#define PAGE_OFFSET            _AC(CONFIG_PAGE_OFFSET, UL)
#endif /* CONFIG_64BIT */
#else
#define PAGE_OFFSET            ((unsigned long)phys_ram_base)
#endif /* CONFIG_MMU */
```

#### 关键变化

1. **条件判断重新组织**：将`CONFIG_MMU`作为最外层判断条件
2. **NOMMU情况下的新定义**：`PAGE_OFFSET = (unsigned long)phys_ram_base`
3. **动态内存基址**：不再使用固定的`CONFIG_PAGE_OFFSET`，而是使用运行时确定的`phys_ram_base`

#### ARCH_PFN_OFFSET 简化

**修改前：**
```c
#ifdef CONFIG_MMU
#define ARCH_PFN_OFFSET                (PFN_DOWN((unsigned long)phys_ram_base))
#else
#define ARCH_PFN_OFFSET                (PAGE_OFFSET >> PAGE_SHIFT)
#endif /* CONFIG_MMU */
```

**修改后：**
```c
#define ARCH_PFN_OFFSET                (PFN_DOWN((unsigned long)phys_ram_base))
```

**意义：** 统一了MMU和NOMMU情况下的页帧偏移计算，都基于`phys_ram_base`。

### 2. arch/riscv/include/asm/pgtable.h 修改

#### KERNEL_LINK_ADDR 的重新定义

**修改前：**
```c
#ifndef CONFIG_MMU
#define KERNEL_LINK_ADDR       PAGE_OFFSET
#define KERN_VIRT_SIZE         (UL(-1))
#endif
```

**修改后：**
```c
#ifndef CONFIG_MMU
#ifdef CONFIG_RELOCATABLE
#define KERNEL_LINK_ADDR       UL(0)
#else
#define KERNEL_LINK_ADDR       _AC(CONFIG_PHYS_RAM_BASE, UL)
#endif
#define KERN_VIRT_SIZE         (UL(-1))
#endif
```

#### 关键变化分析

1. **可重定位内核支持**：
   - 当启用`CONFIG_RELOCATABLE`时，`KERNEL_LINK_ADDR = 0`
   - 这允许内核在任何物理地址加载

2. **非可重定位内核**：
   - 使用`CONFIG_PHYS_RAM_BASE`作为链接地址
   - 保持与配置的一致性

## 核心技术原理

### 1. phys_ram_base 变量

**定义位置：** `arch/riscv/mm/init.c:59`
```c
phys_addr_t phys_ram_base __ro_after_init;
EXPORT_SYMBOL(phys_ram_base);
```

**初始化过程：** 在`setup_bootmem()`函数中
```c
static void __init setup_bootmem(void)
{
    // ...
    if (!IS_ENABLED(CONFIG_XIP_KERNEL)) {
        phys_ram_base = memblock_start_of_DRAM() & PMD_MASK;
    }
    // ...
}
```

**关键特性：**
- `__ro_after_init`：初始化后只读，防止运行时修改
- 通过设备树动态确定RAM的实际起始地址
- PMD对齐以优化内存映射性能

### 2. 内存布局变化

#### 修改前（NOMMU）
```
内存布局：
[0x00000000 - CONFIG_PAGE_OFFSET)     <- 无法访问
[CONFIG_PAGE_OFFSET - 0xFFFFFFFF]     <- 可访问区域
```

#### 修改后（NOMMU）
```
内存布局：
[phys_ram_base - 0xFFFFFFFF]          <- 全部可访问
```

### 3. 地址转换机制

在NOMMU系统中，虚拟地址和物理地址的转换关系：

**修改前：**
- `virtual_addr = physical_addr - CONFIG_PAGE_OFFSET`
- 只能访问 `physical_addr >= CONFIG_PAGE_OFFSET` 的内存

**修改后：**
- `virtual_addr = physical_addr - phys_ram_base`
- 可以访问从`phys_ram_base`开始的所有RAM

## 兼容性和影响分析

### 1. 对现有系统的影响

**MMU系统：** 无影响，保持原有行为
**NOMMU系统：** 
- 可以访问更多内存
- 提高内存利用率
- 不破坏现有的内核链接机制

### 2. 配置选项的作用

**CONFIG_PAGE_OFFSET：** 
- 在MMU系统中继续用于定义虚拟地址空间布局
- 在NOMMU系统中仅用于内核链接地址（非可重定位情况）

**CONFIG_RELOCATABLE：**
- 启用时，内核可以在任何物理地址加载
- NOMMU + RELOCATABLE：`KERNEL_LINK_ADDR = 0`
- 提供最大的部署灵活性

### 3. 设备树依赖

此补丁增强了对设备树的依赖：
- `phys_ram_base`通过`memblock_start_of_DRAM()`从设备树获取
- 系统必须正确配置设备树中的内存节点

## 性能和优化考虑

### 1. 内存对齐优化

```c
phys_ram_base = memblock_start_of_DRAM() & PMD_MASK;
```

**PMD对齐的好处：**
- 提高TLB效率（虽然NOMMU没有TLB，但有助于缓存行为）
- 简化内存管理算法
- 与MMU系统保持一致的对齐策略

### 2. 运行时开销

**最小化开销：**
- `phys_ram_base`在初始化后为只读
- 地址转换仍然是简单的算术运算
- 不增加额外的间接访问

## 测试和验证

### 1. 功能验证

需要验证的场景：
1. **基本内存访问**：确保能访问RAM起始地址的内存
2. **内核模块加载**：验证动态内存分配正常工作
3. **设备驱动**：确保DMA和设备内存访问正常

### 2. 兼容性测试

1. **不同内存配置**：测试各种RAM起始地址
2. **设备树变化**：验证对不同设备树配置的适应性
3. **启动参数**：测试`mem=`参数的影响

## 相关提交分析

### 前置提交
- **bffada8201fc**: "riscv: Remove duplicate CONFIG_PAGE_OFFSET definition"
  - 清理重复定义，为本补丁做准备

### 后续影响
- 为RISC-V NOMMU系统的进一步优化奠定基础
- 可能影响未来的内存管理策略

## 潜在问题和注意事项

### 1. 设备树依赖风险

**问题：** 如果设备树配置错误，`phys_ram_base`可能不正确
**缓解：** 内核启动时的内存检测和验证机制

### 2. 调试复杂性

**问题：** 动态确定的内存基址可能增加调试难度
**缓解：** 保留原有的配置选项作为fallback

### 3. 工具链兼容性

**问题：** 某些调试工具可能假设固定的内存布局
**缓解：** 更新相关工具和文档

## 总结

这个补丁是RISC-V NOMMU支持的重要改进，主要成就：

1. **消除内存访问限制**：NOMMU内核现在可以访问所有可用RAM
2. **提高内存利用率**：特别有益于内存受限的嵌入式系统
3. **保持向后兼容**：不影响现有MMU系统的行为
4. **增强灵活性**：支持可重定位内核，提高部署灵活性
5. **优化内存布局**：通过动态确定内存基址，实现更优的内存管理

这个修改体现了Linux内核在嵌入式系统支持方面的持续改进，为RISC-V架构在资源受限环境中的应用提供了更好的支持。