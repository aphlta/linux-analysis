commit 2960f371f1653f6d8bc2321120eba2a14c861d4c
Author: Sunil V L <sunilvl@ventanamicro.com>
Date:   Wed Oct 18 18:10:07 2023 +0530

    RISC-V: cacheflush: Initialize CBO variables on ACPI systems

    Initialize the CBO variables on ACPI based systems using information in
    RHCT.

    Signed-off-by: Sunil V L <sunilvl@ventanamicro.com>
    Reviewed-by: Andrew Jones <ajones@ventanamicro.com>
    Reviewed-by: Samuel Holland <samuel.holland@sifive.com>
    Link: https://lore.kernel.org/r/20231018124007.1306159-5-sunilvl@ventanamicro.com
    Signed-off-by: Palmer Dabbelt <palmer@rivosinc.com>

diff --git a/arch/riscv/mm/cacheflush.c b/arch/riscv/mm/cacheflush.c
index f1387272a551..55a34f2020a8 100644
--- a/arch/riscv/mm/cacheflush.c
+++ b/arch/riscv/mm/cacheflush.c
@@ -3,7 +3,9 @@
  * Copyright (C) 2017 SiFive
  */

+#include <linux/acpi.h>
 #include <linux/of.h>
+#include <asm/acpi.h>
 #include <asm/cacheflush.h>

 #ifdef CONFIG_SMP
@@ -124,13 +126,24 @@ void __init riscv_init_cbo_blocksizes(void)
 	unsigned long cbom_hartid, cboz_hartid;
 	u32 cbom_block_size = 0, cboz_block_size = 0;
 	struct device_node *node;
+	struct acpi_table_header *rhct;
+	acpi_status status;
+
+	if (acpi_disabled) {
+		for_each_of_cpu_node(node) {
+			/* set block-size for cbom and/or cboz extension if available */
+			cbo_get_block_size(node, "riscv,cbom-block-size",
+					   &cbom_block_size, &cbom_hartid);
+			cbo_get_block_size(node, "riscv,cboz-block-size",
+					   &cboz_block_size, &cboz_hartid);
+		}
+	} else {
+		status = acpi_get_table(ACPI_SIG_RHCT, 0, &rhct);
+		if (ACPI_FAILURE(status))
+			return;

-	for_each_of_cpu_node(node) {
-		/* set block-size for cbom and/or cboz extension if available */
-		cbo_get_block_size(node, "riscv,cbom-block-size",
-				   &cbom_block_size, &cbom_hartid);
-		cbo_get_block_size(node, "riscv,cboz-block-size",
-				   &cboz_block_size, &cboz_hartid);
+		acpi_get_cbo_block_size(rhct, &cbom_block_size, &cboz_block_size, NULL);
+		acpi_put_table((struct acpi_table_header *)rhct);
 	}

 	if (cbom_block_size)



Alex Mao592

复制

删除

2960f371f165 和我详细聊聊patch以及它的前因后果

mygit

参考了 1 个上下文

c667ad229d13.md 160-168

用户想了解commit 2960f371f165的详细信息，我需要先查看这个commit的具体内容。

linux-stable 终端

git show 2960f371f165

现在我需要获取这个commit的完整信息，包括commit message和更多的上下文。

linux-stable 终端

git log --oneline -1 2960f371f165

让我查看这个commit的完整信息，包括详细的commit message。

linux-stable 终端

git log -1 --format=fuller 2960f371f165

现在我需要查看这个patch的前后相关commits，了解整个patch系列的背景。

linux-stable 终端

git log --oneline -10 2960f371f165

我需要查看这个patch系列的相关commits，特别是前面的几个ACPI相关的commits。

linux-stable 终端

git log --oneline 9ca87564190c a06835227280 e8065df5b0c4

让我查看这个patch系列中相关的commits的详细信息。

linux-stable 终端

git show --stat 9ca87564190c

现在让我查看这个patch系列的第一个commit，了解整个系列的背景。

linux-stable 终端

git show --stat e8065df5b0c4

让我查看这个patch修改的具体文件内容，了解CBO相关的代码变化。

arch\riscv\mm\cacheflush.c 120 - 150

现在让我查看ACPI相关的头文件，了解新增的函数声明。

arch\riscv\include\asm\acpi.h 1 - 50

让我查看ACPI头文件的其余部分，寻找CBO相关的函数声明。

arch\riscv\include\asm\acpi.h 51 - 90

现在让我查看RHCT相关的实现代码，了解如何从ACPI表中获取CBO信息。

drivers\acpi\riscv\rhct.c 1 - 50

让我查看RHCT文件中CBO相关的函数实现。

在工作区搜索 'acpi_get_cbo_block_size function implementation in RHCT'

让我查看RHCT文件中CBO相关函数的具体实现。

drivers\acpi\riscv\rhct.c 120 - 170

现在让我查看这个函数中调用的acpi_parse_hart_info_cmo_node函数的实现。

drivers\acpi\riscv\rhct.c 80 - 120

## Commit 2960f371f165 详细分析
### 基本信息
- Commit ID : 2960f371f165
- 标题 : RISC-V: cacheflush: Initialize CBO variables on ACPI systems
- 作者 : Sunil V L sunilvl@ventanamicro.com
- 提交时间 : 2023年10月18日
- 合并者 : Palmer Dabbelt palmer@rivosinc.com
### 技术背景
这个patch是RISC-V架构支持ACPI系统的重要组成部分，专门处理**Cache Block Operation (CBO)**相关的初始化问题。
 CBO是什么？
CBO（Cache Block Operation）是RISC-V架构中的缓存块操作扩展，包括：

- CBOM (Cache Block Management): 缓存块管理操作
- CBOZ (Cache Block Zero): 缓存块清零操作
- CBOP (Cache Block Prefetch): 缓存块预取操作
每种操作都有对应的块大小参数，这些参数对于正确执行缓存操作至关重要。

### 问题背景
在此patch之前，RISC-V Linux内核只能从**Device Tree (DT)**中获取CBO块大小信息：

```
// 原来的实现（仅支持DT）
for_each_of_cpu_node(node) {
    cbo_get_block_size(node, "riscv,cbom-block-size", 
                       &cbom_block_size, &cbom_hartid);
    cbo_get_block_size(node, "riscv,cboz-block-size", 
                       &cboz_block_size, &cboz_hartid);
}
```
但随着RISC-V生态的发展，**ACPI (Advanced Configuration and Power Interface) 系统变得越来越重要，特别是在服务器和企业级应用中。ACPI系统使用 RHCT (RISC-V Hart Capabilities Table)**来描述处理器能力，而不是Device Tree。

### 解决方案
这个patch实现了对ACPI系统的支持，通过以下方式：
 1. 双路径支持
```
if (acpi_disabled) {
    // DT路径：保持原有逻辑
    for_each_of_cpu_node(node) {
        cbo_get_block_size(node, "riscv,
        cbom-block-size", 
                           &cbom_block_size, &
                           cbom_hartid);
        cbo_get_block_size(node, "riscv,
        cboz-block-size", 
                           &cboz_block_size, &
                           cboz_hartid);
    }
} else {
    // ACPI路径：新增逻辑
    status = acpi_get_table(ACPI_SIG_RHCT, 0, &rhct);
    if (ACPI_FAILURE(status))
        return;
    acpi_get_cbo_block_size(rhct, &cbom_block_size, &
    cboz_block_size, NULL);
    acpi_put_table((struct acpi_table_header *)rhct);
}
``` 2. RHCT表解析
新增的 `acpi_get_cbo_block_size` 函数能够：

- 遍历RHCT表中的所有Hart Info节点
- 查找CMO (Cache Management Operation)节点
- 提取CBOM、CBOZ、CBOP的块大小信息
- 验证所有hart的块大小一致性
### Patch系列背景
这个commit是一个更大patch系列的一部分：

1. 1.
   e8065df5b0c4 : "RISC-V: ACPI: Enhance acpi_os_ioremap with MMIO remapping" - 增强ACPI内存映射支持
2. 2.
   a06835227280 : "RISC-V: ACPI: Update the return value of acpi_get_rhct()" - 更新RHCT获取函数
3. 3.
   9ca87564190c : "RISC-V: ACPI: RHCT: Add function to get CBO block sizes" - 添加CBO块大小获取函数
4. 4.
   2960f371f165 : "RISC-V: cacheflush: Initialize CBO variables on ACPI systems" - 本patch，集成CBO初始化
### 技术意义 1. 生态完善
- 使RISC-V能够在ACPI环境中正确运行
- 支持企业级和服务器应用场景
- 与ARM64的ACPI支持保持一致 2. 向后兼容
- 保持对Device Tree系统的完全支持
- 运行时自动检测使用哪种配置方式
- 不影响现有系统 3. 标准化
- 遵循ACPI规范中的RHCT表定义
- 使用标准的ACPI接口和数据结构
- 为未来的ACPI功能扩展奠定基础
### 实际影响
这个patch解决了RISC-V在ACPI系统上的一个关键缺失功能，使得：

- 缓存操作能够使用正确的块大小
- 系统性能得到优化
- RISC-V能够在更广泛的硬件平台上部署
- 为RISC-V进入数据中心和云计算领域铺平道路
这个实现展现了RISC-V社区在企业级功能支持方面的持续投入，是RISC-V生态走向成熟的重要里程碑。