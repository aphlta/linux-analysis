# RISC-V内存热插拔vmemmap释放修复补丁分析

## 基本信息

**Commit ID:** 21f1b85c8912  
**作者:** Björn Töpel <bjorn@rivosinc.com>  
**审核者:** Alexandre Ghiti <alexghiti@rivosinc.com>  
**提交日期:** 2024年11月20日  
**标题:** riscv: mm: avoid calling the pmd dtor when vmemmap_free()

## 问题背景

### 触发的错误

在RISC-V架构上进行内存热插拔操作时，系统出现了内核崩溃：

```
kernel BUG at include/linux/mm.h:3110!
Oops: Invalid instruction [#1]
CPU: 0 UID: 0 PID: 154 Comm: kworker/u2:2 Not tainted 6.12.0-rc5+ #19
Hardware name: riscv-virtio,qemu (DT)
Workqueue: kacpi_hotplug acpi_hotplug_work_fn
Call Trace:
[<ffffffff8000c5b8>] walk_pmd_range+0x1c6/0x1ee
[<ffffffff8000c720>] walk_pud_range+0x140/0x1b2
[<ffffffff8000c8a4>] walk_p4d_range+0x112/0x134
[<ffffffff8000c95c>] walk_pgd_range+0x96/0xc8
[<ffffffff8000ca84>] __walk_page_range+0xf6/0x128
[<ffffffff8000caf8>] walk_page_range+0x42/0x6a
[<ffffffff8000d5a6>] remove_pte_mapping+0x0/0x1c
[<ffffffff8000d5c2>] remove_pmd_mapping+0x0/0x1c
[<ffffffff8000d5de>] remove_pud_mapping+0x0/0x1c
[<ffffffff8000d5fa>] remove_p4d_mapping+0x0/0x1c
[<ffffffff8000d616>] remove_pgd_mapping+0x0/0x1c
[<ffffffff8000d632>] vmemmap_free+0x0/0x1c
[<ffffffff8000d64e>] section_deactivate+0x0/0x1c
[<ffffffff8000d66a>] __remove_pages+0x0/0x1c
[<ffffffff8000d686>] arch_remove_memory+0x0/0x1c
[<ffffffff8000d6a2>] try_remove_memory+0x0/0x1c
[<ffffffff8000d6be>] __remove_memory+0x0/0x1c
[<ffffffff8000d6da>] acpi_memory_remove_memory+0x0/0x1c
[<ffffffff8000d6f6>] acpi_memory_device_remove+0x0/0x1c
[<ffffffff8000d712>] acpi_bus_trim+0x0/0x1c
[<ffffffff8000d72e>] acpi_device_hotplug+0x0/0x1c
[<ffffffff8000d74a>] acpi_hotplug_work_fn+0x0/0x1c
[<ffffffff8000d766>] process_one_work+0x0/0x1c
[<ffffffff8000d782>] worker_thread+0x0/0x1c
[<ffffffff8000d79e>] kthread+0x0/0x1c
[<ffffffff8000d7ba>] ret_from_fork+0x0/0x1c
```

### 根本原因

错误发生在`include/linux/mm.h:3110`，这是`pagetable_dtor()`函数中的一个BUG_ON检查。问题的根源在于：

1. **vmemmap页表管理特殊性**：vmemmap区域用于存储struct page结构体的虚拟内存映射，它有特殊的内存管理需求
2. **页表析构函数调用时机错误**：在vmemmap_free()过程中，不应该调用pagetable_pmd_dtor()函数
3. **内存热插拔流程冲突**：内存热插拔操作中的页表清理与vmemmap的特殊要求产生了冲突

## 修改内容详细分析

### 1. 函数签名修改

**修改前：**
```c
static void __meminit free_pmd_table(pmd_t *pmd_start, pud_t *pud)
```

**修改后：**
```c
static void __meminit free_pmd_table(pmd_t *pmd_start, pud_t *pud, bool is_vmemmap)
```

**技术要点：**
- 添加了`is_vmemmap`布尔参数，用于标识当前操作是否针对vmemmap区域
- 这个参数将决定是否需要调用页表析构函数

### 2. 核心逻辑修改

**修改前：**
```c
pagetable_pmd_dtor(ptdesc);
if (PageReserved(page))
    free_reserved_page(page);
else
    pagetable_free(ptdesc);
```

**修改后：**
```c
if (!is_vmemmap)
    pagetable_pmd_dtor(ptdesc);
if (PageReserved(page))
    free_reserved_page(page);
else
    pagetable_free(ptdesc);
```

**技术要点：**
- 只有在非vmemmap操作时才调用`pagetable_pmd_dtor(ptdesc)`
- 保持了其他内存释放逻辑不变

### 3. 调用点更新

**修改位置：**
```c
if (pgtable_l4_enabled)
    free_pmd_table(pmd_base, pudp, is_vmemmap);
```

**技术要点：**
- 在`remove_pud_mapping()`函数中，将`is_vmemmap`参数传递给`free_pmd_table()`
- 确保vmemmap标识能够正确传播到页表释放函数

## 技术原理深度分析

### 1. vmemmap内存管理机制

**vmemmap的作用：**
- vmemmap是一个虚拟内存区域，用于存储所有物理页面对应的`struct page`结构体
- 它提供了从物理页面号到`struct page`结构体的直接映射
- 在64位系统中，vmemmap通常位于内核虚拟地址空间的固定区域

**vmemmap的特殊性：**
- vmemmap区域的页表不需要常规的页表锁机制
- 它的生命周期与物理内存的热插拔操作紧密相关
- vmemmap页表的释放需要特殊处理，避免与常规页表管理冲突

### 2. pagetable_pmd_dtor()函数分析

**函数功能：**
```c
static inline void pagetable_dtor(struct ptdesc *ptdesc)
{
    struct folio *folio = ptdesc_folio(ptdesc);
    
    ptlock_free(ptdesc);              // 释放页表锁
    __folio_clear_pgtable(folio);     // 清除页表标志
    lruvec_stat_sub_folio(folio, NR_PAGETABLE);  // 更新统计信息
}
```

**为什么vmemmap不能调用：**
1. **锁机制冲突**：vmemmap页表不使用常规的页表锁机制
2. **统计信息错误**：vmemmap页表不应该计入常规页表统计
3. **生命周期管理**：vmemmap页表有特殊的生命周期管理需求

### 3. 内存热插拔流程

**热插拔移除流程：**
1. `arch_remove_memory()` - 架构特定的内存移除
2. `remove_linear_mapping()` - 移除线性映射
3. `vmemmap_free()` - 释放vmemmap映射
4. `remove_pgd_mapping()` - 移除页表映射
5. `remove_pud_mapping()` - 移除PUD级别映射
6. `free_pmd_table()` - 释放PMD页表

**问题发生点：**
- 在步骤6中，原代码无条件调用`pagetable_pmd_dtor()`
- 当处理vmemmap区域时，这个调用导致了内核崩溃

## 相关提交分析

### 引入问题的提交

**Commit:** c75a74f4ba19 ("riscv: mm: Add memory hotplugging support")  
**影响：**
- 这个提交为RISC-V架构添加了内存热插拔支持
- 引入了页表管理代码，但没有正确处理vmemmap的特殊情况
- 导致了在vmemmap释放时调用不当的析构函数

### 修复策略

**设计思路：**
1. **参数传递**：通过`is_vmemmap`参数区分不同的操作类型
2. **条件执行**：只在非vmemmap操作时调用页表析构函数
3. **向下兼容**：保持其他内存管理逻辑不变

**优势：**
- 最小化修改范围，降低引入新问题的风险
- 清晰地区分了vmemmap和常规内存的处理逻辑
- 保持了代码的可读性和可维护性

## 影响范围评估

### 1. 功能影响

**修复的问题：**
- 解决了RISC-V架构上内存热插拔操作导致的内核崩溃
- 修复了vmemmap区域页表释放时的错误处理
- 提高了系统在内存热插拔场景下的稳定性

**不受影响的功能：**
- 常规内存分配和释放
- 非vmemmap区域的页表管理
- 其他架构的内存热插拔功能

### 2. 性能影响

**性能开销：**
- 添加了一个布尔参数检查，开销极小
- 不影响热路径性能
- 内存热插拔本身就是低频操作

### 3. 安全性影响

**安全性提升：**
- 避免了内核崩溃，提高了系统稳定性
- 正确的页表管理减少了内存泄漏风险
- 符合内核内存管理的最佳实践

## 测试验证

### 1. 测试场景

**基本测试：**
- RISC-V虚拟机环境下的内存热插拔操作
- ACPI内存设备的动态添加和移除
- 大内存配置下的压力测试

**回归测试：**
- 常规内存分配和释放功能
- 其他架构的内存热插拔功能
- 系统启动和关闭流程

### 2. 验证方法

**功能验证：**
```bash
# 模拟内存热插拔操作
echo offline > /sys/devices/system/memory/memory[X]/state
echo online > /sys/devices/system/memory/memory[X]/state
```

**稳定性验证：**
- 长时间运行内存热插拔操作
- 并发进行内存分配和热插拔操作
- 监控内核日志确认无崩溃

## 总结

这个补丁通过添加`is_vmemmap`参数来区分vmemmap和常规内存操作，避免在vmemmap释放时调用不当的页表析构函数。修复方案简洁有效，最小化了对现有代码的影响，同时解决了RISC-V架构上内存热插拔的关键问题。

**关键技术点：**
1. 正确理解vmemmap的特殊内存管理需求
2. 通过参数传递实现条件执行逻辑
3. 保持代码的向下兼容性和可维护性

**修复效果：**
- 彻底解决了内存热插拔导致的内核崩溃问题
- 提高了RISC-V架构的内存管理稳定性
- 为后续的内存热插拔功能优化奠定了基础