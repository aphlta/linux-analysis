# RISC-V Misaligned Access Handler Revert Patch 分析

## Commit 信息

**Commit ID**: bddf96e617f2  
**作者**: Nam Cao <namcao@linutronix.de>  
**日期**: Fri Jun 20 13:09:39 2025 +0200  
**标题**: Revert "riscv: misaligned: fix sleeping function called during misaligned access handling"  

## 修改内容概述

这个patch是一个revert操作，撤销了之前的commit 61a74ad25462 ("riscv: misaligned: fix sleeping function called during misaligned access handling")。该revert将misaligned access处理中的`copy_from_user_nofault()`和`copy_to_user_nofault()`函数调用恢复为原来的`copy_from_user()`和`copy_to_user()`。

### 具体代码修改

**文件**: `arch/riscv/kernel/traps_misaligned.c`

#### 修改1: handle_scalar_misaligned_load函数
```diff
 val.data_u64 = 0;
 if (user_mode(regs)) {
-    if (copy_from_user_nofault(&val, (u8 __user *)addr, len))
+    if (copy_from_user(&val, (u8 __user *)addr, len))
         return -1;
 } else {
     memcpy(&val, (u8 *)addr, len);
```

#### 修改2: handle_scalar_misaligned_store函数
```diff
 if (user_mode(regs)) {
-    if (copy_to_user_nofault((u8 __user *)addr, &val, len))
+    if (copy_to_user((u8 __user *)addr, &val, len))
         return -1;
 } else {
     memcpy((u8 *)addr, &val, len);
```

## 原始Patch背景分析

### 被Revert的Commit (61a74ad25462)

**作者**: Zong Li <zong.li@sifive.com>, Nylon Chen <nylon.chen@sifive.com>  
**日期**: Fri Apr 11 15:38:50 2025 +0800  
**目的**: 修复在misaligned access处理过程中调用可能睡眠函数的问题

#### 原始问题描述

原始commit试图解决以下问题：
```
BUG: sleeping function called from invalid context at include/linux/uaccess.h:224
in_atomic(): 1, irqs_disabled(): 1, non_block: 0, pid: 379, name: unalign
preempt_count: 1, expected: 0
RCU nest depth: 0, expected: 0
3 locks held by unalign/379:
 #0: ffff8f80006ac0a8 (&mm->mmap_lock){++++}-{3:3}, at: do_user_addr_fault+0x12a/0x6da
 #1: ffffffff82014cf8 (rcu_read_lock){....}-{1:2}, at: __get_user_pages+0x5c/0x903
 #2: ffffffff82a2cae0 (console_lock){+.+.}-{0:0}, at: vprintk_emit+0x100/0x2d7

Call Trace:
 [<ffffffff800160ea>] dump_backtrace+0x1c/0x24
 [<ffffffff80002304>] show_stack+0x28/0x34
 [<ffffffff80010fae>] dump_stack_lvl+0x4a/0x68
 [<ffffffff80010fe0>] dump_stack+0x14/0x1c
 [<ffffffff8004e44e>] __might_resched+0xfa/0x104
 [<ffffffff8004e496>] __might_sleep+0x3e/0x62
 [<ffffffff801963c4>] __might_fault+0x1c/0x24
 [<ffffffff80425352>] _copy_from_user+0x28/0xaa
 [<ffffffff8000296c>] handle_misaligned_store+0x204/0x254
 [<ffffffff809eae82>] do_trap_store_misaligned+0x24/0xee
 [<ffffffff809f4f1a>] handle_exception+0x146/0x152
```

#### 原始修复方案的问题

原始commit使用`copy_from_user_nofault()`和`copy_to_user_nofault()`来避免在atomic context中调用可能睡眠的函数。然而，这个修复方案存在严重缺陷：

1. **无法处理页面错误**: `nofault`版本的函数无法处理用户内存被换出(paged out)的情况
2. **功能降级**: 这会导致对于被换出的用户内存的misaligned access处理失败
3. **不符合预期行为**: 用户期望即使在内存被换出的情况下，misaligned access也应该被正确处理

## 正确的修复方案

### Commit 453805f0a28f的正确修复

**作者**: Clément Léger <cleger@rivosinc.com>  
**标题**: "riscv: misaligned: enable IRQs while handling misaligned accesses"  

正确的修复方案是在处理来自用户空间的misaligned access时重新启用中断：

```c
if (user_mode(regs)) {
    irqentry_enter_from_user_mode(regs);
    local_irq_enable();  // 重新启用中断
} else {
    state = irqentry_nmi_enter(regs);
}

// 处理misaligned access

if (user_mode(regs)) {
    local_irq_disable(); // 处理完成后禁用中断
    irqentry_exit_to_user_mode(regs);
} else {
    irqentry_nmi_exit(regs, state);
}
```

## 技术原理分析

### copy_from_user vs copy_from_user_nofault

#### copy_from_user()
- **功能**: 从用户空间复制数据到内核空间
- **页面错误处理**: 可以处理页面错误，触发页面换入
- **睡眠行为**: 在页面错误处理过程中可能睡眠
- **适用场景**: 正常的进程上下文，中断已启用

#### copy_from_user_nofault()
- **功能**: 从用户空间复制数据，但不处理页面错误
- **页面错误处理**: 遇到页面错误直接返回失败
- **睡眠行为**: 不会睡眠
- **适用场景**: atomic context或中断禁用的情况

### Misaligned Access处理流程

1. **异常触发**: CPU遇到misaligned memory access
2. **异常处理**: 进入异常处理程序，中断被禁用
3. **用户模式检查**: 检查异常是否来自用户空间
4. **内存访问**: 需要访问用户内存来完成misaligned access
5. **页面错误可能性**: 用户内存可能被换出，需要页面错误处理

### 问题根源

原始的misaligned access处理在中断禁用的状态下尝试访问用户内存，这可能导致：
- 页面错误处理需要睡眠
- 在atomic context中调用睡眠函数
- 触发"sleeping function called from invalid context"警告

## 修复策略对比

### 错误策略 (被revert的方案)
- **方法**: 使用`nofault`版本的内存复制函数
- **优点**: 避免在atomic context中睡眠
- **缺点**: 无法处理被换出的用户内存，功能不完整
- **结果**: 用户体验降级，某些合法的misaligned access会失败

### 正确策略 (453805f0a28f)
- **方法**: 在处理用户空间misaligned access时重新启用中断
- **优点**: 保持完整功能，可以处理所有情况
- **缺点**: 需要更仔细的中断状态管理
- **结果**: 既解决了睡眠问题，又保持了功能完整性

## 相关提交历史

### 问题演进时间线

1. **b686ecdeacf6**: "riscv: misaligned: Restrict user access to kernel memory"
   - 引入了用户内存访问限制

2. **441381506ba7**: "riscv: misaligned: remove CONFIG_RISCV_M_MODE specific code"
   - 移除了M-mode特定代码

3. **61a74ad25462**: "riscv: misaligned: fix sleeping function called during misaligned access handling"
   - 错误的修复方案，使用nofault函数

4. **453805f0a28f**: "riscv: misaligned: enable IRQs while handling misaligned accesses"
   - 正确的修复方案，重新启用中断

5. **bddf96e617f2**: 当前分析的commit
   - Revert错误的修复方案

## 影响分析

### 功能影响
- **恢复完整功能**: 重新支持对被换出用户内存的misaligned access处理
- **提高可靠性**: 避免因内存换出导致的misaligned access处理失败
- **用户体验**: 用户程序的misaligned access行为更加一致和可预期

### 性能影响
- **轻微性能开销**: 页面错误处理可能带来额外开销
- **整体性能提升**: 避免了因处理失败导致的程序异常终止

### 安全影响
- **无安全风险**: 修复不涉及安全相关的更改
- **稳定性提升**: 减少了因内存管理问题导致的系统不稳定

## 测试和验证

### 测试场景
1. **正常内存访问**: 验证常规misaligned access处理
2. **换出内存访问**: 验证对被换出内存的misaligned access处理
3. **高内存压力**: 在内存压力下测试misaligned access处理
4. **并发访问**: 多线程环境下的misaligned access处理

### 验证方法
- 运行包含misaligned access的测试程序
- 在内存压力下重现原始问题场景
- 确认不再出现"sleeping function called from invalid context"警告
- 验证所有misaligned access都能正确处理

## 总结

这个revert patch撤销了一个不完整的修复方案，该方案虽然解决了在atomic context中睡眠的问题，但引入了更严重的功能缺陷。通过revert这个错误的修复，并依赖于commit 453805f0a28f提供的正确解决方案，RISC-V的misaligned access处理机制得以恢复完整功能。

这个案例很好地说明了在内核开发中，修复一个问题时不能仅仅关注表面现象，而需要深入理解问题的根本原因，选择既能解决问题又不引入新问题的方案。正确的解决方案是通过重新启用中断来允许页面错误处理，而不是通过避免页面错误来规避问题。

## 相关人员

**Nam Cao** <namcao@linutronix.de> - Linutronix  
提交了这个revert patch，认识到原始修复方案的问题

**Clément Léger** <cleger@rivosinc.com> - Rivos Inc.  
提供了正确的修复方案 (453805f0a28f)

**Alexandre Ghiti** <alexghiti@rivosinc.com> - Rivos Inc.  
Review了相关的修复方案

**Zong Li** <zong.li@sifive.com> - SiFive  
**Nylon Chen** <nylon.chen@sifive.com> - SiFive  
提交了被revert的原始修复方案

**Palmer Dabbelt** <palmer@dabbelt.com>  
RISC-V维护者，处理了相关的patch

**Greg Kroah-Hartman** <gregkh@linuxfoundation.org>  
稳定版本维护者，将修复合并到稳定分支