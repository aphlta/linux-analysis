# RISC-V Tagged Address ABI Support Patch Analysis

## Commit Information
- **Commit ID**: 2e1743085887ba3f553c2bb472a75a3ff744b242
- **Author**: Samuel Holland <samuel.holland@sifive.com>
- **Date**: Wed Oct 16 13:27:46 2024 -0700
- **Committer**: Palmer Dabbelt <palmer@rivosinc.com>
- **Commit Date**: Thu Oct 24 14:12:56 2024 -0700
- **Subject**: riscv: Add support for the tagged address ABI

## Patch Overview

本补丁为RISC-V架构添加了tagged address ABI（标记地址应用程序二进制接口）支持，这是基于pointer masking（指针掩码）功能的重要特性。该功能允许内核接受带有标记的指针作为系统调用参数，为内存安全和tagged address ABI提供支持。

## 修改的文件

1. **Documentation/arch/riscv/uabi.rst** - 用户空间ABI文档更新
2. **arch/riscv/include/asm/mmu.h** - MMU上下文结构定义
3. **arch/riscv/include/asm/mmu_context.h** - MMU上下文管理
4. **arch/riscv/include/asm/uaccess.h** - 用户空间访问接口
5. **arch/riscv/kernel/process.c** - 进程管理和tagged address控制

## 详细代码修改分析

### 1. Documentation/arch/riscv/uabi.rst

```diff
+Additionally, when pointer masking is enabled (``PR_PMLEN`` is greater than 0),
+a tagged address ABI is supported, with the same interface and behavior as
+documented for AArch64 (Documentation/arch/arm64/tagged-address-abi.rst).
```

**修改原理**: 更新文档说明当pointer masking启用时（PR_PMLEN > 0），支持tagged address ABI，其接口和行为与AArch64的实现保持一致。

### 2. arch/riscv/include/asm/mmu.h

```diff
+       unsigned long flags;
+#ifdef CONFIG_RISCV_ISA_SUPM
+       u8 pmlen;
+#endif
 } mm_context_t;
 
+/* Lock the pointer masking mode because this mm is multithreaded */
+#define MM_CONTEXT_LOCK_PMLEN  0
```

**修改原理**: 
- 在mm_context_t结构中添加flags字段用于状态管理
- 添加pmlen字段存储pointer masking长度配置
- 定义MM_CONTEXT_LOCK_PMLEN标志位，用于锁定多线程mm的pointer masking模式

### 3. arch/riscv/include/asm/mmu_context.h

```diff
+#ifdef CONFIG_RISCV_ISA_SUPM
+       next->context.pmlen = 0;
+       clear_bit(MM_CONTEXT_LOCK_PMLEN, &next->context.flags);
+#endif
```

**修改原理**: 在activate_mm函数中重置新mm的pmlen和锁定标志，确保新的内存管理上下文从干净状态开始。

### 4. arch/riscv/include/asm/uaccess.h

```diff
+#ifdef CONFIG_RISCV_ISA_SUPM
+unsigned long untagged_addr(unsigned long addr);
+unsigned long untagged_addr_remote(struct mm_struct *mm, unsigned long addr);
+#define untagged_addr(addr)            untagged_addr(addr)
+#define untagged_addr_remote(mm, addr) untagged_addr_remote(mm, addr)
+#endif
```

**修改原理**: 
- 声明untagged_addr和untagged_addr_remote函数
- 这些函数用于在用户空间访问时移除指针的标记位
- untagged_addr_remote用于处理远程mm的地址解标记

### 5. arch/riscv/kernel/process.c - 主要修改

#### 5.1 添加全局控制变量
```diff
+/*
+ * Control the relaxed ABI allowing tagged user addresses into the kernel.
+ */
+static unsigned int tagged_addr_disabled;
```

#### 5.2 copy_thread函数修改
```diff
+       /* Ensure all threads in this mm have the same pointer masking mode. */
+       if (IS_ENABLED(CONFIG_RISCV_ISA_SUPM) && p->mm && (clone_flags & CLONE_VM))
+               set_bit(MM_CONTEXT_LOCK_PMLEN, &p->mm->context.flags);
```

**修改原理**: 在线程创建时，如果是共享虚拟内存的线程（CLONE_VM），则锁定pointer masking模式，确保同一mm下的所有线程使用相同的pointer masking配置。

#### 5.3 set_tagged_addr_ctrl函数重大修改

```diff
-       unsigned long valid_mask = PR_PMLEN_MASK;
+       unsigned long valid_mask = PR_PMLEN_MASK | PR_TAGGED_ADDR_ENABLE;
        struct thread_info *ti = task_thread_info(task);
+       struct mm_struct *mm = task->mm;
```

**修改原理**: 
- 扩展有效掩码，支持PR_TAGGED_ADDR_ENABLE标志
- 添加mm指针用于后续的mm上下文操作

```diff
+       /*
+        * Do not allow the enabling of the tagged address ABI if globally
+        * disabled via sysctl abi.tagged_addr_disabled.
+        */
+       if ((arg & PR_TAGGED_ADDR_ENABLE) && tagged_addr_disabled)
+               return -EINVAL;
+
+       /*
+        * If this mm is multithreaded, do not allow changing the pointer
+        * masking mode as that would make the tagged address ABI inconsistent
+        * between threads sharing the same address space.
+        */
+       if (test_bit(MM_CONTEXT_LOCK_PMLEN, &mm->context.flags) &&
+           mm->context.pmlen != pmlen)
+               return -EINVAL;
```

**修改原理**: 
- 检查全局sysctl控制，如果tagged_addr_disabled为真，则禁止启用tagged address ABI
- 检查多线程锁定状态，如果mm已被锁定且要设置的pmlen与当前不同，则拒绝修改

```diff
+       if (arg & PR_TAGGED_ADDR_ENABLE) {
+               mm->context.pmlen = pmlen;
+               set_bit(MM_CONTEXT_LOCK_PMLEN, &mm->context.flags);
+       } else {
+               mm->context.pmlen = 0;
+       }
```

**修改原理**: 
- 如果启用tagged address ABI，则设置mm的pmlen并锁定
- 如果禁用，则清零pmlen

#### 5.4 get_tagged_addr_ctrl函数修改

```diff
+       /*
+        * The mm context's pmlen is set only when the tagged address ABI is
+        * enabled, so the effective PMLEN must be extracted from envcfg.PMM.
+        */
+       if (task->mm->context.pmlen)
+               ret |= PR_TAGGED_ADDR_ENABLE;
```

**修改原理**: 在获取tagged address控制信息时，检查mm的pmlen，如果非零则设置PR_TAGGED_ADDR_ENABLE标志。

#### 5.5 添加sysctl支持

```diff
+/*
+ * Global sysctl to disable the tagged user addresses support. This control
+ * only prevents the tagged address ABI enabling via prctl() and does not
+ * disable it for tasks that already opted in to the relaxed ABI.
+ */
+
+static struct ctl_table tagged_addr_sysctl_table[] = {
+       {
+               .procname       = "tagged_addr_disabled",
+               .mode           = 0644,
+               .data           = &tagged_addr_disabled,
+               .maxlen         = sizeof(int),
+               .proc_handler   = proc_dointvec_minmax,
+               .extra1         = SYSCTL_ZERO,
+               .extra2         = SYSCTL_ONE,
+       },
+};
```

**修改原理**: 添加sysctl接口 `/proc/sys/abi/tagged_addr_disabled`，允许系统管理员全局禁用tagged address ABI的启用。

```diff
+       if (!register_sysctl("abi", tagged_addr_sysctl_table))
+               return -EINVAL;
```

**修改原理**: 在tagged_addr_init函数中注册sysctl表。

## 技术原理深度分析

### 1. Pointer Masking机制

Pointer masking是RISC-V的一个ISA扩展，允许在指针的高位存储额外的元数据（标记），而不影响实际的内存访问。硬件在进行内存访问时会自动屏蔽这些标记位。

### 2. Tagged Address ABI

Tagged Address ABI允许用户空间程序使用带标记的指针调用系统调用，内核需要在处理这些指针之前移除标记位。这为以下应用场景提供支持：
- 内存安全检查
- 垃圾回收器的对象标记
- 调试和分析工具

### 3. 多线程一致性保证

本patch的一个重要设计是确保同一地址空间内的所有线程使用相同的pointer masking配置：
- 使用MM_CONTEXT_LOCK_PMLEN标志锁定配置
- 在copy_thread时自动锁定共享VM的线程
- 在set_tagged_addr_ctrl中检查锁定状态

### 4. 软件解标记的必要性

Commit message中提到："The uaccess routines must perform untagging in software because U-mode and S-mode have entirely separate pointer masking configurations."

这是因为：
- 用户模式（U-mode）和监管者模式（S-mode）有完全独立的pointer masking配置
- 硬件可能不为S-mode实现pointer masking
- 因此内核必须在软件中进行解标记操作

## 相关提交分析

从git历史可以看出，这个commit是一个完整的pointer masking支持系列的一部分：

1. **8727163a1ae3**: dt-bindings: riscv: Add pointer masking ISA extensions
2. **2e6f6ea452aa**: riscv: Add ISA extension parsing for pointer masking  
3. **29eedc7d1587**: riscv: Add CSR definitions for pointer masking
4. **09d6775f503b**: riscv: Add support for userspace pointer masking
5. **2e1743085887**: riscv: Add support for the tagged address ABI (本commit)

这个系列从底层的ISA扩展解析、CSR定义，到用户空间pointer masking支持，最后到tagged address ABI，形成了完整的功能链条。

## 安全性考虑

1. **全局控制**: 通过sysctl提供全局禁用机制，系统管理员可以在安全敏感环境中禁用此功能
2. **多线程一致性**: 防止同一地址空间内的线程使用不同的pointer masking配置，避免安全漏洞
3. **向后兼容**: 默认情况下功能是禁用的，需要显式启用

## 性能影响

1. **软件解标记开销**: 每次用户空间访问都需要软件解标记，会有一定性能开销
2. **配置检查**: 在设置pointer masking时需要进行多项检查，但这是一次性开销
3. **内存开销**: mm_context_t结构增加了少量字段

## 总结

这个patch为RISC-V架构提供了完整的tagged address ABI支持，是一个设计良好的功能实现：
- 提供了完整的用户空间接口
- 确保了多线程环境下的一致性
- 包含了必要的安全控制机制
- 与现有的AArch64实现保持接口兼容

该功能为RISC-V生态系统中的内存安全工具、垃圾回收器和调试工具提供了重要的基础设施支持。