# RISC-V ARCH_USE_CMPXCHG_LOCKREF 补丁分析

## 基本信息

**Commit ID:** eb1e5037294652ddf1437f62292c0727183f11ae  
**作者:** Jisheng Zhang <jszhang@kernel.org>  
**提交日期:** 2024年3月25日  
**标题:** riscv: select ARCH_USE_CMPXCHG_LOCKREF  

## 补丁概述

这个补丁为RISC-V架构启用了基于cmpxchg的无锁lockref实现，通过在RISC-V的Kconfig中选择`ARCH_USE_CMPXCHG_LOCKREF`配置选项来实现。

## 代码修改详细分析

### 修改的文件
- `arch/riscv/Kconfig`

### 具体修改内容
```diff
@@ -50,6 +50,7 @@ config RISCV
        select ARCH_SUPPORTS_PAGE_TABLE_CHECK if MMU
        select ARCH_SUPPORTS_PER_VMA_LOCK if MMU
        select ARCH_SUPPORTS_SHADOW_CALL_STACK if HAVE_SHADOW_CALL_STACK
+       select ARCH_USE_CMPXCHG_LOCKREF if 64BIT
        select ARCH_USE_MEMTEST
        select ARCH_USE_QUEUED_RWLOCKS
        select ARCH_USES_CFI_TRAPS if CFI_CLANG
```

**关键点:**
- 仅在64位RISC-V系统上启用此功能 (`if 64BIT`)
- 添加到现有的架构特性选择列表中

## 技术原理分析

### lockref机制概述

lockref是Linux内核中的一种锁定引用计数机制，它将自旋锁和引用计数原子性地组合在一起。传统实现需要获取自旋锁来修改引用计数，而cmpxchg-based实现可以在某些情况下避免锁的开销。

### ARCH_USE_CMPXCHG_LOCKREF的工作原理

当启用`ARCH_USE_CMPXCHG_LOCKREF`时，lockref操作会尝试使用compare-and-swap (cmpxchg)指令来原子性地更新锁和计数的组合值，而不是获取自旋锁。

#### 关键数据结构
```c
struct lockref {
    union {
#if USE_CMPXCHG_LOCKREF
        aligned_u64 lock_count;  // 8字节对齐的组合值
#endif
        struct {
            spinlock_t lock;     // 自旋锁
            int count;           // 引用计数
        };
    };
};
```

#### 启用条件
```c
#define USE_CMPXCHG_LOCKREF \
    (IS_ENABLED(CONFIG_ARCH_USE_CMPXCHG_LOCKREF) && \
     IS_ENABLED(CONFIG_SMP) && SPINLOCK_SIZE <= 4)
```

需要满足三个条件：
1. 架构支持ARCH_USE_CMPXCHG_LOCKREF
2. 启用SMP支持
3. 自旋锁大小不超过4字节

### CMPXCHG_LOOP宏的实现

核心实现使用CMPXCHG_LOOP宏：

```c
#define CMPXCHG_LOOP(CODE, SUCCESS) do {                    \
    int retry = 100;                                        \
    struct lockref old;                                     \
    BUILD_BUG_ON(sizeof(old) != 8);                        \
    old.lock_count = READ_ONCE(lockref->lock_count);       \
    while (likely(arch_spin_value_unlocked(old.lock.rlock.raw_lock))) { \
        struct lockref new = old;                           \
        CODE                                                \
        if (likely(try_cmpxchg64_relaxed(&lockref->lock_count, \
                                         &old.lock_count,   \
                                         new.lock_count))) { \
            SUCCESS;                                        \
        }                                                   \
        if (!--retry)                                       \
            break;                                          \
    }                                                       \
} while (0)
```

**工作流程:**
1. 读取当前的lock_count值
2. 检查锁是否未被持有
3. 如果锁空闲，尝试使用cmpxchg原子性地更新
4. 如果cmpxchg成功，操作完成
5. 如果失败，重试最多100次
6. 如果锁被持有或重试次数耗尽，回退到传统的锁机制

## 相关提交分析

这个补丁是一个补丁系列的一部分：

### 前置补丁: 79d6e4eae966
**标题:** "riscv: cmpxchg: implement arch_cmpxchg64_{relaxed|acquire|release}"

这个补丁实现了RISC-V架构所需的64位cmpxchg变体：
- `arch_cmpxchg64_relaxed()` - 无内存排序约束
- `arch_cmpxchg64_acquire()` - 获取语义
- `arch_cmpxchg64_release()` - 释放语义

这些函数是lockref cmpxchg实现的基础，因为lockref需要64位的原子操作来同时操作锁和计数。

### 补丁系列背景
根据提交信息，这是"enable lockless lockref implementation"系列的一部分，旨在为RISC-V启用无锁lockref实现。

## 性能影响分析

### 测试结果
根据提交信息，使用Linus的测试用例在两个平台上进行了性能测试：

- **TH1520平台:** 11.2%的性能提升
- **JH7110平台:** 12.0%的性能提升

#### 测试平台详细信息

**TH1520处理器** <mcreference link="https://www.amazon.com/LicheePi-4A-Linux-RISC-V-TH1520/dp/B0CBQ5XBN8" index="6">6</mcreference>:
- 阿里巴巴T-Head设计的四核Xuantie C910处理器
- 主频最高2.5GHz，采用12nm工艺
- 支持RV64GCV指令集(包括向量扩展)
- 集成4TOPS NPU和50GFLOP GPU
- 支持64位LPDDR4X内存，最高4266 MT/s <mcreference link="https://www.reddit.com/r/RISCV/comments/xvdabj/alibaba_thead_th1520_riscv_processor_to_power_the/" index="7">7</mcreference>

**JH7110处理器** <mcreference link="https://www.cnx-software.com/2022/08/29/starfive-jh7110-risc-v-processor-specifications/" index="8">8</mcreference>:
- StarFive设计的六核RISC-V SoC
- 四个64位主核心(最高1.5GHz) + 一个监控核心 + 一个32位实时核心
- 支持RV64GC指令集
- 集成3D GPU，支持OpenGL ES和Vulkan
- 性能水平大约相当于后期Pentium III或PowerPC G4 <mcreference link="https://www.reddit.com/r/RISCV/comments/1coxdwm/whats_the_current_performance_level_of_the_most/" index="9">9</mcreference>

### Linus测试用例背景
这个性能测试基于Linus Torvalds在2013年提出的lockref测试用例 <mcreference link="https://lore.kernel.org/linux-fsdevel/CA+55aFzKQ6Pj18TB8p4Yr0M4t+S+BsiHH=BJNmn=76-NcjTj-g@mail.gmail.com/" index="1">1</mcreference>。该测试用例是在lockref机制最初开发期间创建的，用于验证无锁引用计数实现的性能优势。lockref机制最初是为了解决文件系统中dentry引用计数的性能瓶颈而设计的 <mcreference link="https://lore.kernel.org/linux-fsdevel/CA+55aFzKQ6Pj18TB8p4Yr0M4t+S+BsiHH=BJNmn=76-NcjTj-g@mail.gmail.com/T/" index="2">2</mcreference>。

### 性能提升原理

1. **减少锁竞争:** 在无竞争情况下，避免了获取和释放自旋锁的开销
2. **原子操作优化:** 使用单个cmpxchg指令替代锁+操作+解锁的序列
3. **缓存友好:** 减少了内存屏障和缓存一致性开销
4. **可扩展性:** 在多核系统中减少了锁竞争，提高了并发性能

### RISC-V原子操作实现

RISC-V架构通过"A"扩展提供原子操作支持 <mcreference link="https://en.wikipedia.org/wiki/RISC-V" index="3">3</mcreference>。RISC-V的原子操作基于Load-Reserved/Store-Conditional (LR/SC)机制和原子读-修改-写指令 <mcreference link="https://groups.google.com/a/groups.riscv.org/g/hw-dev/c/5zldgoktMHc" index="4">4</mcreference>：

1. **LR/SC机制**: 
   - LR指令从内存地址加载数据并建立保留集(reservation set)
   - SC指令条件性地存储数据，只有在保留集未被破坏时才成功
   - 这种机制为实现cmpxchg等复杂原子操作提供了基础

2. **原子读-修改-写指令**: 
   - 直接在硬件层面实现原子操作
   - 支持acquire/release语义以确保内存顺序
   - 相比其他RISC架构，RISC-V的原子操作设计更加高效 <mcreference link="https://llvm.org/docs/Atomics.html" index="5">5</mcreference>

3. **硬件实现优势**:
   - CPU直接发送地址、数据和操作码到内存控制器
   - 避免了复杂的缓存一致性协议开销
   - 支持跨缓存行边界的原子操作(虽然有性能代价)

### 适用场景
这种优化特别适用于：
- 高频率的引用计数操作
- 多核系统中的并发访问
- 文件系统操作（如dentry引用计数）
- 网络子系统中的对象管理

## 架构特定考虑

### RISC-V特性
- **64位限制:** 只在64位RISC-V上启用，因为需要64位原子操作
- **内存模型:** RISC-V的弱内存模型使得原子操作优化更加重要
- **指令集支持:** 依赖于RISC-V的AMO（原子内存操作）指令

### 硬件要求
- 支持64位原子操作的RISC-V处理器
- 多核系统（SMP配置）
- 适当的缓存一致性协议支持

## 潜在风险和限制

### 回退机制
当cmpxchg方法失败时（如锁被持有或重试次数耗尽），系统会自动回退到传统的锁机制，确保正确性。

### 内存对齐要求
lockref结构需要8字节对齐，以确保64位原子操作的正确性。

### 调试复杂性
无锁实现可能使调试变得更加复杂，特别是在出现竞态条件时。

## 总结

这个补丁通过启用ARCH_USE_CMPXCHG_LOCKREF为RISC-V架构带来了显著的性能提升。它是一个相对简单但影响深远的改动，展示了如何通过架构特定的优化来提升系统性能。补丁的设计考虑了正确性（通过回退机制）和性能（通过无锁实现），是一个很好的架构优化示例。

关键收益：
- 在TH1520和JH7110平台上分别获得11.2%和12.0%的性能提升
- 减少了锁竞争和内存屏障开销
- 提高了多核系统的可扩展性
- 保持了代码的正确性和稳定性

这个补丁为RISC-V生态系统的性能优化奠定了基础，特别是在服务器和高性能计算应用中。

### 技术意义

1. **架构成熟度标志**: 这个patch标志着RISC-V架构在原子操作支持方面达到了与x86、ARM等成熟架构相当的水平

2. **生态系统完善**: 通过启用已有的内核优化机制，RISC-V平台能够更好地利用现有的Linux内核基础设施

3. **性能基准**: 在两个不同的RISC-V实现上都获得了10%以上的性能提升，证明了该优化的普适性

4. **未来发展**: 为RISC-V平台上更多无锁数据结构的应用奠定了基础

该优化展示了RISC-V架构在高性能计算领域的潜力，同时也证明了通过架构特定优化可以显著提升系统性能。