# Patch Analysis: b18f7296fbfd

## 基本信息

**Commit ID:** b18f7296fbfdb2ad0871f00f3042fc74663d52ac
**标题:** riscv: use ".L" local labels in assembly when applicable
**作者:** Clément Léger <cleger@rivosinc.com>
**提交日期:** 2023年10月24日
**合并日期:** 2023年11月6日
**维护者:** Palmer Dabbelt <palmer@rivosinc.com>
**邮件列表链接:** https://lore.kernel.org/r/20231024132655.730417-2-cleger@rivosinc.com

## Patch概述

这个patch的主要目的是在RISC-V架构的汇编代码中使用".L"前缀的本地标签，以提高代码的一致性并解决kprobes功能的问题。

## 修改的文件

1. `arch/riscv/kernel/entry.S` - 6行修改
2. `arch/riscv/kernel/head.S` - 18行修改
3. `arch/riscv/kernel/mcount.S` - 10行修改
4. `arch/riscv/lib/memmove.S` - 54行修改

**总计:** 4个文件，44行插入，44行删除

## 技术细节分析

### 问题背景

在汇编代码中，标签可以分为两种类型：
- **全局标签**: 在整个程序中可见，会出现在符号表中
- **本地标签**: 以".L"开头，仅在当前文件中可见，不会出现在符号表中

### 核心问题

kprobes功能在计算函数大小时，会查找下一个可见符号的位置。如果汇编代码中使用了全局标签而不是本地标签，会导致：

1. **函数大小计算错误**: kprobes认为函数在遇到第一个全局标签时就结束了
2. **kprobe应用失败**: 由于计算出的函数大小比实际要小，导致无法在指定偏移量处应用kprobe

### 修改示例

以`arch/riscv/lib/memmove.S`为例，主要修改包括：

```assembly
# 修改前
coaligned_copy_forward:
    # ... 代码 ...
    j byte_copy_forward

coaligned_copy_reverse:
    jal t0, byte_copy_until_aligned_reverse
    # ... 代码 ...

# 修改后
.Lcoaligned_copy_forward:
    # ... 代码 ...
    j .Lbyte_copy_forward

.Lcoaligned_copy_reverse:
    jal t0, .Lbyte_copy_until_aligned_reverse
    # ... 代码 ...
```

所有内部使用的标签都添加了".L"前缀，使其成为本地标签。

## 相关提交分析

这个patch是一个系列提交的一部分，相关的提交包括：

1. **76329c693924** - "riscv: Use SYM_*() assembly macros instead of deprecated ones"
   - 使用现代的SYM_*()宏替代过时的汇编宏
   - 影响17个文件，60行插入，74行删除

2. **4cc0d8a3f109** - "riscv: kernel: Use correct SYM_DATA_*() macro for data"
   - 为数据使用正确的SYM_DATA_*()宏而不是SYM_FUNC_*()
   - 影响1个文件，4行插入，5行删除

这三个提交共同构成了RISC-V汇编代码标准化的完整方案。

## 影响和意义

### 直接影响

1. **修复kprobes功能**: 解决了kprobe在RISC-V架构上的应用问题
2. **提高代码一致性**: 统一了汇编代码中标签的使用规范
3. **减少符号表污染**: 本地标签不会出现在最终的符号表中

### 长期意义

1. **调试工具兼容性**: 确保各种调试和分析工具能正确工作
2. **代码维护性**: 提高了汇编代码的可维护性和可读性
3. **架构标准化**: 为RISC-V架构建立了更好的编码标准

## 技术要点

### 汇编标签规范

- **本地标签**: 以".L"开头，如`.Lloop_start`
- **全局标签**: 直接使用名称，如`function_entry`
- **选择原则**: 仅在函数内部使用的标签应该使用本地标签

### kprobes工作原理

kprobes通过以下方式计算函数大小：
1. 找到函数的起始地址
2. 查找下一个可见符号的地址
3. 两者之差即为函数大小
4. 验证探测点偏移量是否在函数范围内

#### 详细的函数大小计算机制

kprobes在计算函数大小时，主要依赖`kallsyms_lookup_size_offset()`函数，其核心实现在`get_symbol_pos()`函数中：

```c
static unsigned long get_symbol_pos(unsigned long addr,
                                    unsigned long *symbolsize,
                                    unsigned long *offset)
{
    unsigned long symbol_start = 0, symbol_end = 0;
    unsigned long i, low, high, mid;

    /* 对排序的kallsyms_offsets数组进行二分查找 */
    low = 0;
    high = kallsyms_num_syms;

    while (high - low > 1) {
        mid = low + (high - low) / 2;
        if (kallsyms_sym_address(mid) <= addr)
            low = mid;
        else
            high = mid;
    }

    /* 查找第一个别名符号（相同地址的符号） */
    while (low && kallsyms_sym_address(low-1) == kallsyms_sym_address(low))
        --low;

    symbol_start = kallsyms_sym_address(low);

    /* 查找下一个非别名符号 */
    for (i = low + 1; i < kallsyms_num_syms; i++) {
        if (kallsyms_sym_address(i) > symbol_start) {
            symbol_end = kallsyms_sym_address(i);
            break;
        }
    }

    /* 如果没有找到下一个符号，使用段的结束地址 */
    if (!symbol_end) {
        if (is_kernel_inittext(addr))
            symbol_end = (unsigned long)_einittext;
        else if (IS_ENABLED(CONFIG_KALLSYMS_ALL))
            symbol_end = (unsigned long)_end;
        else
            symbol_end = (unsigned long)_etext;
    }

    if (symbolsize)
        *symbolsize = symbol_end - symbol_start;
    if (offset)
        *offset = addr - symbol_start;

    return low;
}
```

**关键步骤解析：**

1. **二分查找定位符号**: 在已排序的符号表中找到包含目标地址的符号
2. **处理别名符号**: 跳过相同地址的别名符号，找到真正的符号起始位置
3. **查找下一个符号**: 遍历符号表，找到地址大于当前符号的下一个符号
4. **计算符号大小**: `symbol_end - symbol_start`即为符号（函数）的大小

**问题产生的原因：**

在修复前，汇编代码中的内部标签（如`byte_copy_forward`、`coaligned_copy_reverse`等）被当作全局符号处理，这些标签会出现在符号表中。当kprobes计算函数大小时：

- 假设函数`memmove`从地址0x1000开始
- 函数内部有标签`byte_copy_forward`在地址0x1020
- kprobes计算`memmove`的大小时，会找到下一个符号`byte_copy_forward`
- 计算出的函数大小为`0x1020 - 0x1000 = 0x20`字节
- 但实际上`memmove`函数可能有0x100字节长
- 如果用户想在偏移量0x50处设置kprobe，系统会拒绝，因为0x50 > 0x20

**修复后的效果：**

使用`.L`前缀的本地标签不会出现在符号表中，kprobes能够正确计算到真正的下一个函数的地址，从而得到正确的函数大小。

#### kprobe地址解析流程

kprobes在注册时会调用`_kprobe_addr()`函数来解析和验证探测点地址：

```c
static kprobe_opcode_t *
_kprobe_addr(kprobe_opcode_t *addr, const char *symbol_name,
             unsigned long offset, bool *on_func_entry)
{
    if (symbol_name) {
        /* 根据符号名查找地址 */
        addr = kprobe_lookup_name(symbol_name, offset);
        if (!addr)
            return ERR_PTR(-ENOENT);
    }

    /* 计算最终地址：addr + offset */
    addr = (void *)addr + offset;

    /* 关键步骤：使用kallsyms_lookup_size_offset重新定位到符号起始 */
    if (!kallsyms_lookup_size_offset((unsigned long)addr, NULL, &offset))
        return ERR_PTR(-ENOENT);
    addr = (void *)addr - offset;  // 回到符号起始地址

    /* 让架构特定代码重新组合地址和偏移量 */
    addr = arch_adjust_kprobe_addr((unsigned long)addr, offset, on_func_entry);
    if (!addr)
        return ERR_PTR(-EINVAL);

    return addr;
}
```

**流程说明：**

1. **符号查找**: 如果提供了符号名，先查找符号的基地址
2. **地址计算**: 计算目标地址（基地址 + 偏移量）
3. **重新定位**: 调用`kallsyms_lookup_size_offset()`确定该地址属于哪个符号，并获取在该符号内的偏移量
4. **架构调整**: 调用`arch_adjust_kprobe_addr()`进行架构特定的地址调整

这个过程确保了kprobe能够正确识别目标地址所属的函数，并验证偏移量的有效性。如果内部标签被误认为是独立的符号，就会导致函数边界计算错误。

## 测试和验证

该patch经过了以下验证：
- **代码审查**: Andrew Jones进行了审查
- **功能测试**: 确保kprobes功能正常工作
- **回归测试**: 验证不会影响现有功能

## 总结

这是一个重要的修复patch，虽然修改看起来简单（主要是添加".L"前缀），但解决了一个影响调试和分析工具的关键问题。它体现了内核开发中对细节的重视，以及对工具链兼容性的考虑。这个修改不仅修复了当前的问题，还为未来的RISC-V汇编代码开发建立了更好的标准。