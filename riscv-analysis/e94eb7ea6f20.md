# RISC-V Patch 分析: e94eb7ea6f20

## 基本信息

**Commit ID:** e94eb7ea6f20  
**标题:** riscv: Properly export reserved regions in /proc/iomem  
**作者:** Björn Töpel <bjorn@rivosinc.com>  
**提交日期:** 2025年4月9日  
**修复的问题:** Fixes: ffe0e5261268 ("RISC-V: Improve init_resources()")  

## 问题描述

### 背景

/proc/iomem 文件代表内核的内存映射。其中标记为"Reserved"的区域告诉用户这些范围不应该被篡改。kexec-tools 在使用较旧的 kexec_load 系统调用时，依赖这些"Reserved"区域来构建内存段，这些段将成为新 kexec'd 内核的目标。

### 具体问题

RISC-V 移植试图向用户空间暴露所有保留区域，但某些区域没有被正确暴露：
- 同时存在于"常规"和保留内存块中的区域，例如 EFI Memory Map
- 缺失的条目可能导致保留内存被覆盖

### 影响

这个问题可能导致：
1. kexec 工具无法正确识别保留内存区域
2. 在 kexec 过程中保留内存可能被意外覆盖
3. 系统稳定性问题

## 代码修改分析

### 修改的文件

- `arch/riscv/kernel/setup.c` (+35 lines, -1 line)

### 主要修改内容

#### 1. 新增全局变量

```c
static int num_standard_resources;
static struct resource *standard_resources;
```

这两个变量用于跟踪标准内存资源的数量和指针。

#### 2. 修改 init_resources() 函数

在 `init_resources()` 函数中添加了以下关键修改：

```c
int num_resources = 0, res_idx = 0, non_resv_res = 0;
```

新增 `non_resv_res` 变量来计算非保留资源的数量。

```c
/* Add /memory regions to the resource tree */
for_each_mem_region(region) {
    res = &mem_res[res_idx--];
    non_resv_res++;  // 新增：计数非保留资源
    // ... 其他代码
}

num_standard_resources = non_resv_res;
standard_resources = &mem_res[res_idx + 1];
```

设置全局变量以便后续使用。

#### 3. 新增 reserve_memblock_reserved_regions() 函数

这是这个patch的核心功能：

```c
static int __init reserve_memblock_reserved_regions(void)
{
    u64 i, j;

    for (i = 0; i < num_standard_resources; i++) {
        struct resource *mem = &standard_resources[i];
        phys_addr_t r_start, r_end, mem_size = resource_size(mem);

        if (!memblock_is_region_reserved(mem->start, mem_size))
            continue;

        for_each_reserved_mem_range(j, &r_start, &r_end) {
            resource_size_t start, end;

            start = max(PFN_PHYS(PFN_DOWN(r_start)), mem->start);
            end = min(PFN_PHYS(PFN_UP(r_end)) - 1, mem->end);

            if (start > mem->end || end < mem->start)
                continue;

            reserve_region_with_split(mem, start, end, "Reserved");
        }
    }

    return 0;
}
arch_initcall(reserve_memblock_reserved_regions);
```

## 代码修改原理

### 1. 两阶段处理机制

**第一阶段 (init_resources):**
- 初始化基本的内存资源树
- 记录标准内存资源的位置和数量

**第二阶段 (reserve_memblock_reserved_regions):**
- 在系统初始化后期，通过 arch_initcall 调用
- 遍历所有标准内存资源，检查是否有保留区域重叠
- 使用 `reserve_region_with_split()` 函数分割重叠区域

### 2. 关键算法逻辑

```c
// 计算重叠区域的起始和结束地址
start = max(PFN_PHYS(PFN_DOWN(r_start)), mem->start);
end = min(PFN_PHYS(PFN_UP(r_end)) - 1, mem->end);

// 检查是否真的有重叠
if (start > mem->end || end < mem->start)
    continue;

// 分割并标记为保留
reserve_region_with_split(mem, start, end, "Reserved");
```

这个算法确保：
- 只处理真正重叠的区域
- 正确计算重叠区域的边界
- 使用页面对齐的地址

### 3. 为什么使用 arch_initcall

- `init_resources()` 在早期初始化阶段调用，此时分配器可能还不完全可用
- `arch_initcall()` 确保在系统初始化后期调用，此时有完整的分配器支持
- 这样可以安全地使用 `reserve_region_with_split()` 函数进行内存区域分割

## 相关提交分析

### 1. 修复的原始提交

**ffe0e5261268** ("RISC-V: Improve init_resources()")
- 这个提交改进了资源初始化过程
- 但引入了保留区域暴露不完整的问题

### 2. 参考的ARM64解决方案

**d91680e687f4** ("arm64: Fix /proc/iomem for reserved but not memory regions")
- ARM64遇到了类似的问题
- 提供了解决方案的参考实现

**50d7ba36b916** ("arm64: export memblock_reserve()d regions via /proc/iomem")
- ARM64的另一个相关修复
- 展示了如何正确导出保留区域

### 3. 架构间的一致性

这个patch使RISC-V与其他架构（ARM64、LoongArch）在处理保留内存区域方面保持一致，确保：
- 统一的 /proc/iomem 格式
- 一致的 kexec 行为
- 相同的内存管理语义

## 技术细节

### 1. 内存区域类型

- **System RAM**: 可用的系统内存
- **Reserved**: 保留内存，不应被用户空间访问
- **Kernel image/code/data/bss**: 内核各个段

### 2. 关键函数说明

- `memblock_is_region_reserved()`: 检查区域是否被保留
- `for_each_reserved_mem_range()`: 遍历所有保留内存范围
- `reserve_region_with_split()`: 分割并保留内存区域
- `resource_size()`: 计算资源大小

### 3. 地址对齐处理

```c
start = max(PFN_PHYS(PFN_DOWN(r_start)), mem->start);
end = min(PFN_PHYS(PFN_UP(r_end)) - 1, mem->end);
```

- `PFN_DOWN()`: 向下对齐到页面边界
- `PFN_UP()`: 向上对齐到页面边界
- `PFN_PHYS()`: 将页面号转换为物理地址

## 影响和意义

### 1. 修复的问题

- 确保所有保留内存区域在 /proc/iomem 中正确显示
- 修复 kexec 工具可能遇到的内存映射问题
- 防止保留内存被意外覆盖

### 2. 系统稳定性

- 提高 kexec 操作的可靠性
- 确保 EFI Memory Map 等关键区域得到保护
- 与其他架构保持一致的行为

### 3. 用户空间影响

- /proc/iomem 输出更加完整和准确
- kexec-tools 可以正确识别所有保留区域
- 系统管理工具获得更准确的内存映射信息

## 总结

这个patch通过引入两阶段的内存资源处理机制，解决了RISC-V架构中保留内存区域在/proc/iomem中暴露不完整的问题。通过参考ARM64的成熟解决方案，确保了架构间的一致性，提高了系统的稳定性和kexec操作的可靠性。这是一个典型的架构特定问题的修复，体现了Linux内核在不同架构间保持一致性的重要性。