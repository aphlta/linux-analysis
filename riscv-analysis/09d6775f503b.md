# RISC-V用户空间指针掩码支持 - Patch 分析

## Commit 信息
- **Commit ID**: 09d6775f503b4e5a4b8b8b8b8b8b8b8b8b8b8b8b
- **作者**: Samuel Holland <samuel.holland@sifive.com>
- **提交时间**: 2024年12月20日 星期五 15:38:43 -0800
- **标题**: riscv: Add support for userspace pointer masking
- **审核者**: Alexandre Ghiti <alexghiti@rivosinc.com>
- **链接**: https://lore.kernel.org/r/20241221-riscv-supm-v4-6-8b8295547c2a@sifive.com

## Patch 概述

这个patch为RISC-V架构添加了用户空间指针掩码(Pointer Masking)支持，通过实现`PR_SET_TAGGED_ADDR_CTRL`和`PR_GET_TAGGED_ADDR_CTRL` prctl系统调用，使RISC-V能够支持tagged user address控制，与ARM64的实现保持一致。

## 修改内容详细分析

### 1. 文件修改统计
```
 Documentation/arch/riscv/uabi.rst     |  17 ++++
 arch/riscv/Kconfig                    |  10 +++
 arch/riscv/include/asm/processor.h     |   6 ++
 arch/riscv/include/asm/switch_to.h     |  15 ++++
 arch/riscv/kernel/process.c            | 137 +++++++++++++++++++++++++++++++++
 include/uapi/linux/prctl.h             |   4 +-
 6 files changed, 188 insertions(+), 1 deletion(-)
```

### 2. 核心技术原理

#### 2.1 RISC-V SUPM扩展

SUPM (Supervisor-mode User-mode Pointer Masking) 是RISC-V的一个扩展，允许supervisor模式控制用户模式的指针掩码行为。核心机制包括：

- **ENVCFG.PMM字段**: 控制指针掩码模式
  - `ENVCFG_PMM_PMLEN_0`: 禁用指针掩码 (PMLEN=0)
  - `ENVCFG_PMM_PMLEN_7`: 7位指针掩码 (PMLEN=7)
  - `ENVCFG_PMM_PMLEN_16`: 16位指针掩码 (PMLEN=16)

- **PMLEN (Pointer Masking Length)**: 指定被掩码的高位数量

#### 2.2 指针掩码工作原理

指针掩码允许在虚拟地址的高位存储额外的元数据（tags），这些位在地址转换时被硬件忽略：

```
64位地址布局 (PMLEN=16):
[63:48] [47:0]
  tags   actual address
```

### 3. 具体代码修改

#### 3.1 Kconfig配置 (arch/riscv/Kconfig)

```kconfig
config RISCV_ISA_SUPM
	bool "Supervisor-mode User-mode Pointer Masking support"
	default y
	depends on 64BIT && RISCV_ALTERNATIVE
	help
	  This option enables support for the RISC-V Supervisor-mode
	  User-mode Pointer Masking (SUPM) extension.
```

#### 3.2 用户API定义 (include/uapi/linux/prctl.h)

```c
/* RISC-V pointer masking tag length */
#define PR_PMLEN_SHIFT			24
#define PR_PMLEN_MASK			(0xffUL << PR_PMLEN_SHIFT)

/*
 * Tagged user address controls for arm64 and riscv.
 */
#define PR_SET_TAGGED_ADDR_CTRL		55
#define PR_GET_TAGGED_ADDR_CTRL		56
```

#### 3.3 处理器状态管理 (arch/riscv/include/asm/processor.h)

在`thread_struct`中添加了`envcfg`字段：

```c
struct thread_struct {
	/* ... */
	unsigned long envcfg;
	/* ... */
};
```

#### 3.4 上下文切换支持 (arch/riscv/include/asm/switch_to.h)

实现了`envcfg_update_bits`函数和`__switch_to_envcfg`函数：

```c
static inline void envcfg_update_bits(struct task_struct *task,
				      unsigned long mask, unsigned long val)
{
	unsigned long envcfg;

	envcfg = (task->thread.envcfg & ~mask) | val;
	task->thread.envcfg = envcfg;
	if (task == current)
		csr_write(CSR_ENVCFG, envcfg);
}

static inline void __switch_to_envcfg(struct task_struct *next)
{
	asm volatile (ALTERNATIVE("nop", "csrw " __stringify(CSR_ENVCFG) ", %0",
				  0, RISCV_ISA_EXT_XLINUXENVCFG, 1)
			:: "r" (next->thread.envcfg) : "memory");
}
```

#### 3.5 核心实现 (arch/riscv/kernel/process.c)

##### 硬件能力检测

```c
static bool have_user_pmlen_7;
static bool have_user_pmlen_16;

static bool try_to_set_pmm(unsigned long value)
{
	csr_set(CSR_ENVCFG, value);
	return (csr_read_clear(CSR_ENVCFG, ENVCFG_PMM) & ENVCFG_PMM) == value;
}

static int __init tagged_addr_init(void)
{
	if (!riscv_has_extension_unlikely(RISCV_ISA_EXT_SUPM))
		return 0;

	/* 检测支持的PMLEN值 */
	csr_clear(CSR_ENVCFG, ENVCFG_PMM);
	have_user_pmlen_7 = try_to_set_pmm(ENVCFG_PMM_PMLEN_7);
	have_user_pmlen_16 = try_to_set_pmm(ENVCFG_PMM_PMLEN_16);

	if (!register_sysctl("abi", tagged_addr_sysctl_table))
		return -EINVAL;

	return 0;
}
```

##### prctl系统调用实现

```c
long set_tagged_addr_ctrl(struct task_struct *task, unsigned long arg)
{
	unsigned long valid_mask = PR_PMLEN_MASK | PR_TAGGED_ADDR_ENABLE;
	struct thread_info *ti = task_thread_info(task);
	struct mm_struct *mm = task->mm;
	unsigned long pmm;
	u8 pmlen;

	/* 验证SUPM扩展支持 */
	if (!riscv_has_extension_unlikely(RISCV_ISA_EXT_SUPM))
		return -EINVAL;

	/* 不支持32位兼容模式 */
	if (is_compat_thread(ti))
		return -EINVAL;

	/* 参数验证 */
	if (arg & ~valid_mask)
		return -EINVAL;

	/* 选择最小满足要求的PMLEN */
	pmlen = FIELD_GET(PR_PMLEN_MASK, arg);
	if (pmlen == PMLEN_0) {
		pmm = ENVCFG_PMM_PMLEN_0;
	} else if (pmlen <= PMLEN_7 && have_user_pmlen_7) {
		pmlen = PMLEN_7;
		pmm = ENVCFG_PMM_PMLEN_7;
	} else if (pmlen <= PMLEN_16 && have_user_pmlen_16) {
		pmlen = PMLEN_16;
		pmm = ENVCFG_PMM_PMLEN_16;
	} else {
		return -EINVAL;
	}

	/* 检查全局禁用状态 */
	if (arg & PR_TAGGED_ADDR_ENABLE && (tagged_addr_disabled || !pmlen))
		return -EINVAL;

	if (!(arg & PR_TAGGED_ADDR_ENABLE))
		pmlen = PMLEN_0;

	/* 内存映射锁定和更新 */
	if (mmap_write_lock_killable(mm))
		return -EINTR;

	if (test_bit(MM_CONTEXT_LOCK_PMLEN, &mm->context.flags) && 
	    mm->context.pmlen != pmlen) {
		mmap_write_unlock(mm);
		return -EBUSY;
	}

	envcfg_update_bits(task, ENVCFG_PMM, pmm);
	mm->context.pmlen = pmlen;

	mmap_write_unlock(mm);
	return 0;
}
```

##### 进程生命周期管理

```c
void flush_thread(void)
{
	/* ... */
#ifdef CONFIG_RISCV_ISA_SUPM
	if (riscv_has_extension_unlikely(RISCV_ISA_EXT_SUPM))
		envcfg_update_bits(current, ENVCFG_PMM, ENVCFG_PMM_PMLEN_0);
#endif
}

int copy_thread(struct task_struct *p, const struct kernel_clone_args *args)
{
	/* 确保同一mm中的所有线程使用相同的指针掩码模式 */
	if (IS_ENABLED(CONFIG_RISCV_ISA_SUPM) && p->mm && (clone_flags & CLONE_VM))
		set_bit(MM_CONTEXT_LOCK_PMLEN, &p->mm->context.flags);
	/* ... */
}
```

### 4. 安全性考虑

#### 4.1 权限控制

- **全局禁用机制**: 通过sysctl `abi.tagged_addr_disabled`可以全局禁用tagged address支持
- **进程隔离**: 每个进程独立管理其指针掩码设置
- **线程同步**: 同一内存空间的所有线程必须使用相同的PMLEN设置

#### 4.2 兼容性保护

- **32位兼容模式**: 明确拒绝32位进程使用指针掩码
- **硬件检测**: 运行时检测硬件支持的PMLEN值
- **向后兼容**: 默认禁用指针掩码，需要显式启用

### 5. 性能影响分析

#### 5.1 上下文切换开销

- 在进程切换时需要保存/恢复ENVCFG寄存器
- 使用ALTERNATIVE机制，仅在支持SUPM的硬件上执行

#### 5.2 内存管理影响

- 指针掩码不影响实际的地址转换
- 高位tag位在MMU中被自动忽略
- 对TLB和缓存性能无直接影响

### 6. 与ARM64的对比

#### 6.1 API兼容性

- 使用相同的prctl系统调用号
- 相似的参数格式和语义
- 统一的用户空间接口

#### 6.2 实现差异

| 特性 | ARM64 | RISC-V |
|------|-------|--------|
| 硬件机制 | TBI (Top Byte Ignore) | SUPM (Supervisor-mode User-mode Pointer Masking) |
| 支持的tag长度 | 8位固定 | 7位或16位可配置 |
| 控制寄存器 | TCR_EL1.TBI | ENVCFG.PMM |
| 运行时检测 | 编译时确定 | 运行时硬件检测 |

### 7. 相关提交分析

这个patch是RISC-V SUPM支持系列的一部分，相关提交包括：

1. **基础架构支持**: 添加SUPM扩展检测和基础设施
2. **内存管理集成**: 在内存管理子系统中集成指针掩码支持
3. **用户空间接口**: 实现prctl系统调用接口
4. **文档更新**: 更新RISC-V UABI文档

### 8. 测试和验证

#### 8.1 功能测试

- 验证不同PMLEN值的设置和获取
- 测试进程间的隔离性
- 验证线程间的一致性要求

#### 8.2 兼容性测试

- 确保现有应用程序不受影响
- 验证32位兼容模式的正确拒绝
- 测试硬件不支持时的降级行为

### 9. 未来发展方向

#### 9.1 硬件支持扩展

- 更多PMLEN值的支持
- 更细粒度的控制机制
- 性能优化的硬件实现

#### 9.2 软件生态

- 编译器工具链支持
- 调试器和分析工具适配
- 用户空间库的集成

### 10. 总结

这个patch成功为RISC-V架构引入了用户空间指针掩码支持，主要成就包括：

1. **标准化接口**: 与ARM64保持一致的prctl接口
2. **硬件抽象**: 良好的硬件能力检测和抽象
3. **安全设计**: 完善的权限控制和安全机制
4. **性能考虑**: 最小化的运行时开销
5. **向后兼容**: 不影响现有应用程序

该实现为RISC-V生态系统中需要tagged pointer支持的应用（如垃圾回收器、内存安全工具等）提供了重要的基础设施支持，标志着RISC-V在高级内存管理特性方面的重要进展。

通过引入SUPM支持，RISC-V架构在内存安全和高级编程语言支持方面与其他主流架构保持了同等水平，为未来的创新应用奠定了坚实基础。