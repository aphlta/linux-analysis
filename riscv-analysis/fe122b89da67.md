# RISC-V 内存热插拔准备：页表函数属性修改 Patch 分析

## Commit 信息

**Commit ID:** fe122b89da670be155f3474c0cb28af2fbcd2ecc  
**作者:** Björn Töpel <bjorn@rivosinc.com>  
**提交日期:** 2024年6月5日  
**提交者:** Palmer Dabbelt <palmer@rivosinc.com>  
**标题:** riscv: mm: Change attribute from __init to __meminit for page functions  

**审核者:**
- Alexandre Ghiti <alexghiti@rivosinc.com>
- David Hildenbrand <david@redhat.com>
- Oscar Salvador <osalvador@suse.de>

**邮件链接:** https://lore.kernel.org/r/20240605114100.315918-4-bjorn@kernel.org

## Patch 概述

这个patch是RISC-V内存热插拔支持patch系列中的关键准备工作，通过将页表管理相关函数的属性从`__init`修改为`__meminit`，为即将到来的内存热插拔架构特定回调函数做准备。

## 详细修改内容

### 修改的文件

1. **arch/riscv/include/asm/mmu.h** (4行修改)
2. **arch/riscv/include/asm/pgtable.h** (2行修改)
3. **arch/riscv/mm/init.c** (56行修改)

### 具体代码修改

#### 1. arch/riscv/include/asm/mmu.h

**修改前:**
```c
void __init create_pgd_mapping(pgd_t *pgdp, uintptr_t va, phys_addr_t pa,
                              phys_addr_t sz, pgprot_t prot);
```

**修改后:**
```c
void __meminit create_pgd_mapping(pgd_t *pgdp, uintptr_t va, phys_addr_t pa, phys_addr_t sz,
                                 pgprot_t prot);
```

#### 2. arch/riscv/include/asm/pgtable.h

**修改前:**
```c
void __init remove_pgd_mapping(pgd_t *pgdp, uintptr_t va, phys_addr_t size);
```

**修改后:**
```c
void __meminit remove_pgd_mapping(pgd_t *pgdp, uintptr_t va, phys_addr_t size);
```

#### 3. arch/riscv/mm/init.c

**主要修改的函数:**

1. **create_pgd_mapping()** - PGD级别页表映射创建
```c
// 修改前
void __init create_pgd_mapping(pgd_t *pgdp, uintptr_t va, phys_addr_t pa,
                              phys_addr_t sz, pgprot_t prot)

// 修改后
void __meminit create_pgd_mapping(pgd_t *pgdp, uintptr_t va, phys_addr_t pa, phys_addr_t sz,
                                 pgprot_t prot)
```

2. **best_map_size()** - 最佳映射大小计算
```c
// 修改前
static uintptr_t __init best_map_size(phys_addr_t pa, uintptr_t va, phys_addr_t size)

// 修改后
static uintptr_t __meminit best_map_size(phys_addr_t pa, uintptr_t va, phys_addr_t size)
```

3. **pgprot_from_va()** - 虚拟地址保护属性获取（两个版本）
```c
// CONFIG_STRICT_KERNEL_RWX版本
static __init pgprot_t pgprot_from_va(uintptr_t va) → static __meminit pgprot_t pgprot_from_va(uintptr_t va)

// 非CONFIG_STRICT_KERNEL_RWX版本
static __init pgprot_t pgprot_from_va(uintptr_t va) → static __meminit pgprot_t pgprot_from_va(uintptr_t va)
```

4. **create_linear_mapping_range()** - 线性映射范围创建
```c
// 修改前
static void __init create_linear_mapping_range(phys_addr_t start, phys_addr_t end,
                                              uintptr_t fixed_map_size)

// 修改后
static void __meminit create_linear_mapping_range(phys_addr_t start, phys_addr_t end,
                                                 uintptr_t fixed_map_size)
```

## 代码修改原理分析

### 1. __init vs __meminit 属性差异

#### __init 属性
- **生命周期:** 仅在系统初始化阶段可用
- **内存管理:** 初始化完成后，标记为__init的代码和数据会被释放
- **使用场景:** 一次性初始化代码
- **内存节省:** 释放后可回收内存空间

#### __meminit 属性
- **生命周期:** 在内存热插拔启用时保持可用
- **条件保留:** 只有在CONFIG_MEMORY_HOTPLUG启用时才保留在内核中
- **使用场景:** 内存热插拔相关的代码
- **动态需求:** 支持运行时内存管理操作

### 2. 内存热插拔的技术需求

#### 页表管理需求
内存热插拔操作需要在运行时动态地：
- **添加内存:** 为新内存创建页表映射
- **移除内存:** 清理和移除页表映射
- **映射管理:** 维护虚拟地址到物理地址的映射关系

#### 函数可用性要求
内存热插拔的架构特定回调函数需要调用这些页表管理函数：
- `arch_add_memory()` - 需要调用`create_pgd_mapping()`等函数
- `arch_remove_memory()` - 需要调用`remove_pgd_mapping()`等函数
- `vmemmap_populate()` - 需要页表创建功能
- `vmemmap_free()` - 需要页表清理功能

### 3. 修改函数的功能分析

#### create_pgd_mapping()
**功能:** 创建PGD级别的页表映射
**参数:**
- `pgdp`: PGD页表指针
- `va`: 虚拟地址
- `pa`: 物理地址
- `sz`: 映射大小
- `prot`: 页面保护属性

**实现逻辑:**
```c
void __meminit create_pgd_mapping(pgd_t *pgdp, uintptr_t va, phys_addr_t pa, phys_addr_t sz,
                                 pgprot_t prot)
{
    pgd_next_t *nextp;
    phys_addr_t next_phys;
    uintptr_t pgd_idx = pgd_index(va);

    // 如果映射大小等于PGDIR_SIZE，直接设置PGD条目
    if (sz == PGDIR_SIZE) {
        if (pgd_val(pgdp[pgd_idx]) == 0)
            pgdp[pgd_idx] = pfn_pgd(PFN_DOWN(pa), prot);
        return;
    }

    // 否则需要分配下一级页表
    if (pgd_val(pgdp[pgd_idx]) == 0) {
        next_phys = alloc_pgd_next(va);
        pgdp[pgd_idx] = pfn_pgd(PFN_DOWN(next_phys), PAGE_TABLE);
        nextp = get_pgd_next_virt(next_phys);
        memset(nextp, 0, PAGE_SIZE);
    } else {
        next_phys = PFN_PHYS(_pgd_pfn(pgdp[pgd_idx]));
        nextp = get_pgd_next_virt(next_phys);
    }

    create_pgd_next_mapping(nextp, va, pa, sz, prot);
}
```

#### best_map_size()
**功能:** 根据地址对齐和大小确定最佳的映射粒度
**优化策略:**
- 优先使用大页映射（P4D_SIZE, PUD_SIZE, PMD_SIZE）
- 考虑地址对齐要求
- 在debug_pagealloc启用时强制使用PAGE_SIZE

#### pgprot_from_va()
**功能:** 根据虚拟地址确定页面保护属性
**策略:**
- 内核代码段：PAGE_KERNEL_READ_EXEC
- 内核数据段：PAGE_KERNEL
- 线性映射别名：PAGE_KERNEL_READ（64位且启用严格RWX时）

#### create_linear_mapping_range()
**功能:** 为指定物理内存范围创建线性映射
**过程:**
1. 遍历物理地址范围
2. 计算对应的虚拟地址
3. 确定最佳映射大小
4. 调用create_pgd_mapping()创建映射

## 内存热插拔架构支持

### 1. RISC-V内存热插拔patch系列

这个patch是完整内存热插拔支持的一部分，相关提交包括：

#### 前置准备提交
1. **66673099f734** - "riscv: mm: Pre-allocate vmemmap/direct map/kasan PGD entries"
2. **fe122b89da67** - "riscv: mm: Change attribute from __init to __meminit for page functions" (本patch)
3. **6e6c5e21b8cb** - "riscv: mm: Add pfn_to_kaddr() implementation"

#### 核心实现提交
4. **c75a74f4ba19** - "riscv: mm: Add memory hotplugging support"
5. **37992b7f1097** - "riscv: mm: Take memory hotplug read-lock during kernel page table dump"

#### 功能启用提交
6. **f8c2a240556e** - "riscv: Enable memory hotplugging for RISC-V"
7. **0546d7043e55** - "virtio-mem: Enable virtio-mem for RISC-V"

### 2. 架构特定回调函数

内存热插拔需要架构提供以下回调函数：

```c
// 添加内存到系统
int arch_add_memory(int nid, u64 start, u64 size, struct mhp_params *params);

// 从系统移除内存
void arch_remove_memory(u64 start, u64 size, struct vmem_altmap *altmap);

// 获取可映射的地址范围
struct range arch_get_mappable_range(void);

// 释放vmemmap映射
void vmemmap_free(unsigned long start, unsigned long end, struct vmem_altmap *altmap);
```

### 3. 内存热插拔流程

#### 内存热添加流程
1. **验证内存范围** - 检查地址范围的有效性
2. **创建页表映射** - 调用`create_pgd_mapping()`等函数
3. **初始化页面结构** - 设置struct page结构
4. **添加到内存管理** - 调用`__add_pages()`
5. **更新内存统计** - 更新系统内存信息

#### 内存热移除流程
1. **隔离内存页面** - 确保页面不被使用
2. **移除页面结构** - 清理struct page结构
3. **清理页表映射** - 调用`remove_pgd_mapping()`等函数
4. **释放内存资源** - 回收相关资源
5. **更新内存统计** - 更新系统内存信息

## 技术影响分析

### 1. 内存使用影响

#### 启用内存热插拔时
- **代码保留:** 标记为`__meminit`的函数代码保留在内核中
- **内存开销:** 增加约几KB的内核代码段大小
- **功能支持:** 支持运行时内存热插拔操作

#### 未启用内存热插拔时
- **代码释放:** `__meminit`函数在初始化后被释放（与`__init`行为相同）
- **内存节省:** 不增加额外的内存开销
- **功能限制:** 不支持内存热插拔

### 2. 性能影响

#### 编译时影响
- **条件编译:** 基于CONFIG_MEMORY_HOTPLUG配置
- **代码优化:** 编译器可以进行相应优化
- **二进制大小:** 在启用热插拔时略微增加

#### 运行时影响
- **初始化性能:** 对系统启动性能无影响
- **热插拔性能:** 提供必要的函数支持，确保操作正确性
- **内存访问:** 对正常内存访问性能无影响

### 3. 兼容性考虑

#### 向后兼容性
- **ABI兼容:** 不影响用户空间ABI
- **配置兼容:** 在未启用热插拔时行为不变
- **功能兼容:** 不影响现有内存管理功能

#### 架构兼容性
- **RISC-V特定:** 修改仅影响RISC-V架构
- **多级页表:** 支持RISC-V的多级页表结构（SV39/SV48/SV57）
- **扩展支持:** 为未来的内存管理扩展奠定基础

## 代码质量和安全性

### 1. 代码审查要点

#### 函数签名一致性
- **头文件声明:** 确保头文件中的函数声明与实现一致
- **参数类型:** 验证参数类型的正确性
- **返回值处理:** 确保返回值处理的一致性

#### 内存安全
- **边界检查:** 确保地址范围检查的正确性
- **空指针检查:** 验证指针有效性
- **内存泄漏:** 确保页表分配和释放的平衡

### 2. 测试验证

#### 功能测试
- **基本功能:** 验证页表创建和映射功能
- **边界条件:** 测试各种地址对齐和大小组合
- **错误处理:** 验证错误条件下的行为

#### 集成测试
- **内存热插拔:** 与完整的热插拔功能集成测试
- **多架构:** 确保不影响其他架构的构建
- **配置测试:** 测试不同内核配置下的行为

## 总结

这个patch通过将关键的页表管理函数属性从`__init`修改为`__meminit`，为RISC-V架构的内存热插拔支持奠定了重要基础。修改策略简洁有效：

### 主要贡献
1. **功能准备:** 为内存热插拔提供必要的函数支持
2. **内存优化:** 在不需要时仍然释放内存，在需要时保留功能
3. **架构完善:** 完善RISC-V的内存管理架构

### 技术优势
1. **条件保留:** 只在启用内存热插拔时保留代码
2. **最小影响:** 对现有功能和性能影响最小
3. **标准实现:** 遵循Linux内核的标准内存热插拔架构

### 未来展望
这个patch为RISC-V架构带来了现代化的内存管理能力，支持：
- **动态内存管理:** 运行时添加和移除内存
- **虚拟化支持:** 为虚拟化环境提供更好的内存管理
- **云计算适配:** 支持云环境中的动态资源调整

通过这个精心设计的修改，RISC-V架构在内存管理方面向前迈出了重要一步，为支持现代计算环境的动态内存需求提供了坚实的基础。