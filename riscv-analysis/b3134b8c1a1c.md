# RISC-V Jump Label Boot Failure Fix Analysis

## Commit Information
- **Commit ID**: b3134b8c1a1c
- **Title**: riscv: Fixup boot failure when CONFIG_DEBUG_RT_MUTEXES=y
- **Author**: Guo Ren <guoren@linux.alibaba.com>
- **Date**: 2024-11-30
- **Fixes**: ab83647fadae ("riscv: Add qspinlock support")

## 1. 问题背景

### 1.1 问题描述
当启用`CONFIG_DEBUG_RT_MUTEXES=y`配置时，RISC-V架构在启动过程中会出现死锁导致的启动失败。这个问题是由于在早期启动阶段，jump label转换过程中spinlock类型不匹配造成的。

### 1.2 根本原因
问题的根本原因在于RISC-V架构引入qspinlock支持后，在系统启动早期阶段会发生以下情况：

1. **初始状态**: 系统使用ticket spinlock
2. **转换过程**: `arch_jump_label_transform_queue()`函数在修改代码时会改变spinlock的实现
3. **不匹配问题**: 在代码修改过程中，可能出现ticket_lock与queued_spin_unlock的混合使用
4. **死锁**: 最终导致在mutex操作中发生死锁

## 2. 技术分析

### 2.1 问题场景分析

根据commit message中的详细分析，问题发生的三个阶段：

#### 阶段1: 正常情况
```
arch_jump_label_transform_queue() ->
mutex_lock(&text_mutex);   +-> raw_spin_lock -> ticket_lock
                           |-> raw_spin_unlock -> ticket_unlock
patch_insn_write -> 无修改
mutex_unlock(&text_mutex);
```

#### 阶段2: 部分修改导致不匹配
```
arch_jump_label_transform_queue() ->
mutex_lock(&text_mutex);   +-> raw_spin_lock -> ticket_lock
                           |-> raw_spin_unlock -> *queued_spin_unlock*
patch_insn_write -> 将raw_spin_lock改为ticket_lock
mutex_unlock(&text_mutex);
```
**问题**: ticket_lock与queued_spin_unlock不匹配

#### 阶段3: 死锁
```
arch_jump_label_transform_queue() ->
mutex_lock(&text_mutex);   +-> raw_spin_lock -> ticket_lock /* 死锁! */
                           |-> raw_spin_unlock -> ticket_unlock
patch_insn_write -> 修改其他raw_spin_#op为ticket_#op
mutex_unlock(&text_mutex);
```

### 2.2 修复方案

修复方案是在早期启动阶段禁用mutex的使用，类似于stop_machine的处理方式：

```c
if (early_boot_irqs_disabled) {
    riscv_patch_in_stop_machine = 1;
    patch_insn_write(addr, &insn, sizeof(insn));
    riscv_patch_in_stop_machine = 0;
} else {
    mutex_lock(&text_mutex);
    patch_insn_write(addr, &insn, sizeof(insn));
    mutex_unlock(&text_mutex);
}
```

## 3. 代码修改详解

### 3.1 修改的文件
- **文件**: `arch/riscv/kernel/jump_label.c`
- **函数**: `arch_jump_label_transform_queue()`
- **修改行数**: +9, -3

### 3.2 关键修改点

1. **条件判断**: 添加`early_boot_irqs_disabled`检查
2. **标志设置**: 使用`riscv_patch_in_stop_machine`标志
3. **互斥锁绕过**: 在早期启动阶段避免使用`text_mutex`

### 3.3 设计原理

#### 3.3.1 early_boot_irqs_disabled检查
- **目的**: 判断是否处于早期启动阶段
- **原理**: 在早期启动阶段，中断被禁用，此时不应该使用可能导致调度的mutex

#### 3.3.2 riscv_patch_in_stop_machine标志
- **目的**: 指示当前正在进行代码修补操作
- **作用**: 可能用于其他代码路径的同步和保护

#### 3.3.3 mutex绕过机制
- **原理**: 在早期启动阶段，系统是单线程运行，不需要mutex保护
- **安全性**: 通过`riscv_patch_in_stop_machine`标志确保操作的原子性

## 4. 相关技术背景

### 4.1 RISC-V Spinlock演进

1. **Ticket Spinlock**: 传统的基于ticket的自旋锁实现
2. **Queued Spinlock**: 更高效的队列化自旋锁实现
3. **动态切换**: 系统启动时从ticket切换到queued spinlock

### 4.2 Jump Label机制

- **目的**: 运行时代码修补，用于优化条件分支
- **实现**: 通过修改指令实现分支的启用/禁用
- **挑战**: 需要在多核环境下安全地修改代码

### 4.3 Text Patching

- **text_mutex**: 保护代码修改操作的互斥锁
- **patch_insn_write**: 实际执行指令修改的函数
- **同步需求**: 确保所有CPU看到一致的代码视图

## 5. 影响分析

### 5.1 修复效果
- **解决问题**: 消除了CONFIG_DEBUG_RT_MUTEXES=y时的启动死锁
- **保持功能**: 不影响jump label的正常功能
- **性能影响**: 最小，仅在早期启动阶段有轻微差异

### 5.2 适用范围
- **架构**: 仅影响RISC-V架构
- **配置**: 主要解决DEBUG_RT_MUTEXES配置下的问题
- **版本**: 适用于引入qspinlock支持后的内核版本

## 6. 测试和验证

### 6.1 测试人员
- Conor Dooley <conor.dooley@microchip.com>
- Alexandre Ghiti <alexghiti@rivosinc.com>
- Nam Cao <namcao@linutronix.de>

### 6.2 审查人员
- Alexandre Ghiti <alexghiti@rivosinc.com>

## 7. 相关链接

- **原始报告**: [Linux RISC-V邮件列表](https://lore.kernel.org/linux-riscv/CAJF2gTQwYTGinBmCSgVUoPv0_q4EPt_+WiyfUA1HViAKgUzxAg@mail.gmail.com/T/#mf488e6347817fca03bb93a7d34df33d8615b3775)
- **补丁链接**: [Patch链接](https://lore.kernel.org/r/20241130153310.3349484-1-guoren@kernel.org)
- **修复的原始commit**: ab83647fadae ("riscv: Add qspinlock support")

## 8. 总结

这个patch解决了RISC-V架构在引入qspinlock支持后出现的启动死锁问题。通过在早期启动阶段绕过mutex使用，避免了spinlock类型不匹配导致的死锁。这是一个典型的架构特定的启动时序问题，体现了在引入新特性时需要考虑与现有机制的兼容性。修复方案简洁有效，对系统性能影响最小，是一个高质量的bug修复。