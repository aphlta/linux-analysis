# RISC-V Misaligned Access Handler Patch 分析

## Commit 信息
- **Commit ID**: 4b0b4df9e8a1
- **标题**: riscv: misaligned: fix sleeping function called during misaligned access handling
- **作者**: Zong Li <zong.li@sifive.com>, Nylon Chen <nylon.chen@sifive.com>
- **提交者**: Palmer Dabbelt <palmer@rivosinc.com>
- **稳定版维护者**: Sasha Levin <sashal@kernel.org>

## 问题描述

这个patch修复了在RISC-V架构的misaligned access处理过程中调用可能睡眠函数的问题。具体表现为在处理未对齐访问时，系统会产生以下警告：

```
BUG: sleeping function called from invalid context at mm/page_alloc.c:4663
in_atomic(): 0, irqs_disabled(): 1, non_block: 0, pid: 1, name: init
preempt_count: 0, expected: 0
RCU nest depth: 0, expected: 0
irq event stamp: 42
hardirqs last  enabled at (41): [<ffffffff8000aa0e>] restore_all+0xe/0x66
hardirqs last disabled at (42): [<ffffffff809ecd5e>] __do_softirq+0x2de/0x2e6
softirqs last  enabled at (0): [<0000000000000000>] 0x0
softirqs last disabled at (0): [<0000000000000000>] 0x0
```

## 代码修改内容

### 修改的文件
- `arch/riscv/kernel/traps_misaligned.c`

### 具体修改

#### 1. handle_scalar_misaligned_load 函数 (第458行)
```c
// 修改前
if (copy_from_user(&val, (u8 __user *)addr, len))
    return -1;

// 修改后  
if (copy_from_user_nofault(&val, (u8 __user *)addr, len))
    return -1;
```

#### 2. handle_scalar_misaligned_store 函数 (第559行)
```c
// 修改前
if (copy_to_user((u8 __user *)addr, &val, len))
    return -1;

// 修改后
if (copy_to_user_nofault((u8 __user *)addr, &val, len))
    return -1;
```

## 技术原理分析

### copy_from_user vs copy_from_user_nofault

1. **copy_from_user**:
   - 标准的用户空间到内核空间数据拷贝函数
   - 内部调用 `might_fault()` 和 `might_sleep()`
   - 可能触发页面错误处理，进而可能导致进程睡眠
   - 在原子上下文或中断禁用状态下调用会产生警告

2. **copy_from_user_nofault**:
   - 专门设计用于原子上下文的用户空间数据拷贝函数
   - 使用 `pagefault_disable()` 禁用页面错误处理
   - 使用 `__copy_from_user_inatomic()` 进行原子拷贝
   - 不会导致进程睡眠，适合在中断上下文中使用

### copy_to_user vs copy_to_user_nofault

类似地，`copy_to_user_nofault` 相比 `copy_to_user` 的主要区别是：
- 在原子上下文中安全使用
- 禁用页面错误处理机制
- 不会触发可能的睡眠操作

### 函数实现细节

从 `mm/maccess.c` 中可以看到 `copy_from_user_nofault` 的实现：

```c
long copy_from_user_nofault(void *dst, const void __user *src, size_t size)
{
    long ret = -EFAULT;

    if (!__access_ok(src, size))
        return ret;

    if (!nmi_uaccess_okay())
        return ret;

    pagefault_disable();  // 关键：禁用页面错误处理
    ret = __copy_from_user_inatomic(dst, src, size);
    pagefault_enable();

    if (ret)
        return -EFAULT;
    return 0;
}
```

## 问题根因分析

### 调用上下文问题

Misaligned access处理通常发生在以下上下文中：
1. **异常处理上下文**: 当CPU遇到未对齐访问时触发异常
2. **中断禁用状态**: 异常处理期间通常会禁用中断
3. **原子上下文**: 不允许进程调度和睡眠

在这种上下文中调用可能睡眠的函数（如 `copy_from_user`）会导致系统不一致状态。

### 历史修复链

这个patch是一系列修复的延续：

1. **b686ecdeacf6**: "riscv: misaligned: Restrict user access to kernel memory"
   - 将 `raw_copy_from_user` 改为 `copy_from_user`
   - 修复了安全漏洞，但引入了睡眠函数调用问题

2. **441381506ba7**: "riscv: misaligned: remove CONFIG_RISCV_M_MODE specific code"
   - 重构了misaligned处理代码
   - 引入了用户空间访问的统一处理

3. **4b0b4df9e8a1** (当前patch):
   - 修复睡眠函数调用问题
   - 使用 `*_nofault` 版本确保原子性

## 影响和意义

### 修复的问题
1. **消除内核警告**: 解决了在原子上下文中调用睡眠函数的警告
2. **提高系统稳定性**: 避免了潜在的调度问题和系统不一致状态
3. **保持功能完整性**: 在修复问题的同时保持了misaligned access处理的正确性

### 性能影响
- `*_nofault` 函数在某些情况下可能性能略低（因为禁用了页面错误处理）
- 但在异常处理上下文中，这是必要的权衡
- 对于misaligned access这种相对少见的情况，性能影响可以忽略

## 相关技术背景

### RISC-V Misaligned Access
- RISC-V架构要求内存访问必须对齐
- 未对齐访问会触发异常，需要软件模拟
- 异常处理器需要读取/写入用户空间数据来完成模拟

### 内核原子上下文
- 中断处理、异常处理等上下文中不允许睡眠
- 需要使用特殊的原子版本函数
- 违反原子性要求会导致系统不稳定

## 总结

这个patch通过将 `copy_from_user`/`copy_to_user` 替换为对应的 `*_nofault` 版本，成功解决了RISC-V misaligned access处理中的睡眠函数调用问题。这是一个典型的内核原子上下文修复案例，体现了内核开发中对上下文安全性的严格要求。修复既保持了功能的正确性，又确保了系统的稳定性。