# Patch Analysis: 1845d381f280

## Commit Information

**Commit ID:** 1845d381f28063a3b68e9e148d5a7f01d6be8721  
**Author:** Steffen Persvold <spersvold@gmail.com>  
**Date:** Sun Jul 7 02:35:15 2024 +0200  
**Subject:** riscv: cacheinfo: Add back init_cache_level() function  

## 问题背景

这个patch解决了RISC-V架构在非SMP（单处理器）内核配置下无法检测缓存层次结构的问题。

### 根本原因

1. **历史变更影响**: commit 5944ce092b97 ("arch_topology: Build cacheinfo from primary CPU") 从 `arch/riscv/kernel/cacheinfo.c` 中移除了 `init_cache_level()` 函数

2. **依赖关系问题**: 该commit让系统依赖于 `drivers/base/arch_topology.c` 中的 `init_cpu_topology()` 函数来调用 `fetch_cache_info()`，而 `fetch_cache_info()` 会调用 `init_of_cache_level()` 来填充缓存层次信息

3. **SMP配置限制**: `init_cpu_topology()` 函数只在 `smpboot.c:smp_prepare_cpus()` 中被调用，因此只在定义了 `CONFIG_SMP` 时才可用

4. **非SMP内核问题**: 在非SMP内核中，`smp_prepare_cpus()` 不会被调用，导致缓存层次检测失效

## 代码修改分析

### 修改内容

在 `arch/riscv/kernel/cacheinfo.c` 中添加了以下函数：

```c
int init_cache_level(unsigned int cpu)
{
    return init_of_cache_level(cpu);
}
```

### 修改原理

1. **函数作用**: `init_cache_level()` 是一个架构特定的函数，用于初始化CPU的缓存层次信息

2. **调用链路**: 
   - 在SMP系统中：`smp_prepare_cpus()` → `init_cpu_topology()` → `fetch_cache_info()` → `init_of_cache_level()`
   - 在非SMP系统中：直接调用 `init_cache_level()` → `init_of_cache_level()`

3. **兼容性处理**: `init_level_allocate_ci()` 函数能够优雅地处理SMP系统中的重复调用，因为它会检查缓存信息是否已经在早期的 `fetch_cache_info()` 调用中初始化

### 核心函数分析

#### `init_of_cache_level()` 函数

位于 `drivers/base/cacheinfo.c`，主要功能：

1. **设备树解析**: 通过 `of_cpu_device_node_get(cpu)` 获取CPU设备节点
2. **缓存节点检查**: 使用 `of_check_cache_nodes()` 验证缓存节点的有效性
3. **层次计算**: 遍历设备树中的缓存节点，计算缓存层次和叶子节点数量
4. **信息存储**: 将计算结果存储到 `cpu_cacheinfo` 结构中

#### `fetch_cache_info()` 函数

位于 `drivers/base/cacheinfo.c`，执行流程：

1. **平台检测**: 根据 `acpi_disabled` 选择DT或ACPI路径
2. **缓存级别初始化**: 调用 `init_of_cache_level()` 或 `acpi_get_cache_info()`
3. **内存分配**: 通过 `allocate_cache_info()` 为缓存信息分配内存

## 相关提交分析

### 原始问题提交: 5944ce092b97

**标题**: "arch_topology: Build cacheinfo from primary CPU"  
**作者**: Pierre Gondois <pierre.gondois@arm.com>  
**日期**: Wed Jan 4 19:30:29 2023 +0100  

**问题描述**:
- 在PREEMPT_RT内核中，secondary CPU上的 `detect_cache_attributes()` 会触发 "BUG: sleeping function called from invalid context"
- 原因是该函数在禁用抢占和中断的上下文中分配内存并可能获取PPTT互斥锁

**解决方案**:
- 将缓存信息构建移到primary CPU的早期初始化阶段
- 通过 `allocate_cache_info()` 在secondary CPU启动前预先构建缓存信息
- 如果预构建失败，则回退到原有机制

### 修复策略

1. **早期分配**: 在primary CPU上预先分配和填充缓存信息
2. **内存保持**: CPU热插拔时不释放缓存信息内存，避免重新分配时的上下文问题
3. **多次调用支持**: `populate_cache_leaves()` 可能被多次调用，因为 `detect_cache_attributes()` 可能在已分配但未填充的情况下被调用

## 技术影响

### 正面影响

1. **功能恢复**: 非SMP内核重新获得缓存层次检测能力
2. **架构一致性**: 保持了RISC-V与其他架构的一致性
3. **向后兼容**: 不影响现有SMP系统的功能

### 设计考虑

1. **重复调用安全**: SMP系统中可能存在重复调用，但 `init_level_allocate_ci()` 能够正确处理
2. **内存效率**: 避免了不必要的重复内存分配
3. **错误处理**: 保持了原有的错误处理机制

## 总结

这个patch是一个重要的修复，解决了commit 5944ce092b97引入的回归问题。通过重新添加 `init_cache_level()` 函数，确保了非SMP RISC-V内核能够正确检测和初始化缓存层次结构信息。

该修复采用了最小化的方法，只添加了必要的函数，并且与现有的SMP机制完全兼容。这种设计确保了在不同配置下（SMP和非SMP）都能正确工作，同时保持了代码的简洁性和可维护性。

## 相关文件

- `arch/riscv/kernel/cacheinfo.c` - 主要修改文件
- `drivers/base/cacheinfo.c` - 核心缓存信息处理
- `drivers/base/arch_topology.c` - 架构拓扑和SMP初始化
- `arch/riscv/kernel/smpboot.c` - RISC-V SMP启动代码
- `include/linux/cacheinfo.h` - 缓存信息相关头文件

## 详细技术分析

### 缓存信息初始化流程

#### SMP系统中的流程

1. **启动阶段**: `start_kernel()` → `smp_prepare_cpus()`
2. **拓扑初始化**: `smp_prepare_cpus()` → `init_cpu_topology()`
3. **缓存信息获取**: `init_cpu_topology()` → `fetch_cache_info()`
4. **设备树解析**: `fetch_cache_info()` → `init_of_cache_level()`
5. **内存分配**: `fetch_cache_info()` → `allocate_cache_info()`

#### 非SMP系统中的流程（修复后）

1. **直接调用**: 缓存子系统直接调用 `init_cache_level()`
2. **设备树解析**: `init_cache_level()` → `init_of_cache_level()`
3. **后续处理**: 通过标准的缓存信息分配和填充流程

### 关键数据结构

#### `cpu_cacheinfo` 结构

```c
struct cpu_cacheinfo {
    struct cacheinfo *info_list;    // 缓存信息列表
    unsigned int num_levels;        // 缓存层次数
    unsigned int num_leaves;        // 缓存叶子节点数
    bool early_ci_levels;          // 是否早期初始化
};
```

#### `cacheinfo` 结构

```c
struct cacheinfo {
    unsigned int id;               // 缓存ID
    enum cache_type type;          // 缓存类型（数据/指令/统一）
    unsigned int level;            // 缓存级别
    unsigned int coherency_line_size;  // 一致性行大小
    unsigned int number_of_sets;   // 组数
    unsigned int ways_of_associativity; // 关联度
    unsigned int size;             // 缓存大小
    cpumask_t shared_cpu_map;      // 共享CPU映射
};
```

### 错误处理机制

1. **设备树缺失**: 如果设备树中没有缓存信息，`init_of_cache_level()` 返回错误
2. **内存分配失败**: `allocate_cache_info()` 处理内存分配失败的情况
3. **重复初始化**: `init_level_allocate_ci()` 检查是否已经初始化，避免重复操作
4. **回退机制**: 如果DT解析失败，系统会尝试使用 `early_cache_level()` 作为备选方案

### 性能考虑

1. **一次性初始化**: 缓存信息只在系统启动时初始化一次
2. **内存复用**: CPU热插拔时不释放缓存信息内存，提高效率
3. **延迟分配**: 只有在需要时才分配和填充缓存信息
4. **共享信息**: 多个CPU可以共享相同的缓存信息，减少内存使用

### 兼容性分析

1. **向后兼容**: 不影响现有的SMP系统功能
2. **架构一致**: 与ARM、x86等其他架构保持一致的接口
3. **配置无关**: 在SMP和非SMP配置下都能正常工作
4. **设备树兼容**: 支持标准的设备树缓存描述格式

这个patch的设计充分考虑了系统的复杂性和各种使用场景，是一个经过深思熟虑的技术解决方案。