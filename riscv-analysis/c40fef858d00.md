commit c40fef858d002fb027033c572ac8bdf8756a2c6b
Author: Sami Tolvanen <samitolvanen@google.com>
Date:   Wed Sep 27 22:48:03 2023 +0000

    riscv: Use separate IRQ shadow call stacks

    When both CONFIG_IRQ_STACKS and SCS are enabled, also use a separate
    per-CPU shadow call stack.

    Signed-off-by: Sami Tolvanen <samitolvanen@google.com>
    Tested-by: Nathan Chancellor <nathan@kernel.org>
    Link: https://lore.kernel.org/r/20230927224757.1154247-13-samitolvanen@google.com
    Signed-off-by: Palmer Dabbelt <palmer@rivosinc.com>

diff --git a/arch/riscv/include/asm/scs.h b/arch/riscv/include/asm/scs.h
index 94726ea773e3..0e45db78b24b 100644
--- a/arch/riscv/include/asm/scs.h
+++ b/arch/riscv/include/asm/scs.h
@@ -13,6 +13,11 @@
 	XIP_FIXUP_OFFSET gp
 .endm

+/* Load the per-CPU IRQ shadow call stack to gp. */
+.macro scs_load_irq_stack tmp
+	load_per_cpu gp, irq_shadow_call_stack_ptr, \tmp
+.endm
+
 /* Load task_scs_sp(current) to gp. */
 .macro scs_load_current
 	REG_L	gp, TASK_TI_SCS_SP(tp)
@@ -34,6 +39,8 @@

 .macro scs_load_init_stack
 .endm
+.macro scs_load_irq_stack tmp
+.endm
 .macro scs_load_current
 .endm
 .macro scs_load_current_if_task_changed prev
diff --git a/arch/riscv/kernel/entry.S b/arch/riscv/kernel/entry.S
index 52793193a763..3a0db310325a 100644
--- a/arch/riscv/kernel/entry.S
+++ b/arch/riscv/kernel/entry.S
@@ -237,12 +237,19 @@ SYM_FUNC_START(call_on_irq_stack)
 	REG_S	s0, STACKFRAME_FP(sp)
 	addi	s0, sp, STACKFRAME_SIZE_ON_STACK

+	/* Switch to the per-CPU shadow call stack */
+	scs_save_current
+	scs_load_irq_stack t0
+
 	/* Switch to the per-CPU IRQ stack and call the handler */
 	load_per_cpu t0, irq_stack_ptr, t1
 	li	t1, IRQ_STACK_SIZE
 	add	sp, t0, t1
 	jalr	a1

+	/* Switch back to the thread shadow call stack */
+	scs_load_current
+
 	/* Switch back to the thread stack and restore ra and s0 */
 	addi	sp, s0, -STACKFRAME_SIZE_ON_STACK
 	REG_L	ra, STACKFRAME_RA(sp)
diff --git a/arch/riscv/kernel/irq.c b/arch/riscv/kernel/irq.c
index 95dafdcbd135..7bfea97ee7e7 100644
--- a/arch/riscv/kernel/irq.c
+++ b/arch/riscv/kernel/irq.c
@@ -9,6 +9,7 @@
 #include <linux/irqchip.h>
 #include <linux/irqdomain.h>
 #include <linux/module.h>
+#include <linux/scs.h>
 #include <linux/seq_file.h>
 #include <asm/sbi.h>
 #include <asm/smp.h>
@@ -34,6 +35,24 @@ EXPORT_SYMBOL_GPL(riscv_get_intc_hwnode);
 #ifdef CONFIG_IRQ_STACKS
 #include <asm/irq_stack.h>

+DECLARE_PER_CPU(ulong *, irq_shadow_call_stack_ptr);
+
+#ifdef CONFIG_SHADOW_CALL_STACK
+DEFINE_PER_CPU(ulong *, irq_shadow_call_stack_ptr);
+#endif
+
+static void init_irq_scs(void)
+{
+	int cpu;
+
+	if (!scs_is_enabled())
+		return;
+
+	for_each_possible_cpu(cpu)
+		per_cpu(irq_shadow_call_stack_ptr, cpu) =
+			scs_alloc(cpu_to_node(cpu));
+}
+
 DEFINE_PER_CPU(ulong *, irq_stack_ptr);

 #ifdef CONFIG_VMAP_STACK
@@ -76,6 +95,7 @@ void do_softirq_own_stack(void)
 #endif /* CONFIG_HAVE_SOFTIRQ_ON_OWN_STACK */

 #else
+static void init_irq_scs(void) {}
 static void init_irq_stacks(void) {}
 #endif /* CONFIG_IRQ_STACKS */

@@ -87,6 +107,7 @@ int arch_show_interrupts(struct seq_file *p, int prec)

 void __init init_IRQ(void)
 {
+	init_irq_scs();
 	init_irq_stacks();
 	irqchip_init();
 	if (!handle_arch_irq)


mygit
我需要查找c40fef858d00这个commit的详细信息，包括它的修改内容、背景和相关历史。

linux-stable
终端
git show c40fef858d00
现在我需要查看这个commit的完整信息，包括commit message和作者信息。

linux-stable
终端
git log --format=fuller -1 c40fef858d00
我需要查看这个patch的相关背景，包括它所属的patch系列和相关的Shadow Call Stack功能。

linux-stable
终端
git log --oneline --grep="shadow call stack" --grep="SCS" --grep="IRQ.*stack" --all -10
让我搜索更具体的Shadow Call Stack相关的commits。

linux-stable
终端
git log --oneline --grep="shadow call" --all -20
让我查看这个commit所在的patch系列，通过查看同一时间段的相关commits。

linux-stable
终端
git log --oneline --author="Sami Tolvanen" --since="2023-09-01" --until="2023-10-31" --all
现在我需要查看这个patch系列的完整信息，特别是82982fdd5133这个commit，它是IRQ stack switching的重构。

linux-stable
终端
git show 82982fdd5133
让我查看Shadow Call Stack的实现commit d1584d791a29。

linux-stable
终端
git show d1584d791a29
让我查看这个patch系列的邮件链接，了解更多背景信息。

linux-stable
终端
git log --format="%H %s" --author="Sami Tolvanen" --since="2023-09-01" --until="2023-10-31" | head -10
让我查看这些commits的详细信息，了解整个patch系列的背景。

linux-stable
终端
git log --format="%H %s" --author="Sami Tolvanen" --since="2023-09-01" --until="2023-10-31"
让我直接查看这些commits的详细信息。

linux-stable
终端
git log --oneline --author="Sami Tolvanen" --since="2023-09-01" --until="2023-10-31"
让我查看Shadow Call Stack的相关文档和配置信息。

在工作区搜索 'Shadow Call Stack SCS configuration and documentation in RISC-V architecture'
现在让我查看RISC-V架构中Shadow Call Stack的具体实现文件。

arch\riscv\include\asm\scs.h
1-100
让我搜索RISC-V架构中SCS相关的头文件。

在工作区搜索 'scs\.h'
让我搜索RISC-V中SCS相关的宏定义和实现。

在工作区搜索 'scs_'
让我查看这个commit涉及的具体文件内容，了解IRQ shadow call stack的实现。

arch\riscv\include\asm\irq_stack.h
1-50
让我查看RISC-V的entry.S文件，了解IRQ处理和SCS的集成。

arch\riscv\kernel\entry.S
100-200
让我查看IRQ处理相关的汇编代码，特别是call_on_irq_stack函数的实现。

在工作区搜索 'call_on_irq_stack'
现在让我查看当前版本中call_on_irq_stack函数的完整实现。

arch\riscv\kernel\entry.S
250-308
让我搜索call_on_irq_stack函数在当前代码中的定义位置。

在工作区搜索 'SYM_FUNC_START\(call_on_irq_stack\)'
让我查看arch/riscv/kernel目录下的所有汇编文件，寻找call_on_irq_stack的定义。

linux-stable\arch\riscv\kernel
让我查看irq.c文件，看看call_on_irq_stack函数是否在那里定义。

在工作区搜索 'call_on_irq_stack'
c40fef858d00 patch详细分析
基本信息
Commit ID: c40fef858d00
标题: "riscv: Use separate IRQ shadow call stacks"
作者: Sami Tolvanen samitolvanen@google.com
提交时间: 2023年9月27日
合并时间: 2023年10月27日 (Palmer Dabbelt)
功能描述
这个patch为RISC-V架构实现了**IRQ专用的Shadow Call Stack (SCS)**支持。当同时启用CONFIG_IRQ_STACKS和CONFIG_SHADOW_CALL_STACK时，系统会为每个CPU分配独立的shadow call stack用于中断处理。

技术背景
Shadow Call Stack (SCS) 简介
Shadow Call Stack是一种安全机制，通过维护一个独立的栈来保护函数返回地址，防止被攻击者覆盖。编译器会在函数调用时将返回地址同时保存到普通栈和shadow栈中，返回时进行验证。

为什么需要IRQ专用的SCS？
1.
栈切换问题: 当发生中断时，内核会从线程栈切换到IRQ栈
2.
SCS一致性: Shadow call stack也需要相应地切换，以保持与实际执行栈的一致性
3.
安全性: 确保中断处理过程中的返回地址保护不被破坏
实现细节
1. 数据结构添加
C



// 声明每CPU的IRQ shadow call stack指针DECLARE_PER_CPU(ulong *, irq_shadow_call_stack_ptr);#ifdef CONFIG_SHADOW_CALL_STACKDEFINE_PER_CPU(ulong *, irq_shadow_call_stack_ptr);#endif
2. 初始化函数
C



static void init_irq_scs(void){    int cpu;        if (!scs_is_enabled())        return;            // 为每个CPU分配IRQ专用的shadow call stack    for_each_possible_cpu(cpu)        per_cpu(irq_shadow_call_stack_ptr, cpu) =             scs_alloc(cpu_to_node(cpu));}
3. 汇编层面的集成
在arch/riscv/kernel/entry.S中的IRQ处理路径添加了SCS切换逻辑：

Assembly



/* Switch to the per-CPU shadow call stack */scs_save_current      // 保存当前线程的SCSscs_load_irq_stack t0 // 加载IRQ专用的SCS/* 执行IRQ处理 */jalr a1/* Switch back to the thread shadow call stack */scs_load_current      // 恢复线程的SCS
前世今生 - Patch系列背景
这个patch是Sami Tolvanen在2023年9月提交的RISC-V SCS支持系列的一部分：

1.
e609b4f4252a: "riscv: Move global pointer loading to a macro" - 重构准备工作
2.
82982fdd5133: "riscv: Deduplicate IRQ stack switching" - 重构IRQ栈切换逻辑
3.
d1584d791a29: "riscv: Implement Shadow Call Stack" - 实现基础SCS支持
4.
c40fef858d00: "riscv: Use separate IRQ shadow call stacks" - 本patch，添加IRQ专用SCS
5.
245561ba6d5d: "lkdtm: Fix CFI_BACKWARD on RISC-V" - 相关测试修复
依赖关系
前置条件
82982fdd5133: 这个patch重构了IRQ栈切换，引入了call_on_irq_stack函数，为SCS集成奠定了基础
d1584d791a29: 实现了RISC-V的基础SCS支持，包括相关宏定义和初始化
编译器支持
需要编译器支持-fsanitize=shadow-call-stack标志
链接器需要支持--no-relax-gp选项
安全意义
1.
返回地址保护: 防止ROP/JOP攻击通过覆盖返回地址劫持控制流
2.
中断安全: 确保中断处理过程中的控制流完整性
3.
性能平衡: 在安全性和性能之间取得平衡，只在必要时启用
配置要求
要启用此功能，需要同时满足：

CONFIG_IRQ_STACKS=y
CONFIG_SHADOW_CALL_STACK=y
CONFIG_ARCH_SUPPORTS_SHADOW_CALL_STACK=y
总结
c40fef858d00是RISC-V架构安全增强的重要里程碑，它完善了Shadow Call Stack在中断处理场景下的支持，提高了内核的安全性。这个patch体现了现代操作系统内核在面对日益复杂的安全威胁时，如何通过硬件和编译器协作来实现深度防御。