# RISC-V Patch 分析报告

## Commit 信息

**Commit ID:** af042c457db07db4bc1baa5c22d089cab69cfc5b  
**作者:** Alexandre Ghiti <alexghiti@rivosinc.com>  
**日期:** Sun Nov 3 15:51:42 2024 +0100  
**标题:** riscv: Do not fail to build on byte/halfword operations with Zawrs  

## 1. Patch 修改内容详细分析

### 1.1 修改的文件
- `arch/riscv/include/asm/cmpxchg.h`

### 1.2 具体修改内容

在 `__cmpwait` 函数的 `switch (size)` 语句中添加了对字节(1字节)和半字(2字节)操作的处理：

```c
switch (size) {
+       case 1:
+               fallthrough;
+       case 2:
+               /* RISC-V doesn't have lr instructions on byte and half-word. */
+               goto no_zawrs;
        case 4:
                asm volatile(
                "       lr.w    %0, %1\n"
```

### 1.3 修改原理

**问题背景:**
- RISC-V架构本身不支持字节(byte)和半字(halfword)的 `lr` (Load-Reserved) 指令
- 但是 qspinlock 实现会使用 Zabha 扩展提供的原子操作，这些操作在字节和半字大小上是合法的
- 当启用 Zawrs 扩展时，`__cmpwait` 函数会尝试对所有大小执行 `lr` 指令，导致编译失败

**解决方案:**
- 对于字节(1字节)和半字(2字节)操作，直接跳转到 `no_zawrs` 标签
- 这样会回退到不使用 Zawrs 扩展的路径，使用 `RISCV_PAUSE` 指令
- 避免了编译错误，同时保持了功能的正确性

## 2. 相关代码修改的技术原理

### 2.1 RISC-V 扩展介绍

**Zawrs (Wait-on-Reservation-Set) 扩展:**
- 提供了 `wrs.nto` (Wait-on-Reservation-Set with No Timeout) 指令
- 用于在等待内存位置变化时进入低功耗状态
- 可以提高自旋锁等同步原语的效率

**Zabha (Byte and Halfword Atomic Memory Operations) 扩展:**
- 提供字节和半字的原子内存操作
- 包括原子交换、比较交换等操作
- 弥补了 RISC-V 基础指令集在小粒度原子操作上的不足

### 2.2 __cmpwait 函数分析

`__cmpwait` 函数的作用是在等待内存位置变化时进行优化：

```c
static __always_inline void __cmpwait(volatile void *ptr,
                                      unsigned long val,
                                      int size)
```

**函数逻辑:**
1. 首先检查是否支持 Zawrs 扩展
2. 根据操作大小(size)选择相应的处理方式
3. 使用 `lr` 指令加载当前值并比较
4. 如果值匹配，执行 `wrs.nto` 指令进入等待状态
5. 如果不支持 Zawrs，回退到使用 `RISCV_PAUSE` 指令

**修改前的问题:**
- 对于 size=1 和 size=2，会尝试执行 `lr.w` 或相应的字节/半字 `lr` 指令
- 但 RISC-V 架构不支持字节和半字的 `lr` 指令
- 导致编译时出错

**修改后的解决:**
- 直接跳转到 `no_zawrs` 标签，使用通用的 `RISCV_PAUSE` 方式
- 避免了不支持的指令，确保编译成功

### 2.3 qspinlock 与 Zabha 的关系

qspinlock (queued spinlock) 是一种高效的自旋锁实现：
- 使用队列来管理等待的线程，减少缓存一致性开销
- 需要原子操作来维护队列状态
- Zabha 扩展提供的字节和半字原子操作使得 qspinlock 可以更高效地工作

## 3. 相关提交分析

### 3.1 相关的 Zawrs 提交历史

通过 `git log --grep="Zawrs"` 可以看到相关提交：

1. **b8ddb0df30f9** - "riscv: Add Zawrs support for spinlocks"
   - 最初添加 Zawrs 支持的提交
   - 引入了 `__cmpwait` 函数

2. **244c18fbf64a** - "riscv: hwprobe: export Zawrs ISA extension"
   - 导出 Zawrs 扩展信息给用户空间

3. **d9708b1931fc** - "riscv: Implement smp_cond_load8/16() with Zawrs"
   - 实现了 8 位和 16 位的条件加载函数
   - 可能与当前修复相关

### 3.2 相关的 Zabha/qspinlock 提交

从提交历史可以看到：
- **64f7b77f0bd9** - "Merge patch series 'Zacas/Zabha support and qspinlocks'"
- 这个合并提交包含了 Zabha 扩展和 qspinlock 的支持

### 3.3 修复的时间线

1. 首先引入了 Zawrs 支持 (b8ddb0df30f9)
2. 然后添加了 Zabha 和 qspinlock 支持 (64f7b77f0bd9)
3. 发现了字节/半字操作与 Zawrs 的兼容性问题
4. 通过当前 patch (af042c457db0) 修复了这个问题

## 4. 技术影响和意义

### 4.1 修复的重要性

1. **编译兼容性:** 确保启用 Zawrs 扩展时代码能够正常编译
2. **功能完整性:** 保持 qspinlock 在字节和半字操作上的正确性
3. **性能考虑:** 虽然字节/半字操作不能使用 Zawrs 优化，但不影响整体性能

### 4.2 设计权衡

**优点:**
- 简单有效的修复方案
- 不影响现有功能
- 保持了代码的清晰性

**权衡:**
- 字节和半字操作无法享受 Zawrs 带来的性能优化
- 但这是架构限制，无法避免

### 4.3 未来发展

这个修复为未来的 RISC-V 扩展发展奠定了基础：
- 如果未来 RISC-V 添加了字节/半字的 `lr` 指令支持，可以很容易地修改代码
- 当前的回退机制确保了向后兼容性

## 5. 总结

这个 patch 是一个典型的架构兼容性修复：
- **问题:** RISC-V 不支持字节/半字的 `lr` 指令，但 qspinlock 需要这些操作
- **解决:** 对于不支持的操作大小，回退到通用的等待机制
- **影响:** 确保了编译成功，保持了功能正确性，虽然牺牲了部分性能优化

这种修复体现了内核开发中常见的权衡：在架构限制和功能需求之间找到平衡点，确保系统的稳定性和兼容性。