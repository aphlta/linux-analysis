# RISC-V Unaligned Access Info Messages Fix - Patch Analysis

## Commit Information
- **Commit ID**: 441016056010e50cee18633b9dc125b24feeb74d
- **Author**: Andrew Jones <ajones@ventanamicro.com>
- **Date**: Wed Apr 9 17:36:51 2025 +0200
- **Title**: riscv: Fix unaligned access info messages

## 问题描述

这个patch修复了RISC-V架构中非对齐访问信息消息的显示问题。主要解决以下两个问题：

1. **不必要的信息打印**: 即使命令行参数没有被实际使用，系统也会打印相关的信息消息
2. **缺少错误检查**: 当vector支持不可用时，使用vector参数没有给出警告

## 修改的文件

- `arch/riscv/kernel/unaligned_access_speed.c`

## 详细代码修改分析

### 1. Scalar非对齐访问处理逻辑重构

**修改前的逻辑**:
```c
if (unaligned_scalar_speed_param == RISCV_HWPROBE_MISALIGNED_SCALAR_UNKNOWN &&
    !check_unaligned_access_emulated_all_cpus()) {
    check_unaligned_access_speed_all_cpus();
} else {
    pr_info("scalar unaligned access speed set to '%s' by command line\n",
            speed_str[unaligned_scalar_speed_param]);
    for_each_online_cpu(cpu)
        per_cpu(misaligned_access_speed, cpu) = unaligned_scalar_speed_param;
}
```

**修改后的逻辑**:
```c
if (unaligned_scalar_speed_param != RISCV_HWPROBE_MISALIGNED_SCALAR_UNKNOWN) {
    pr_info("scalar unaligned access speed set to '%s' (%lu) by command line\n",
            speed_str[unaligned_scalar_speed_param], unaligned_scalar_speed_param);
    for_each_online_cpu(cpu)
        per_cpu(misaligned_access_speed, cpu) = unaligned_scalar_speed_param;
} else if (!check_unaligned_access_emulated_all_cpus()) {
    check_unaligned_access_speed_all_cpus();
}
```

**改进点**:
- 只有当参数确实被设置时（不等于UNKNOWN）才打印信息
- 在信息中添加了数值显示 `(%lu)`
- 逻辑更清晰：先检查是否有用户设置的参数，再决定是否进行自动检测

### 2. Vector非对齐访问处理逻辑重构

**新增的Vector参数验证**:
```c
if (unaligned_vector_speed_param != RISCV_HWPROBE_MISALIGNED_VECTOR_UNKNOWN) {
    if (!has_vector() &&
        unaligned_vector_speed_param != RISCV_HWPROBE_MISALIGNED_VECTOR_UNSUPPORTED) {
        pr_warn("vector support is not available, ignoring unaligned_vector_speed=%s\n",
                speed_str[unaligned_vector_speed_param]);
    } else {
        pr_info("vector unaligned access speed set to '%s' (%lu) by command line\n",
                speed_str[unaligned_vector_speed_param], unaligned_vector_speed_param);
    }
}
```

**改进点**:
- 添加了vector支持检查：当系统不支持vector但用户设置了vector参数时发出警告
- 只有在参数实际被使用时才打印信息
- 增加了参数数值的显示

**修改后的Vector处理逻辑**:
```c
if (unaligned_vector_speed_param != RISCV_HWPROBE_MISALIGNED_VECTOR_UNKNOWN) {
    for_each_online_cpu(cpu)
        per_cpu(vector_misaligned_access, cpu) = unaligned_vector_speed_param;
} else if (!check_vector_unaligned_access_emulated_all_cpus() &&
           IS_ENABLED(CONFIG_RISCV_PROBE_VECTOR_UNALIGNED_ACCESS)) {
    kthread_run(vec_check_unaligned_access_speed_all_cpus,
                NULL, "vec_check_unaligned_access_speed_all_cpus");
}
```

## 技术原理分析

### RISC-V非对齐访问机制

RISC-V架构的非对齐访问支持分为两类：

1. **Scalar非对齐访问**: 普通的标量数据非对齐访问
2. **Vector非对齐访问**: 向量指令的非对齐访问

每种访问类型都有以下几种状态：
- `UNKNOWN(0)`: 未知状态，需要运行时检测
- `EMULATED(1)`: 通过软件模拟支持
- `SLOW(2)`: 硬件支持但性能较慢
- `FAST(3)`: 硬件支持且性能良好
- `UNSUPPORTED(4)`: 不支持

### 运行时检测机制

系统启动时会进行以下检测流程：

1. **检查命令行参数**: 如果用户通过命令行指定了非对齐访问速度参数，直接使用用户设置
2. **检查模拟支持**: 如果系统配置了模拟支持，则无需硬件检测
3. **硬件性能检测**: 通过运行测试代码来检测硬件的非对齐访问性能

### hwprobe系统调用

这些信息最终会通过`riscv_hwprobe`系统调用暴露给用户空间程序，让应用程序能够：
- 了解系统的非对齐访问支持情况
- 根据硬件能力选择最优的代码路径
- 避免在不支持的系统上使用非对齐访问

## 修复的问题

### 1. 信息打印时机问题

**问题**: 原代码在else分支中无条件打印信息，即使参数值为默认的UNKNOWN状态

**影响**: 导致系统启动时打印误导性信息，让用户以为设置了命令行参数

**解决**: 只有当参数确实被用户设置（不等于UNKNOWN）时才打印

### 2. Vector支持检查缺失

**问题**: 用户可能在不支持vector的系统上设置vector相关参数，但系统没有给出警告

**影响**: 用户可能不知道参数被忽略，导致配置错误

**解决**: 添加vector支持检查，在不支持时发出警告

## 相关提交

- **Fixes**: aecb09e091dc ("riscv: Add parameter for skipping access speed tests")
- **Reported-by**: Geert Uytterhoeven <geert@linux-m68k.org>
- **Tested-by**: Geert Uytterhoeven <geert+renesas@glider.be>
- **Tested-by**: Alexandre Ghiti <alexghiti@rivosinc.com>
- **Reviewed-by**: Alexandre Ghiti <alexghiti@rivosinc.com>

## Bug报告链接

- https://lore.kernel.org/all/CAMuHMdVEp2_ho51gkpLLJG2HimqZ1gZ0fa=JA4uNNZjFFqaPMg@mail.gmail.com/
- https://lore.kernel.org/all/CAMuHMdWVMP0MYCLFq+b7H_uz-2omdFiDDUZq0t_gw0L9rrJtkQ@mail.gmail.com/

## 影响和意义

1. **用户体验改善**: 减少了误导性的启动信息，只在真正需要时显示相关信息
2. **错误检测增强**: 增加了对无效配置的检测和警告
3. **代码逻辑优化**: 使代码逻辑更清晰，更容易理解和维护
4. **调试信息完善**: 在信息中添加了数值显示，便于调试

这个patch虽然看起来是一个小的修复，但它体现了内核开发中对用户体验和代码质量的重视，确保系统信息的准确性和有用性。