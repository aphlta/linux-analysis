# Patch Analysis: 67a5ba8f742f

## 基本信息

**Commit ID**: 67a5ba8f742f247bc83e46dd2313c142b1383276  
**作者**: Pu Lehui <pulehui@huawei.com>  
**日期**: Mon Mar 17 03:12:14 2025 +0000  
**标题**: riscv: fgraph: Fix stack layout to match __arch_ftrace_regs argument of ftrace_return_to_handler

## 问题描述

### 报告的问题
Naresh Kamboju报告了在RISC-V平台上运行LTP trace ftrace_stress_test.sh时出现"Bad frame pointer"内核警告。

### 复现步骤
```bash
$ cd /sys/kernel/debug/tracing
$ echo 'f:myprobe do_nanosleep%return args1=$retval' > dynamic_events
$ echo 1 > events/fprobes/enable
$ echo 1 > tracing_on
$ sleep 1
```

### 错误信息
```
[  127.692888] ------------[ cut here ]------------
[  127.693755] Bad frame pointer: expected ff2000000065be50, received ba34c141e9594000
[  127.693755]   from func do_nanosleep return to ffffffff800ccb16
[  127.698699] WARNING: CPU: 1 PID: 129 at kernel/trace/fgraph.c:755 ftrace_return_to_handler+0x1b2/0x1be
```

## 修改内容分析

### 文件修改: arch/riscv/kernel/mcount.S

#### 1. 移除旧的宏定义
```asm
-#define ABI_SIZE_ON_STACK      80
```

#### 2. 修改SAVE_RET_ABI_STATE宏
**修改前**:
```asm
.macro SAVE_RET_ABI_STATE
addi    sp, sp, -ABI_SIZE_ON_STACK
REG_S   ra, 1*SZREG(sp)
REG_S   s0, 8*SZREG(sp)
REG_S   a0, 10*SZREG(sp)
REG_S   a1, 11*SZREG(sp)
addi    s0, sp, ABI_SIZE_ON_STACK
.endm
```

**修改后**:
```asm
.macro SAVE_RET_ABI_STATE
addi    sp, sp, -FREGS_SIZE_ON_STACK
REG_S   ra, FREGS_RA(sp)
REG_S   s0, FREGS_S0(sp)
REG_S   a0, FREGS_A0(sp)
REG_S   a1, FREGS_A1(sp)
addi    s0, sp, FREGS_SIZE_ON_STACK
.endm
```

#### 3. 修改RESTORE_RET_ABI_STATE宏
**修改前**:
```asm
.macro RESTORE_RET_ABI_STATE
REG_L   ra, 1*SZREG(sp)
REG_L   s0, 8*SZREG(sp)
REG_L   a0, 10*SZREG(sp)
REG_L   a1, 11*SZREG(sp)
addi    sp, sp, ABI_SIZE_ON_STACK
.endm
```

**修改后**:
```asm
.macro RESTORE_RET_ABI_STATE
REG_L   ra, FREGS_RA(sp)
REG_L   s0, FREGS_S0(sp)
REG_L   a0, FREGS_A0(sp)
REG_L   a1, FREGS_A1(sp)
addi    sp, sp, FREGS_SIZE_ON_STACK
.endm
```

## 技术原理分析

### 1. 栈布局不匹配问题

原始代码使用硬编码的偏移量和栈大小:
- `ABI_SIZE_ON_STACK = 80`
- 寄存器偏移使用固定计算: `1*SZREG`, `8*SZREG`, `10*SZREG`, `11*SZREG`

这种硬编码方式与`__arch_ftrace_regs`结构体的实际布局不匹配，导致:
1. **栈帧指针错误**: 保存和恢复的栈帧指针位置不正确
2. **寄存器偏移错误**: 寄存器在栈中的位置与预期不符
3. **栈大小不匹配**: 分配的栈空间与实际需要的不一致

### 2. FREGS_*宏的定义

在`arch/riscv/kernel/asm-offsets.c`中定义:
```c
#ifdef CONFIG_DYNAMIC_FTRACE_WITH_ARGS
DEFINE(FREGS_SIZE_ON_STACK, ALIGN(sizeof(struct __arch_ftrace_regs), STACK_ALIGN));
DEFINE(FREGS_EPC,     offsetof(struct __arch_ftrace_regs, epc));
DEFINE(FREGS_RA,      offsetof(struct __arch_ftrace_regs, ra));
DEFINE(FREGS_SP,      offsetof(struct __arch_ftrace_regs, sp));
DEFINE(FREGS_S0,      offsetof(struct __arch_ftrace_regs, s0));
DEFINE(FREGS_T1,      offsetof(struct __arch_ftrace_regs, t1));
DEFINE(FREGS_A0,      offsetof(struct __arch_ftrace_regs, a0));
DEFINE(FREGS_A1,      offsetof(struct __arch_ftrace_regs, a1));
// ... 其他寄存器
#endif
```

### 3. __arch_ftrace_regs结构体

在`arch/riscv/include/asm/ftrace.h`中定义:
```c
struct __arch_ftrace_regs {
    unsigned long epc;
    unsigned long ra;
    unsigned long sp;
    unsigned long s0;
    unsigned long t1;
    union {
        unsigned long args[8];
        struct {
            unsigned long a0;
            unsigned long a1;
            unsigned long a2;
            unsigned long a3;
            unsigned long a4;
            unsigned long a5;
            unsigned long a6;
            unsigned long a7;
        };
    };
};
```

## 修复原理

### 1. 使用编译时计算的偏移量
- **FREGS_SIZE_ON_STACK**: 根据`__arch_ftrace_regs`结构体大小和栈对齐要求计算
- **FREGS_RA, FREGS_S0, FREGS_A0, FREGS_A1**: 使用`offsetof`宏计算精确偏移量

### 2. 确保栈布局一致性
修复后的代码确保:
1. **栈大小匹配**: `FREGS_SIZE_ON_STACK`与`__arch_ftrace_regs`结构体大小一致
2. **寄存器位置精确**: 每个寄存器在栈中的位置与结构体中的偏移量完全匹配
3. **栈对齐正确**: 遵循RISC-V ABI的栈对齐要求

### 3. 解决frame pointer验证失败
`ftrace_return_to_handler`函数会验证frame pointer的正确性:
- 期望的frame pointer值基于`__arch_ftrace_regs`结构体布局计算
- 修复后确保保存和恢复的frame pointer位置正确
- 消除"Bad frame pointer"警告

## 相关提交分析

### 前置提交: e8eb8e1bdae9
**标题**: riscv: fgraph: Select HAVE_FUNCTION_GRAPH_TRACER depends on HAVE_DYNAMIC_FTRACE_WITH_ARGS

**作用**: 确保function graph tracer只在支持DYNAMIC_FTRACE_WITH_ARGS时启用，为本patch提供了必要的基础设施。

### 根本原因提交: a3ed4157b7d8
**标题**: fgraph: Replace fgraph_ret_regs with ftrace_regs

**影响**: 这个提交改变了fgraph的实现，要求栈布局与`ftrace_regs`（在RISC-V上是`__arch_ftrace_regs`）完全匹配。

## 影响范围

### 1. 功能影响
- **修复function graph tracer**: 解决在RISC-V上的崩溃问题
- **提高稳定性**: 消除frame pointer验证失败
- **确保兼容性**: 与新的fgraph基础设施保持一致

### 2. 性能影响
- **无性能损失**: 修改仅涉及栈布局，不影响执行效率
- **编译时计算**: 使用编译时确定的偏移量，运行时无额外开销

### 3. 维护性改进
- **消除硬编码**: 使用结构体偏移量替代魔数
- **自动同步**: 结构体变化时偏移量自动更新
- **类型安全**: 编译时验证偏移量正确性

## 测试验证

### 1. 回归测试
- **LTP ftrace_stress_test.sh**: 原始失败的测试用例
- **Function graph tracer**: 各种ftrace功能测试
- **Frame pointer验证**: 确保无"Bad frame pointer"警告

### 2. 兼容性测试
- **不同RISC-V配置**: 32位和64位平台
- **各种编译器**: GCC和Clang
- **优化级别**: 不同的编译优化设置

## 总结

这个patch通过以下方式修复了RISC-V平台上function graph tracer的栈布局问题:

1. **替换硬编码偏移量**: 使用编译时计算的精确偏移量
2. **统一栈布局**: 确保与`__arch_ftrace_regs`结构体完全匹配
3. **提高可维护性**: 消除魔数，使用类型安全的偏移量计算
4. **解决兼容性问题**: 适配新的fgraph基础设施要求

修复后，RISC-V平台的function graph tracer能够正常工作，不再出现frame pointer验证失败的问题，为内核调试和性能分析提供了可靠的工具支持。