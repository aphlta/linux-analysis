# RISC-V vmemmap地址越界问题修复分析

## Commit信息
- **Commit ID**: f754f27e98f8
- **标题**: riscv: mm: Fix the out of bound issue of vmemmap address
- **作者**: Xu Lu <luxu.kernel@bytedance.com>
- **提交者**: Palmer Dabbelt <palmer@rivosinc.com>
- **提交日期**: 2025-01-08
- **修复的commit**: a11dd49dcb93 ("riscv: Sparse-Memory/vmemmap out-of-bounds fix")

## 问题描述

### 背景
在RISC-V架构的sparse vmemmap模型中，vmemmap的虚拟地址计算公式为：
```c
((struct page *)VMEMMAP_START - (phys_ram_base >> PAGE_SHIFT))
```

而struct page的虚拟地址通过偏移量计算：
```c
(vmemmap + (pfn))
```

### 问题根源
当初始化struct pages时，内核实际上从`phys_ram_base`所属的同一个section的第一个页面开始。如果第一个页面的物理地址不是`(phys_ram_base >> PAGE_SHIFT)`，那么在计算其struct page的虚拟地址时会得到一个低于`VMEMMAP_START`的地址。

### 具体示例
假设`phys_ram_base`从0x82000000开始，对应pfn为0x82000，但同一section中的第一个页面实际上是pfn 0x80000。在`init_unavailable_range()`期间，会为pfn 0x80000初始化struct page，其虚拟地址为：
```
((struct page *)VMEMMAP_START - 0x2000)
```
这个地址低于`VMEMMAP_START`，同时也低于`PCI_IO_END`，造成地址越界。

## 代码修改分析

### 1. 新增变量定义
在`arch/riscv/mm/init.c`中新增：
```c
#ifdef CONFIG_SPARSEMEM_VMEMMAP
#define VMEMMAP_ADDR_ALIGN     (1ULL << SECTION_SIZE_BITS)

unsigned long vmemmap_start_pfn __ro_after_init;
EXPORT_SYMBOL(vmemmap_start_pfn);
#endif
```

**分析**：
- `VMEMMAP_ADDR_ALIGN`定义为section大小对齐（2^27 = 128MB）
- `vmemmap_start_pfn`是新引入的全局变量，用于替代直接使用`phys_ram_base`
- 使用`__ro_after_init`确保初始化后只读

### 2. vmemmap宏定义修改
在`arch/riscv/include/asm/pgtable.h`中：
```c
// 修改前
#define vmemmap ((struct page *)VMEMMAP_START - (phys_ram_base >> PAGE_SHIFT))

// 修改后  
#define vmemmap ((struct page *)VMEMMAP_START - vmemmap_start_pfn)
```

**分析**：
- 直接使用`vmemmap_start_pfn`替代`(phys_ram_base >> PAGE_SHIFT)`
- 确保vmemmap基地址计算的准确性

### 3. 初始化逻辑修改

#### 在setup_bootmem()函数中：
```c
if (!IS_ENABLED(CONFIG_XIP_KERNEL)) {
    phys_ram_base = memblock_start_of_DRAM() & PMD_MASK;
#ifdef CONFIG_SPARSEMEM_VMEMMAP
    vmemmap_start_pfn = round_down(phys_ram_base, VMEMMAP_ADDR_ALIGN) >> PAGE_SHIFT;
#endif
}
```

#### 在setup_vm()函数中（XIP_KERNEL情况）：
```c
phys_ram_base = CONFIG_PHYS_RAM_BASE;
#ifdef CONFIG_SPARSEMEM_VMEMMAP
vmemmap_start_pfn = round_down(phys_ram_base, VMEMMAP_ADDR_ALIGN) >> PAGE_SHIFT;
#endif
```

**分析**：
- 使用`round_down(phys_ram_base, VMEMMAP_ADDR_ALIGN)`确保按section边界对齐
- 在两种内核配置（普通内核和XIP内核）下都正确初始化
- 确保`vmemmap_start_pfn`总是指向section的起始pfn

## 修复原理

### 核心思想
通过引入`vmemmap_start_pfn`变量，确保vmemmap的计算基于section对齐的起始pfn，而不是直接使用`phys_ram_base`。

### 对齐机制
1. **Section对齐**：`VMEMMAP_ADDR_ALIGN = 1ULL << SECTION_SIZE_BITS = 1ULL << 27 = 128MB`
2. **向下对齐**：`round_down(phys_ram_base, VMEMMAP_ADDR_ALIGN)`确保起始地址是section边界
3. **PFN转换**：`>> PAGE_SHIFT`将物理地址转换为页帧号

### 地址空间布局
修复后的vmemmap地址计算：
```
vmemmap_va = VMEMMAP_START - vmemmap_start_pfn * sizeof(struct page)
struct_page_va = vmemmap_va + pfn * sizeof(struct page)
```

这确保了即使是section中的第一个页面，其struct page的虚拟地址也不会低于`VMEMMAP_START`。

## 相关提交历史

### 原始问题引入
- **Commit**: d95f1a542c3d ("RISC-V: Implement sparsemem")
- 最初实现的sparsemem支持存在地址计算问题

### 第一次修复尝试
- **Commit**: a11dd49dcb93 ("riscv: Sparse-Memory/vmemmap out-of-bounds fix")
- **作者**: Dimitris Vlachos
- **修改**: `#define vmemmap ((struct page *)VMEMMAP_START - (phys_ram_base >> PAGE_SHIFT))`
- **问题**: 仍然存在section内第一个页面地址越界的问题

### 最终修复
- **Commit**: f754f27e98f8 (当前分析的patch)
- **作者**: Xu Lu
- **方案**: 引入`vmemmap_start_pfn`变量，确保section对齐

## 影响范围

### 受影响的配置
- `CONFIG_SPARSEMEM_VMEMMAP=y`
- RISC-V 64位架构
- 物理内存起始地址不在section边界的系统

### 修复效果
1. **消除地址越界**：确保所有struct page的虚拟地址都在合法范围内
2. **提高稳定性**：避免访问非法内存区域导致的系统崩溃
3. **保持性能**：修复不影响正常的内存管理性能

## 技术细节

### SECTION_SIZE_BITS
- 在RISC-V中定义为27，即128MB的section大小
- 这是sparsemem模型中内存管理的基本单位

### round_down宏
确保地址按指定边界向下对齐：
```c
#define round_down(x, y) ((x) & ~((y) - 1))
```

### __ro_after_init属性
- 变量在初始化阶段可写
- 初始化完成后变为只读
- 提高系统安全性，防止运行时意外修改

## 总结

这个patch通过引入`vmemmap_start_pfn`变量，彻底解决了RISC-V架构中sparse vmemmap模型的地址越界问题。修复的核心在于确保vmemmap的基地址计算基于section对齐的起始pfn，而不是直接使用可能不对齐的`phys_ram_base`。这个修复不仅解决了当前的问题，还为未来的内存布局提供了更好的兼容性和稳定性。