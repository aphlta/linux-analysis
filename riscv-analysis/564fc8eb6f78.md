# RISC-V Signal Frame Size 修复分析 - Commit 564fc8eb6f78

## 基本信息

- **Commit ID**: 564fc8eb6f78e01292ff10801f318feae6153fdd
- **作者**: Yong-Xuan Wang <yongxuan.wang@sifive.com>
- **提交日期**: 2024年12月20日
- **标题**: riscv: signal: fix signal_minsigstksz
- **修复的问题**: e92f469b0771 ("riscv: signal: Report signal frame size to userspace via auxv")

## 问题描述

### 核心问题

`init_rt_signal_env()` 函数在 `apply_boot_alternatives()` 之前被调用，导致在该函数内使用与alternative机制相关的API检查扩展可用性时无法获得预期效果。这会导致 `signal_minsigstksz` 计算不正确。

### 问题根源

1. **调用顺序问题**: 在 `arch/riscv/kernel/setup.c` 中，`init_rt_signal_env()` 在 `apply_boot_alternatives()` 之前调用
2. **Alternative机制依赖**: `has_vector()` 函数依赖于alternative机制来正确检测vector扩展的可用性
3. **Signal frame size计算错误**: 由于vector扩展检测失败，导致signal frame size计算不准确

## 代码修改分析

### 修改内容

```c
// arch/riscv/kernel/setup.c
void __init setup_arch(char **cmdline_p)
{
    // ... 其他代码 ...
    
    riscv_init_cbo_blocksizes();
    riscv_fill_hwcap();
-   init_rt_signal_env();
    apply_boot_alternatives();
+   init_rt_signal_env();
    
    // ... 其他代码 ...
}
```

### 修改原理

通过调整函数调用顺序，确保在 `init_rt_signal_env()` 执行时，alternative机制已经完成初始化，从而使 `has_vector()` 能够正确检测vector扩展的可用性。

## 函数实现原理分析

### init_rt_signal_env() 函数

**位置**: `arch/riscv/kernel/signal.c:469`

```c
void __init init_rt_signal_env(void)
{
    riscv_v_sc_size = sizeof(struct __riscv_ctx_hdr) +
                      sizeof(struct __sc_riscv_v_state) + riscv_v_vsize;
    /*
     * Determine the stack space required for guaranteed signal delivery.
     * The signal_minsigstksz will be populated into the AT_MINSIGSTKSZ entry
     * in the auxiliary array at process startup.
     */
    signal_minsigstksz = get_rt_frame_size(true);
}
```

**功能**:
1. 计算vector扩展的signal context大小 (`riscv_v_sc_size`)
2. 通过 `get_rt_frame_size(true)` 计算最小signal stack大小
3. 设置 `signal_minsigstksz`，该值会通过auxv传递给用户空间

### apply_boot_alternatives() 函数

**位置**: `arch/riscv/kernel/alternative.c:180`

```c
void __init apply_boot_alternatives(void)
{
    _apply_alternatives((struct alt_entry *)__alt_start,
                       (struct alt_entry *)__alt_end,
                       RISCV_ALTERNATIVES_BOOT);
    apply_vdso_alternatives();
}
```

**功能**:
1. 应用启动时的alternative patches
2. 处理VDSO中的alternative代码
3. 使CPU特性检测函数能够正确工作

### has_vector() 函数

**位置**: `arch/riscv/include/asm/vector.h:62`

```c
static __always_inline bool has_vector(void)
{
    return riscv_has_extension_unlikely(RISCV_ISA_EXT_ZVE32X);
}
```

**功能**:
- 检测RISC-V vector扩展 (ZVE32X) 的可用性
- 依赖于alternative机制来进行运行时检测
- 在alternative patches应用之前，该函数可能返回错误结果

### get_rt_frame_size() 函数

**位置**: `arch/riscv/kernel/signal.c:207`

```c
static size_t get_rt_frame_size(bool cal_all)
{
    struct rt_sigframe __user *frame;
    size_t frame_size;
    size_t total_context_size = 0;

    frame_size = sizeof(*frame);

    if (has_vector()) {
        if (cal_all || riscv_v_vstate_query(task_pt_regs(current)))
            total_context_size += riscv_v_sc_size;
    }

    frame_size += total_context_size;
    return frame_size;
}
```

**功能**:
1. 计算signal frame的总大小
2. 当 `cal_all=true` 时，包含所有可能的扩展context大小
3. 当 `cal_all=false` 时，只包含当前任务使用的扩展context

## 相关提交历史分析

### 引入问题的提交: e92f469b0771

**标题**: "riscv: signal: Report signal frame size to userspace via auxv"

**主要变更**:
1. 修改 `get_rt_frame_size()` 函数，添加 `cal_all` 参数
2. 在 `init_rt_signal_env()` 中调用 `get_rt_frame_size(true)` 设置 `signal_minsigstksz`
3. 通过auxv向用户空间报告signal frame大小

**问题**: 该提交没有考虑到alternative机制的初始化顺序，导致vector扩展检测失败。

### 相关修复提交: aa49bc2ca852

**标题**: "riscv: signal: fix signal frame size"

**修复内容**: 移除了signal context中不必要的END header预留空间，因为 `__riscv_extra_ext_header` 已经包含了空的context header。

## 技术影响分析

### 修复前的问题

1. **错误的signal_minsigstksz**: 由于 `has_vector()` 返回false，导致计算的最小stack大小不包含vector context
2. **用户空间影响**: 通过AT_MINSIGSTKSZ传递给用户空间的值不正确
3. **潜在的stack overflow**: 如果用户空间基于错误的最小值分配signal stack，可能导致overflow

### 修复后的改进

1. **正确的扩展检测**: alternative机制初始化后，`has_vector()` 能正确检测vector扩展
2. **准确的frame size**: signal frame大小计算包含所有必要的扩展context
3. **用户空间兼容性**: 用户空间程序能获得正确的最小signal stack大小

## Alternative机制原理

RISC-V的alternative机制允许在运行时根据CPU特性动态替换代码段：

1. **编译时**: 编译器生成包含alternative代码的特殊段
2. **启动时**: `apply_boot_alternatives()` 根据检测到的CPU特性应用相应的patches
3. **运行时**: CPU特性检测函数能够正确返回硬件支持情况

## 总结

这个patch通过简单的函数调用顺序调整，解决了一个关键的初始化依赖问题。它确保了：

1. **正确的初始化顺序**: alternative机制在signal环境初始化之前完成
2. **准确的特性检测**: vector扩展检测能够正确工作
3. **正确的signal frame大小**: 用户空间能获得准确的最小signal stack大小

这个修复对于支持RISC-V vector扩展的系统至关重要，确保了signal处理的正确性和用户空间程序的稳定性。