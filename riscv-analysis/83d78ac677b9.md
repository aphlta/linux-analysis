# RISC-V Hugetlb PTE数量获取修复分析 (83d78ac677b9)

## 1. 基本信息

**Commit ID:** 83d78ac677b9fdd8ea763507c6fe02d6bf415f3a  
**作者:** Alexandre Ghiti <alexghiti@rivosinc.com>  
**提交日期:** 2025年3月17日  
**标题:** riscv: Fix hugetlb retrieval of number of ptes in case of !present pte

## 2. 问题背景

### 2.1 Svnapot扩展简介

RISC-V的Svnapot(Standard Vector Extension for Naturally Aligned Power-of-Two)扩展允许使用连续的页表项(PTE)来映射大页，提高内存管理效率。这个扩展在commit 82a1a1f3bfb6中被引入到Linux内核的hugetlb实现中。

### 2.2 核心问题

在某些hugetlb函数中，当PTE不存在(not present)时，不能使用PTE的值来获取映射的大小，因为：

1. **PTE不存在时的状态**: 当PTE标记为不存在时，其内容可能不包含有效的大小信息
2. **Napot信息丢失**: 不存在的PTE中的napot相关位可能已被清除或无效
3. **错误的PTE数量计算**: 基于无效PTE计算出的连续PTE数量可能导致内存操作错误

### 2.3 ARM64的类似修复

这个问题最初在ARM64架构中被Ryan Roberts发现并修复(链接: https://lore.kernel.org/all/20250217140419.1702389-1-ryan.roberts@arm.com/)，RISC-V架构存在相同的问题模式。

## 3. 修改内容详细分析

### 3.1 引入新的辅助函数

```c
static int num_contig_ptes_from_size(unsigned long sz, size_t *pgsize)
{
    unsigned long hugepage_shift;

    if (sz >= PGDIR_SIZE)
        hugepage_shift = PGDIR_SHIFT;
    else if (sz >= P4D_SIZE)
        hugepage_shift = P4D_SHIFT;
    else if (sz >= PUD_SIZE)
        hugepage_shift = PUD_SHIFT;
    else if (sz >= PMD_SIZE)
        hugepage_shift = PMD_SHIFT;
    else
        hugepage_shift = PAGE_SHIFT;

    *pgsize = 1 << hugepage_shift;

    return sz >> hugepage_shift;
}
```

**功能说明:**
- 根据给定的大小(sz)参数计算需要的连续PTE数量
- 同时返回对应的页面大小(pgsize)
- 不依赖PTE内容，避免了在PTE不存在时的错误计算

### 3.2 set_huge_pte_at函数修改

**修改前:**
```c
void set_huge_pte_at(struct mm_struct *mm,
                     unsigned long addr,
                     pte_t *ptep,
                     pte_t pte,
                     unsigned long sz)
{
    unsigned long hugepage_shift, pgsize;
    int i, pte_num;

    if (sz >= PGDIR_SIZE)
        hugepage_shift = PGDIR_SHIFT;
    else if (sz >= P4D_SIZE)
        hugepage_shift = P4D_SHIFT;
    else if (sz >= PUD_SIZE)
        hugepage_shift = PUD_SHIFT;
    else if (sz >= PMD_SIZE)
        hugepage_shift = PMD_SHIFT;
    else
        hugepage_shift = PAGE_SHIFT;

    pte_num = sz >> hugepage_shift;
    pgsize = 1 << hugepage_shift;
    // ...
}
```

**修改后:**
```c
void set_huge_pte_at(struct mm_struct *mm,
                     unsigned long addr,
                     pte_t *ptep,
                     pte_t pte,
                     unsigned long sz)
{
    size_t pgsize;
    int i, pte_num;

    pte_num = num_contig_ptes_from_size(sz, &pgsize);
    // ...
}
```

**改进点:**
- 消除了重复的大小计算逻辑
- 使用统一的辅助函数，提高代码可维护性
- pgsize类型从unsigned long改为size_t，更符合语义

### 3.3 huge_ptep_get_and_clear函数修改

**修改前:**
```c
pte_t huge_ptep_get_and_clear(struct mm_struct *mm,
                              unsigned long addr,
                              pte_t *ptep, unsigned long sz)
{
    pte_t orig_pte = ptep_get(ptep);
    int pte_num;

    if (!pte_napot(orig_pte))
        return ptep_get_and_clear(mm, addr, ptep);

    pte_num = napot_pte_num(napot_cont_order(orig_pte));

    return get_clear_contig(mm, addr, ptep, pte_num);
}
```

**修改后:**
```c
pte_t huge_ptep_get_and_clear(struct mm_struct *mm,
                              unsigned long addr,
                              pte_t *ptep, unsigned long sz)
{
    size_t pgsize;
    pte_t orig_pte = ptep_get(ptep);
    int pte_num;

    if (!pte_napot(orig_pte))
        return ptep_get_and_clear(mm, addr, ptep);

    pte_num = num_contig_ptes_from_size(sz, &pgsize);

    return get_clear_contig(mm, addr, ptep, pte_num);
}
```

**关键修复:**
- **问题根源**: 原代码使用`napot_pte_num(napot_cont_order(orig_pte))`从PTE中提取信息
- **修复方案**: 改用`num_contig_ptes_from_size(sz, &pgsize)`从size参数获取信息
- **安全性**: 即使PTE不存在或napot位无效，也能正确计算PTE数量

### 3.4 huge_pte_clear函数修改

**修改前:**
```c
void huge_pte_clear(struct mm_struct *mm,
                    unsigned long addr,
                    pte_t *ptep,
                    unsigned long sz)
{
    pte_t pte = ptep_get(ptep);
    int i, pte_num;

    if (!pte_napot(pte)) {
        pte_clear(mm, addr, ptep);
        return;
    }

    pte_num = napot_pte_num(napot_cont_order(pte));
    for (i = 0; i < pte_num; i++, addr += PAGE_SIZE, ptep++)
        pte_clear(mm, addr, ptep);
}
```

**修改后:**
```c
void huge_pte_clear(struct mm_struct *mm,
                    unsigned long addr,
                    pte_t *ptep,
                    unsigned long sz)
{
    size_t pgsize;
    pte_t pte = ptep_get(ptep);
    int i, pte_num;

    if (!pte_napot(pte)) {
        pte_clear(mm, addr, ptep);
        return;
    }

    pte_num = num_contig_ptes_from_size(sz, &pgsize);

    for (i = 0; i < pte_num; i++, addr += pgsize, ptep++)
        pte_clear(mm, addr, ptep);
}
```

**重要修复:**
1. **PTE数量计算**: 同样改用size参数而非PTE内容
2. **地址递增修复**: 从`addr += PAGE_SIZE`改为`addr += pgsize`
   - 原代码假设所有PTE都是PAGE_SIZE大小
   - 修复后正确处理不同大小的页面(PMD_SIZE, PUD_SIZE等)

### 3.5 huge_ptep_get函数的A/D位收集优化

在`huge_ptep_get`函数中，还有一个重要的修复是确保只在present的PTE上收集A/D(Access/Dirty)位：

```c
if (!pte_present(orig_pte) || !pte_napot(orig_pte))
    return orig_pte;
```

这确保了只有在PTE存在且为napot类型时才进行A/D位的聚合操作。

## 4. 修复原理深入分析

### 4.1 问题的根本原因

1. **PTE状态的不一致性**: 当PTE被标记为不存在时，其napot相关的位域可能：
   - 被清零
   - 包含陈旧的信息
   - 处于未定义状态

2. **函数接口设计缺陷**: 原始的hugetlb函数过度依赖PTE内容来推断映射大小，而忽略了已有的size参数。

3. **内存管理的时序问题**: 在某些内存管理操作中，PTE可能在函数调用时已经被清除，但size参数仍然有效。

### 4.2 修复策略的优势

1. **参数优先级**: 优先使用函数参数中的size信息，这是调用者明确提供的可靠数据
2. **状态无关性**: 不依赖PTE的当前状态，避免了状态不一致导致的错误
3. **代码统一性**: 所有相关函数使用相同的大小计算逻辑，减少了维护负担

### 4.3 内存安全性改进

修复后的代码在以下场景中更加安全：
- **页面回收**: 当页面被回收时PTE被清除，但清理操作仍需要正确的大小信息
- **内存迁移**: 在页面迁移过程中，源PTE可能已被清除
- **错误恢复**: 在某些错误处理路径中，PTE状态可能不可靠

## 5. 相关提交分析

### 5.1 被修复的原始提交

**Commit:** 82a1a1f3bfb6 ("riscv: mm: support Svnapot in hugetlb page")  
**问题**: 引入了依赖PTE内容计算大小的逻辑，在PTE不存在时会出现错误

### 5.2 ARM64的对应修复

**链接**: https://lore.kernel.org/all/20250217140419.1702389-1-ryan.roberts@arm.com/  
**作者**: Ryan Roberts  
**影响**: 证明了这是一个跨架构的通用问题模式

## 6. 技术影响评估

### 6.1 性能影响

- **正面影响**: 消除了错误的内存操作，避免了潜在的性能损失
- **开销**: 新增的`num_contig_ptes_from_size`函数调用开销极小
- **优化**: 代码重构减少了重复计算

### 6.2 稳定性改进

- **内存安全**: 防止了基于无效PTE信息的错误内存操作
- **一致性**: 确保了不同函数使用一致的大小计算逻辑
- **可靠性**: 提高了在边界条件下的系统稳定性

### 6.3 兼容性

- **向后兼容**: 修复不改变对外接口，完全向后兼容
- **架构一致**: 与ARM64的修复保持了跨架构的一致性

## 7. 测试和验证建议

### 7.1 功能测试

1. **基本hugetlb操作**: 验证大页的分配、释放、映射操作
2. **边界条件**: 测试PTE不存在时的各种操作
3. **多种页面大小**: 验证PMD_SIZE、PUD_SIZE等不同大小的处理

### 7.2 压力测试

1. **并发操作**: 多线程同时进行hugetlb操作
2. **内存压力**: 在内存不足情况下的行为
3. **页面迁移**: 验证在页面迁移过程中的正确性

### 7.3 回归测试

1. **现有功能**: 确保修复不影响现有的hugetlb功能
2. **性能基准**: 验证性能没有显著下降
3. **兼容性**: 确保与现有应用程序的兼容性

## 8. 总结

这个patch解决了RISC-V架构中hugetlb实现的一个重要安全问题。通过改用函数参数中的size信息而非PTE内容来计算连续PTE数量，修复避免了在PTE不存在时的错误行为。这个修复不仅提高了系统的稳定性和安全性，还与ARM64架构的类似修复保持了一致性，体现了良好的跨架构设计原则。

修复的核心思想是**参数优先于状态**，即优先使用调用者提供的明确参数，而不是依赖可能不可靠的内部状态。这种设计原则在系统编程中具有重要的指导意义。