# RISC-V Percpu Page First Chunk Allocator 补丁分析

## 基本信息

- **Commit ID**: 6b9f29b81b155af023da95f560f738f29722b306
- **作者**: Alexandre Ghiti <alexghiti@rivosinc.com>
- **提交日期**: 2023年12月12日
- **签名者**: Dennis Zhou <dennis@kernel.org>
- **标题**: riscv: Enable pcpu page first chunk allocator

## 补丁概述

这个补丁为RISC-V架构启用了percpu页面优先块分配器(pcpu page first chunk allocator)，作为嵌入式优先块分配器(embedding first chunk allocator)的备用方案。

## 修改内容详细分析

### 1. 配置文件修改 (arch/riscv/Kconfig)

```diff
 config NUMA
        depends on SMP && MMU
        select ARCH_SUPPORTS_NUMA_BALANCING
        select GENERIC_ARCH_NUMA
+       select HAVE_SETUP_PER_CPU_AREA
        select NEED_PER_CPU_EMBED_FIRST_CHUNK
+       select NEED_PER_CPU_PAGE_FIRST_CHUNK
        select OF_NUMA
        select USE_PERCPU_NUMA_NODE_ID
```

**修改说明**:
- 添加了 `HAVE_SETUP_PER_CPU_AREA` 配置选项
- 添加了 `NEED_PER_CPU_PAGE_FIRST_CHUNK` 配置选项

这两个配置选项的作用：
- `HAVE_SETUP_PER_CPU_AREA`: 表示架构有自己的per-cpu区域设置函数
- `NEED_PER_CPU_PAGE_FIRST_CHUNK`: 启用页面优先块分配器支持

### 2. KASAN初始化代码修改 (arch/riscv/mm/kasan_init.c)

```diff
+#ifdef CONFIG_KASAN_VMALLOC
+void __init kasan_populate_early_vm_area_shadow(void *start, unsigned long size)
+{
+       kasan_populate(kasan_mem_to_shadow(start),
+                      kasan_mem_to_shadow(start + size));
+}
+#endif
```

**修改说明**:
- 添加了 `kasan_populate_early_vm_area_shadow` 函数的RISC-V特定实现
- 这个函数用于在早期VM区域分配时填充KASAN影子内存
- 只在启用 `CONFIG_KASAN_VMALLOC` 时编译

## 技术原理分析

### 1. Percpu分配器机制

Linux内核中的percpu分配器有两种主要的首块分配策略：

1. **嵌入式分配器 (Embedding Allocator)**:
   - 将所有CPU的percpu数据嵌入到一个连续的vmalloc区域中
   - 需要vmalloc空间足够大，能容纳所有NUMA节点间的最大距离
   - 性能较好，但对vmalloc空间要求较高

2. **页面分配器 (Page Allocator)**:
   - 为每个CPU单独分配页面
   - 对vmalloc空间要求较低
   - 性能略差，但更灵活

### 2. 问题背景

根据commit 6ea529a2037c的说明，嵌入式分配器需要满足以下条件：
- vmalloc空间必须大于NUMA节点间单元的最大距离
- 在稀疏NUMA配置和小vmalloc区域(如sv39中的64GB)情况下，动态percpu数据分配可能失败

### 3. 解决方案

这个补丁通过以下方式解决问题：

1. **启用备用分配器**: 当嵌入式分配器因vmalloc空间不足而失败时，自动回退到页面分配器

2. **KASAN支持**: 添加必要的KASAN影子内存支持，确保内存安全检查正常工作

3. **配置选项**: 通过Kconfig选项控制功能的启用

### 4. 代码执行流程

当系统启动时，percpu初始化流程如下：

1. 首先尝试使用嵌入式分配器 (`pcpu_embed_first_chunk`)
2. 如果失败且启用了 `CONFIG_NEED_PER_CPU_PAGE_FIRST_CHUNK`，则回退到页面分配器 (`pcpu_page_first_chunk`)
3. 在分配过程中，如果启用了KASAN_VMALLOC，会调用 `kasan_populate_early_vm_area_shadow` 来设置影子内存

## 相关提交分析

### 1. 引用的关键提交

- **6ea529a2037c**: "percpu: make embedding first chunk allocator check vmalloc space size"
  - 这个提交在嵌入式分配器中添加了vmalloc空间大小检查
  - 当最大距离超过vmalloc空间的75%时发出警告
  - 如果有备用分配器可用，则直接失败以触发回退

- **09cea6195073**: "arm64: support page mapping percpu first chunk allocator"
  - ARM64架构的类似实现
  - 为RISC-V的实现提供了参考模板

### 2. 架构对比

这个补丁使RISC-V架构与ARM64保持一致，都支持percpu页面分配器作为备用方案。这种一致性有助于：
- 代码维护
- 跨架构的功能对等
- 解决相似的内存布局问题

## 影响和意义

### 1. 解决的问题
- **稀疏NUMA配置**: 在节点间距离很大的NUMA系统中提供可靠的percpu分配
- **小vmalloc空间**: 在sv39等地址空间受限的配置中确保系统正常启动
- **内存安全**: 通过KASAN支持确保分配的内存区域得到正确的安全检查

### 2. 性能考虑
- 页面分配器的性能略低于嵌入式分配器
- 但在无法使用嵌入式分配器的情况下，这是必要的权衡
- 大多数情况下，嵌入式分配器仍然是首选

### 3. 兼容性
- 向后兼容，不影响现有配置
- 只在需要时才启用备用分配器
- 通过配置选项控制，可以根据需要禁用

## 总结

这个补丁是一个重要的稳定性改进，它：

1. **提高了系统鲁棒性**: 在极端内存配置下仍能正常启动
2. **保持了架构一致性**: 与ARM64等其他架构保持功能对等
3. **维护了性能**: 优先使用高性能的嵌入式分配器，只在必要时回退
4. **确保了安全性**: 通过KASAN支持维护内存安全检查

这种设计体现了Linux内核在面对多样化硬件配置时的适应性和鲁棒性原则。