# Patch Analysis: 28093cfef5dd

## 基本信息

**Commit ID:** 28093cfef5dd62f4cbd537f2bdf6f0bf85309c45  
**作者:** Yao Zi <ziyao@disroot.org>  
**提交日期:** Wed Mar 26 05:14:46 2025 +0000  
**标题:** riscv/kexec_file: Handle R_RISCV_64 in purgatory relocator  

## 问题背景

### 引发问题的原始提交

**相关提交:** 58ff537109ac ("riscv: Omit optimized string routines when using KASAN")  

该提交在汇编字符串例程中引入了 `EXPORT_SYMBOL()` 调用，这些调用会产生针对 `.export_symbol` 段的 `R_RISCV_64` 重定位。由于这些例程被 RISC-V purgatory 重用，而我们的重定位器不识别这些重定位类型，导致 kexec-file-load 失败。

### 错误现象

当使用 kexec-file-load 时，会出现以下错误信息：
```
[   11.344251] kexec_image: Unknown rela relocation: 2
[   11.345972] kexec_image: Error loading purgatory ret=-8
```

错误代码 2 对应的就是 `R_RISCV_64` 重定位类型。

## 技术原理分析

### EXPORT_SYMBOL 机制

`EXPORT_SYMBOL` 宏在汇编代码中的定义（来自 `include/linux/export.h`）：

```c
#define ___EXPORT_SYMBOL(sym, license, ns...)        \
    .section ".export_symbol","a"        ASM_NL    \
    __export_symbol_##sym:            ASM_NL    \
        .asciz license            ASM_NL    \
        .ascii ns "\0"            ASM_NL    \
        __EXPORT_SYMBOL_REF(sym)    ASM_NL    \
    .previous

#ifdef CONFIG_64BIT
#define __EXPORT_SYMBOL_REF(sym)            \
    .balign 8                ASM_NL    \
    .quad sym
#else
#define __EXPORT_SYMBOL_REF(sym)            \
    .balign 4                ASM_NL    \
    .long sym
#endif
```

在 64 位 RISC-V 系统中，`__EXPORT_SYMBOL_REF(sym)` 使用 `.quad sym` 指令，这会生成一个 64 位的符号引用，链接器需要使用 `R_RISCV_64` 重定位类型来解析这个引用。

### R_RISCV_64 重定位类型

`R_RISCV_64` 是 RISC-V ELF 规范中定义的重定位类型，用于 64 位绝对地址重定位。它的处理方式很简单：
- 将符号的最终地址直接写入到重定位位置
- 公式：`*location = symbol_value`

### Kexec Purgatory 机制

Kexec purgatory 是一个小的代码段，在内核切换过程中执行。它需要：
1. 验证新内核的完整性
2. 设置新内核的执行环境
3. 跳转到新内核

Purgatory 代码会被重定位到运行时地址，因此需要一个重定位器来处理各种重定位类型。

## 代码修改详解

### 修改的文件

**文件:** `arch/riscv/kernel/elf_kexec.c`  
**函数:** `arch_kexec_apply_relocations_add()`  

### 具体修改内容

```c
case R_RISCV_64:
    *(u64 *)loc = val;
    break;
```

这个修改在重定位处理的 switch 语句中添加了对 `R_RISCV_64` 类型的支持。

### 修改位置分析

修改位置在现有的重定位类型处理之后：
- `R_RISCV_ALIGN` 和 `R_RISCV_RELAX`：这些是优化提示，不需要实际处理
- `R_RISCV_64`：新增的处理，直接将计算出的值写入目标位置

### 处理逻辑

1. `val` 变量包含了符号的最终地址（符号值 + 段基址 + 加数）
2. `loc` 指向需要重定位的内存位置
3. 直接将 64 位值写入目标位置：`*(u64 *)loc = val`

## 影响范围

### 适用平台
- **仅限 64 位 RISC-V**：32 位变体未涵盖，因为 `KEXEC_FILE` 和 `KEXEC_PURGATORY` 在 32 位 RISC-V 上不可用

### 功能影响
- **修复 kexec-file-load 功能**：解决了由于 `EXPORT_SYMBOL` 引入的重定位问题
- **保持向后兼容**：不影响现有的重定位类型处理

## 测试验证

**测试者:** Björn Töpel <bjorn@rivosinc.com>  
**审查者:** Björn Töpel <bjorn@rivosinc.com>  

该补丁已经过测试验证，确认能够解决 kexec-file-load 失败的问题。

## 相关提交链接

**Fixes:** 58ff537109ac ("riscv: Omit optimized string routines when using KASAN")  
**Link:** https://lore.kernel.org/r/20250326051445.55131-2-ziyao@disroot.org  
**Signed-off-by:** Alexandre Ghiti <alexghiti@rivosinc.com>  

## 总结

这是一个针对性的修复补丁，解决了由于在汇编代码中使用 `EXPORT_SYMBOL` 而引入的 `R_RISCV_64` 重定位类型处理缺失问题。修复方法简单直接，通过在 purgatory 重定位器中添加对 `R_RISCV_64` 的支持，确保 kexec-file-load 功能在 64 位 RISC-V 平台上正常工作。

该补丁体现了内核开发中的一个重要原则：当引入新的代码模式（如在汇编中使用 `EXPORT_SYMBOL`）时，需要确保所有相关的子系统都能正确处理由此产生的副作用。