commit 82982fdd5133fa7e0b2dfaf746d18d6f29922b82
Author: Sami Tolvanen <samitolvanen@google.com>
Date:   Wed Sep 27 22:48:00 2023 +0000

    riscv: Deduplicate IRQ stack switching

    With CONFIG_IRQ_STACKS, we switch to a separate per-CPU IRQ stack
    before calling handle_riscv_irq or __do_softirq. We currently
    have duplicate inline assembly snippets for stack switching in
    both code paths. Now that we can access per-CPU variables in
    assembly, implement call_on_irq_stack in assembly, and use that
    instead of redundant inline assembly.

    Signed-off-by: Sami Tolvanen <samitolvanen@google.com>
    Tested-by: Nathan Chancellor <nathan@kernel.org>
    Reviewed-by: Guo Ren <guoren@kernel.org>
    Link: https://lore.kernel.org/r/20230927224757.1154247-10-samitolvanen@google.com
    Signed-off-by: Palmer Dabbelt <palmer@rivosinc.com>

diff --git a/arch/riscv/include/asm/asm.h b/arch/riscv/include/asm/asm.h
index bfb4c26f113c..8e446be2d57c 100644
--- a/arch/riscv/include/asm/asm.h
+++ b/arch/riscv/include/asm/asm.h
@@ -104,6 +104,11 @@
 .endm
 #endif /* CONFIG_SMP */

+.macro load_per_cpu dst ptr tmp
+	asm_per_cpu \dst \ptr \tmp
+	REG_L \dst, 0(\dst)
+.endm
+
 	/* save all GPs except x1 ~ x5 */
 	.macro save_from_x6_to_x31
 	REG_S x6,  PT_T1(sp)
diff --git a/arch/riscv/include/asm/irq_stack.h b/arch/riscv/include/asm/irq_stack.h
index e4042d297580..6441ded3b0cf 100644
--- a/arch/riscv/include/asm/irq_stack.h
+++ b/arch/riscv/include/asm/irq_stack.h
@@ -12,6 +12,9 @@

 DECLARE_PER_CPU(ulong *, irq_stack_ptr);

+asmlinkage void call_on_irq_stack(struct pt_regs *regs,
+				  void (*func)(struct pt_regs *));
+
 #ifdef CONFIG_VMAP_STACK
 /*
  * To ensure that VMAP'd stack overflow detection works correctly, all VMAP'd
diff --git a/arch/riscv/kernel/asm-offsets.c b/arch/riscv/kernel/asm-offsets.c
index 9f535d5de33f..0af8860f9d68 100644
--- a/arch/riscv/kernel/asm-offsets.c
+++ b/arch/riscv/kernel/asm-offsets.c
@@ -14,6 +14,7 @@
 #include <asm/thread_info.h>
 #include <asm/ptrace.h>
 #include <asm/cpu_ops_sbi.h>
+#include <asm/stacktrace.h>
 #include <asm/suspend.h>

 void asm_offsets(void);
@@ -480,4 +481,8 @@ void asm_offsets(void)
 	OFFSET(KERNEL_MAP_VIRT_ADDR, kernel_mapping, virt_addr);
 	OFFSET(SBI_HART_BOOT_TASK_PTR_OFFSET, sbi_hart_boot_data, task_ptr);
 	OFFSET(SBI_HART_BOOT_STACK_PTR_OFFSET, sbi_hart_boot_data, stack_ptr);
+
+	DEFINE(STACKFRAME_SIZE_ON_STACK, ALIGN(sizeof(struct stackframe), STACK_ALIGN));
+	OFFSET(STACKFRAME_FP, stackframe, fp);
+	OFFSET(STACKFRAME_RA, stackframe, ra);
 }
diff --git a/arch/riscv/kernel/entry.S b/arch/riscv/kernel/entry.S
index 3d11aa3af105..a306562636e4 100644
--- a/arch/riscv/kernel/entry.S
+++ b/arch/riscv/kernel/entry.S
@@ -218,6 +218,36 @@ SYM_CODE_START(ret_from_fork)
 	tail syscall_exit_to_user_mode
 SYM_CODE_END(ret_from_fork)

+#ifdef CONFIG_IRQ_STACKS
+/*
+ * void call_on_irq_stack(struct pt_regs *regs,
+ * 		          void (*func)(struct pt_regs *));
+ *
+ * Calls func(regs) using the per-CPU IRQ stack.
+ */
+SYM_FUNC_START(call_on_irq_stack)
+	/* Create a frame record to save ra and s0 (fp) */
+	addi	sp, sp, -STACKFRAME_SIZE_ON_STACK
+	REG_S	ra, STACKFRAME_RA(sp)
+	REG_S	s0, STACKFRAME_FP(sp)
+	addi	s0, sp, STACKFRAME_SIZE_ON_STACK
+
+	/* Switch to the per-CPU IRQ stack and call the handler */
+	load_per_cpu t0, irq_stack_ptr, t1
+	li	t1, IRQ_STACK_SIZE
+	add	sp, t0, t1
+	jalr	a1
+
+	/* Switch back to the thread stack and restore ra and s0 */
+	addi	sp, s0, -STACKFRAME_SIZE_ON_STACK
+	REG_L	ra, STACKFRAME_RA(sp)
+	REG_L	s0, STACKFRAME_FP(sp)
+	addi	sp, sp, STACKFRAME_SIZE_ON_STACK
+
+	ret
+SYM_FUNC_END(call_on_irq_stack)
+#endif /* CONFIG_IRQ_STACKS */
+
 /*
  * Integer register context switch
  * The callee-saved registers must be saved and restored.
diff --git a/arch/riscv/kernel/irq.c b/arch/riscv/kernel/irq.c
index a8efa053c4a5..95dafdcbd135 100644
--- a/arch/riscv/kernel/irq.c
+++ b/arch/riscv/kernel/irq.c
@@ -61,35 +61,16 @@ static void init_irq_stacks(void)
 #endif /* CONFIG_VMAP_STACK */

 #ifdef CONFIG_HAVE_SOFTIRQ_ON_OWN_STACK
+static void ___do_softirq(struct pt_regs *regs)
+{
+	__do_softirq();
+}
+
 void do_softirq_own_stack(void)
 {
-#ifdef CONFIG_IRQ_STACKS
-	if (on_thread_stack()) {
-		ulong *sp = per_cpu(irq_stack_ptr, smp_processor_id())
-					+ IRQ_STACK_SIZE/sizeof(ulong);
-		__asm__ __volatile(
-		"addi	sp, sp, -"RISCV_SZPTR  "\n"
-		REG_S"  ra, (sp)		\n"
-		"addi	sp, sp, -"RISCV_SZPTR  "\n"
-		REG_S"  s0, (sp)		\n"
-		"addi	s0, sp, 2*"RISCV_SZPTR "\n"
-		"move	sp, %[sp]		\n"
-		"call	__do_softirq		\n"
-		"addi	sp, s0, -2*"RISCV_SZPTR"\n"
-		REG_L"  s0, (sp)		\n"
-		"addi	sp, sp, "RISCV_SZPTR   "\n"
-		REG_L"  ra, (sp)		\n"
-		"addi	sp, sp, "RISCV_SZPTR   "\n"
-		:
-		: [sp] "r" (sp)
-		: "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7",
-		  "t0", "t1", "t2", "t3", "t4", "t5", "t6",
-#ifndef CONFIG_FRAME_POINTER
-		  "s0",
-#endif
-		  "memory");
-	} else
-#endif
+	if (on_thread_stack())
+		call_on_irq_stack(NULL, ___do_softirq);
+	else
 		__do_softirq();
 }
 #endif /* CONFIG_HAVE_SOFTIRQ_ON_OWN_STACK */
diff --git a/arch/riscv/kernel/traps.c b/arch/riscv/kernel/traps.c
index 0063a195deca..cda6dcdb0376 100644
--- a/arch/riscv/kernel/traps.c
+++ b/arch/riscv/kernel/traps.c
@@ -352,34 +352,10 @@ static void noinstr handle_riscv_irq(struct pt_regs *regs)
 asmlinkage void noinstr do_irq(struct pt_regs *regs)
 {
 	irqentry_state_t state = irqentry_enter(regs);
-#ifdef CONFIG_IRQ_STACKS
-	if (on_thread_stack()) {
-		ulong *sp = per_cpu(irq_stack_ptr, smp_processor_id())
-					+ IRQ_STACK_SIZE/sizeof(ulong);
-		__asm__ __volatile(
-		"addi	sp, sp, -"RISCV_SZPTR  "\n"
-		REG_S"  ra, (sp)		\n"
-		"addi	sp, sp, -"RISCV_SZPTR  "\n"
-		REG_S"  s0, (sp)		\n"
-		"addi	s0, sp, 2*"RISCV_SZPTR "\n"
-		"move	sp, %[sp]		\n"
-		"move	a0, %[regs]		\n"
-		"call	handle_riscv_irq	\n"
-		"addi	sp, s0, -2*"RISCV_SZPTR"\n"
-		REG_L"  s0, (sp)		\n"
-		"addi	sp, sp, "RISCV_SZPTR   "\n"
-		REG_L"  ra, (sp)		\n"
-		"addi	sp, sp, "RISCV_SZPTR   "\n"
-		:
-		: [sp] "r" (sp), [regs] "r" (regs)
-		: "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7",
-		  "t0", "t1", "t2", "t3", "t4", "t5", "t6",
-#ifndef CONFIG_FRAME_POINTER
-		  "s0",
-#endif
-		  "memory");
-	} else
-#endif
+
+	if (IS_ENABLED(CONFIG_IRQ_STACKS) && on_thread_stack())
+		call_on_irq_stack(regs, handle_riscv_irq);
+	else
 		handle_riscv_irq(regs);

 	irqentry_exit(regs, state);



我需要查找commit 82982fdd5133的详细信息，了解这个patch的内容和背景。

linux-stable 终端

git show 82982fdd5133

现在我需要获取这个commit的完整信息，包括commit message和作者信息。

linux-stable 终端

git log -1 --pretty=fuller 82982fdd5133

我需要查看这个patch引入的新函数call_on_irq_stack的实现，以及相关的汇编代码。

在工作区搜索 'call_on_irq_stack function implementation in RISC-V architecture'

我需要查看call_on_irq_stack函数的具体实现，它应该在汇编文件中。

在工作区搜索 'call_on_irq_stack'

让我查看这个patch修改的具体文件，看看call_on_irq_stack是在哪里定义的。

arch\riscv\kernel\irq.c 1 - 50

让我继续查看这个文件的其余部分，特别是call_on_irq_stack函数的定义。

arch\riscv\kernel\irq.c 51 - 114

我需要查看这个patch引入的call_on_irq_stack函数，它应该在汇编文件中定义。让我搜索相关的汇编文件。

在工作区搜索 'call_on_irq_stack assembly function definition in RISC-V kernel entry or irq related assembly files'

我需要查找call_on_irq_stack函数的定义，它应该在某个汇编文件中。让我搜索包含这个函数的文件。

在工作区搜索 'SYM.*call_on_irq_stack'

让我查看这个patch的前后文，了解call_on_irq_stack函数是如何被引入的。

linux-stable 终端

git log --oneline --grep="call_on_irq_stack" -n 10

让我查看这个patch系列的相关commits，看看call_on_irq_stack是在哪个patch中引入的。

linux-stable 终端

git log --oneline --author="Sami Tolvanen" --since="2023-09-01" --until="2023-11-01" arch/riscv/

让我查看这个commit的父commit，看看call_on_irq_stack函数是在哪里定义的。

linux-stable 终端

git show 82982fdd5133^ --name-only

让我查看这个commit的前一个commit，看看call_on_irq_stack函数是在那里引入的。

linux-stable 终端

git show 82982fdd5133^

让我查看这个patch系列中引入call_on_irq_stack的具体commit。

linux-stable 终端

git log --oneline 82982fdd5133~10..82982fdd5133 arch/riscv/

让我查看be97d0db5f44这个commit，它应该包含了call_on_irq_stack函数的引入。

linux-stable 终端

git show be97d0db5f44

让我查看当前代码中call_on_irq_stack函数的定义，它应该在entry.S文件中。

在工作区搜索 'call_on_irq_stack:'

让我查看entry.S文件的完整内容，寻找call_on_irq_stack函数的定义。

arch\riscv\kernel\entry.S

我需要查找call_on_irq_stack函数的定义，它可能在其他汇编文件中。让我搜索所有的汇编文件。

在工作区搜索 'call_on_irq_stack'

让我查看这个patch引入的头文件，看看call_on_irq_stack是否在那里声明。

arch\riscv\include\asm\asm-prototypes.h 1 - 50

让我查看这个patch的完整diff，看看call_on_irq_stack函数是在哪里定义的。

linux-stable 终端

git show 82982fdd5133 --stat

现在我看到call_on_irq_stack函数是在entry.S文件中新增的。让我查看这个patch对entry.S的具体修改。

linux-stable 终端

git show 82982fdd5133 -- arch/riscv/kernel/entry.S

现在我需要查看这个patch对其他文件的修改，特别是头文件和asm-offsets.c的修改。

linux-stable 终端

git show 82982fdd5133 -- arch/riscv/include/asm/irq_stack.h arch/riscv/include/asm/asm.h arch/riscv/kernel/asm-offsets.c

现在让我查看这个patch的历史背景，了解IRQ stack相关的发展历程。

linux-stable 终端

git log --oneline --grep="IRQ.*stack" --since="2020-01-01" --until="2024-01-01" arch/riscv/ | head -20

让我查看RISC-V IRQ stack功能的引入历史。

linux-stable 终端

git log --oneline --grep="IRQ_STACKS" --since="2020-01-01" --until="2024-01-01" arch/riscv/

让我查看dd69d07a5a6c这个commit，了解RISC-V IRQ stack功能的引入。

linux-stable 终端

git show dd69d07a5a6c

## commit 82982fdd5133 详细分析
### 基本信息
- Commit ID : 82982fdd5133fa7e0b2dfaf746d18d6f29922b82
- 作者 : Sami Tolvanen samitolvanen@google.com
- 提交时间 : 2023年9月27日
- 标题 : riscv: Deduplicate IRQ stack switching
### 问题背景
在这个patch之前，RISC-V架构在启用 CONFIG_IRQ_STACKS 配置时，存在代码重复的问题：

1. 1.
   重复的内联汇编代码 : 在 `irq.c` 和 `traps.c` 中都有相似的内联汇编代码用于IRQ栈切换
2. 2.
   维护困难 : 两处几乎相同的汇编代码增加了维护负担和出错风险
3. 3.
   代码冗余 : 违反了DRY（Don't Repeat Yourself）原则
### 技术实现
这个patch的核心是引入了一个新的汇编函数 `call_on_irq_stack` ：

```
SYM_FUNC_START(call_on_irq_stack)
    /* Create a frame record to save ra and s0 (fp) */
    addi    sp, sp, -STACKFRAME_SIZE_ON_STACK
    REG_S   ra, STACKFRAME_RA(sp)
    REG_S   s0, STACKFRAME_FP(sp)
    addi    s0, sp, STACKFRAME_SIZE_ON_STACK

    /* Switch to the per-CPU IRQ stack and call the 
    handler */
    load_per_cpu t0, irq_stack_ptr, t1
    li      t1, IRQ_STACK_SIZE
    add     sp, t0, t1
    jalr    a1

    /* Switch back to the thread stack and restore ra 
    and s0 */
    addi    sp, s0, -STACKFRAME_SIZE_ON_STACK
    REG_L   ra, STACKFRAME_RA(sp)
    REG_L   s0, STACKFRAME_FP(sp)
    addi    sp, sp, STACKFRAME_SIZE_ON_STACK

    ret
SYM_FUNC_END(call_on_irq_stack)
```
### 主要改进
1. 1.
   统一的栈切换机制 : 将原本分散在两个文件中的内联汇编代码统一为一个汇编函数
2. 2.
   简化调用方式 :
   - 原来：复杂的内联汇编代码
   - 现在：简单的函数调用 call_on_irq_stack(regs, handle_riscv_irq)
3. 3.
   更好的可维护性 : 栈切换逻辑集中在一处，便于维护和调试
4. 4.
   利用新特性 : 使用了新引入的 load_per_cpu 宏来访问per-CPU变量
### 前世今生 历史发展
1. 1.
   IRQ_STACKS功能引入 : 在commit dd69d07a5a6c中，RISC-V首次引入了独立的IRQ栈支持
2. 2.
   代码重复问题 : 随着功能的完善，在 do_irq 和 do_softirq_own_stack 中出现了重复的栈切换代码
3. 3.
   优化需求 : 社区意识到代码重复的问题，需要进行重构 技术演进
- VMAP_STACK支持 : 在be97d0db5f44中改进了栈溢出检测的线程安全性
- 统一栈切换 : 本patch (82982fdd5133) 统一了IRQ栈切换机制
### 影响和意义
1. 1.
   代码质量提升 : 消除了重复代码，提高了代码的可维护性
2. 2.
   性能优化 : 统一的汇编实现可能带来轻微的性能提升
3. 3.
   架构完善 : 为RISC-V的IRQ处理机制提供了更加清晰的实现
4. 4.
   社区贡献 : 体现了RISC-V社区对代码质量的重视
这个patch是RISC-V架构在企业级功能支持方面持续改进的一个典型例子，展现了社区对代码质量和可维护性的重视，是RISC-V生态走向成熟的重要里程碑。