# RISC-V Zawrs扩展smp_cond_load8/16()实现 Patch 分析

## Commit 信息

**Commit ID:** d9708b1931fc0ebb21cd94a56283d09222847749
**作者:** Guo Ren <guoren@linux.alibaba.com>
**提交者:** Alexandre Ghiti <alexghiti@rivosinc.com>
**作者日期:** Mon Dec 16 20:39:10 2024 -0500
**标题:** riscv: Implement smp_cond_load8/16() with Zawrs

## Patch 概述

这个patch为RISC-V架构实现了基于Zawrs扩展的8位和16位条件加载操作(`smp_cond_load8/16()`)。RISC-V使用队列自旋锁实现，该实现会调用针对单字节的`smp_cond_load_acquire`宏，因此需要补充字节和半字版本的实现。

## 修改文件统计

- **arch/riscv/include/asm/cmpxchg.h**: +35行, -3行
- **总计**: 38行修改

## 详细修改内容分析

### 1. 核心修改：__cmpwait函数增强

#### 修改前的代码结构

```c
static __always_inline void __cmpwait(volatile void *ptr,
                                      unsigned long val,
                                      int size)
{
    unsigned long tmp;

    asm goto(ALTERNATIVE("j %l[no_zawrs]", "nop",
                         0, RISCV_ISA_EXT_ZAWRS, 1)
             : : : : no_zawrs);

    switch (size) {
    case 1:
        fallthrough;  // 原来直接fallthrough到case 2
    case 2:
        /* RISC-V doesn't have lr instructions on byte and half-word. */
        goto no_zawrs;
    case 4:
        // 4字节实现...
    }
}
```

#### 修改后的完整实现

```c
static __always_inline void __cmpwait(volatile void *ptr,
                                      unsigned long val,
                                      int size)
{
    unsigned long tmp;

    u32 *__ptr32b;
    ulong __s, __val, __mask;

    asm goto(ALTERNATIVE("j %l[no_zawrs]", "nop",
                         0, RISCV_ISA_EXT_ZAWRS, 1)
             : : : : no_zawrs);

    switch (size) {
    case 1:
        __ptr32b = (u32 *)((ulong)(ptr) & ~0x3);
        __s = ((ulong)(ptr) & 0x3) * BITS_PER_BYTE;
        __val = val << __s;
        __mask = 0xff << __s;

        asm volatile(
        "       lr.w    %0, %1\n"
        "       and     %0, %0, %3\n"
        "       xor     %0, %0, %2\n"
        "       bnez    %0, 1f\n"
                ZAWRS_WRS_NTO "\n"
        "1:"
        : "=&r" (tmp), "+A" (*(__ptr32b))
        : "r" (__val), "r" (__mask)
        : "memory");
        break;

    case 2:
        __ptr32b = (u32 *)((ulong)(ptr) & ~0x3);
        __s = ((ulong)(ptr) & 0x2) * BITS_PER_BYTE;
        __val = val << __s;
        __mask = 0xffff << __s;

        asm volatile(
        "       lr.w    %0, %1\n"
        "       and     %0, %0, %3\n"
        "       xor     %0, %0, %2\n"
        "       bnez    %0, 1f\n"
                ZAWRS_WRS_NTO "\n"
        "1:"
        : "=&r" (tmp), "+A" (*(__ptr32b))
        : "r" (__val), "r" (__mask)
        : "memory");
        break;

    case 4:
        // 原有的4字节实现保持不变
        break;
    }
}
```

## 技术原理分析

### 1. RISC-V Zawrs扩展

#### 1.1 Zawrs扩展概述

**Zawrs (Wait-for-Reservation-Set)** 是RISC-V的等待保留集扩展，提供了两个新指令：
- `wrs.nto` (Wait for Reservation Set - No Timeout): 无超时等待
- `wrs.sto` (Wait for Reservation Set - Short Timeout): 短超时等待

#### 1.2 指令编码定义

在`arch/riscv/include/asm/insn-def.h`中定义：
```c
#define ZAWRS_WRS_NTO   ".4byte 0x00d00073"
#define ZAWRS_WRS_STO   ".4byte 0x01d00073"
```

#### 1.3 工作原理

- `wrs.nto`指令会让处理器进入低功耗等待状态
- 当监控的内存位置发生变化时，处理器会被唤醒
- 这比传统的忙等待循环更节能

### 2. 字节和半字操作的实现挑战

#### 2.1 RISC-V架构限制

RISC-V架构的Load-Reserved/Store-Conditional指令只支持字(32位)和双字(64位)操作：
- `lr.w/sc.w`: 32位操作
- `lr.d/sc.d`: 64位操作（仅64位架构）
- **没有**`lr.b/sc.b`或`lr.h/sc.h`指令

#### 2.2 解决方案：字对齐访问

为了实现字节和半字的原子操作，使用以下策略：

1. **地址对齐**: 将目标地址对齐到4字节边界
   ```c
   __ptr32b = (u32 *)((ulong)(ptr) & ~0x3);
   ```

2. **位偏移计算**: 计算目标字节/半字在32位字中的位置
   ```c
   // 字节操作
   __s = ((ulong)(ptr) & 0x3) * BITS_PER_BYTE;  // 0, 8, 16, 24

   // 半字操作
   __s = ((ulong)(ptr) & 0x2) * BITS_PER_BYTE;  // 0, 16
   ```

3. **掩码生成**: 创建相应的位掩码
   ```c
   // 字节掩码
   __mask = 0xff << __s;      // 0x000000ff, 0x0000ff00, 0x00ff0000, 0xff000000

   // 半字掩码
   __mask = 0xffff << __s;    // 0x0000ffff, 0xffff0000
   ```

4. **值移位**: 将比较值移位到正确位置
   ```c
   __val = val << __s;
   ```

### 3. 汇编代码实现分析

#### 3.1 汇编指令序列

```assembly
lr.w    %0, %1      # 加载保留32位字
and     %0, %0, %3  # 提取目标字节/半字 (使用掩码)
xor     %0, %0, %2  # 与期望值比较
bnez    %0, 1f      # 如果不相等，跳过等待
wrs.nto             # 等待内存变化
1:                  # 继续执行
```

#### 3.2 指令功能详解

1. **lr.w**: Load-Reserved Word，加载32位字并建立保留
2. **and**: 使用掩码提取目标位域
3. **xor**: 与期望值进行异或比较（结果为0表示相等）
4. **bnez**: 如果比较结果非零（不相等），跳过等待
5. **wrs.nto**: 等待保留集变化，节能等待

### 4. 内存序和同步语义

#### 4.1 内存约束

```c
: "memory"
```

这个约束告诉编译器：
- 汇编代码可能修改内存
- 防止编译器重排序内存访问
- 确保内存可见性

#### 4.2 Load-Reserved语义

- `lr.w`指令建立对内存位置的监控
- 任何其他处理器对该位置的写入都会破坏保留
- `wrs.nto`会在保留被破坏时唤醒处理器

## 应用场景分析

### 1. 队列自旋锁(Queued Spinlock)

#### 1.1 使用场景

RISC-V内核使用队列自旋锁实现，该实现需要：
- 对锁状态字节进行原子操作
- 高效的等待机制
- 低功耗的忙等待

#### 1.2 性能优势

- **节能**: `wrs.nto`比传统忙等待更节能
- **响应性**: 内存变化时立即唤醒
- **可扩展性**: 减少总线流量和缓存一致性开销

### 2. 同步原语优化

#### 2.1 适用的同步机制

- 自旋锁(Spinlock)
- 读写锁(RWLock)
- 信号量(Semaphore)
- 条件变量等待

#### 2.2 性能提升

- 减少CPU功耗
- 降低内存带宽占用
- 提高多核系统的整体性能

## 相关提交分析

### 1. 前置依赖提交

需要以下基础设施支持：
- RISC-V Zawrs扩展检测机制
- Alternative指令替换框架
- Load-Reserved/Store-Conditional基础实现

### 2. 相关扩展支持

可能的相关提交包括：
- Zawrs扩展的hwprobe支持
- 用户空间Zawrs扩展检测
- 编译器工具链支持

### 3. 性能优化机会

后续可能的优化：
- 在更多同步原语中使用Zawrs
- 针对不同工作负载的调优
- 与其他RISC-V扩展的协同优化

## 兼容性和向后兼容性

### 1. 硬件兼容性

- **支持Zawrs的硬件**: 使用高效的`wrs.nto`指令
- **不支持Zawrs的硬件**: 通过Alternative机制回退到`no_zawrs`路径
- **完全向后兼容**: 不影响现有硬件的功能

### 2. 软件兼容性

- **内核**: 透明支持，无需修改上层代码
- **用户空间**: 不直接影响用户空间应用
- **工具链**: 需要支持Zawrs扩展的汇编器

## 性能影响分析

### 1. 正面影响

- **功耗降低**: 等待时CPU进入低功耗状态
- **响应延迟减少**: 内存变化时立即唤醒
- **系统吞吐量提升**: 减少无效的内存访问

### 2. 开销分析

- **指令开销**: 增加了掩码计算和位操作
- **代码大小**: 轻微增加代码体积
- **编译时开销**: Alternative机制的编译时处理

### 3. 适用场景

最适合以下场景：
- 高竞争的锁操作
- 频繁的同步操作
- 多核系统的并发访问

## 测试和验证

### 1. 功能测试

- 验证字节和半字操作的正确性
- 测试不同对齐情况下的行为
- 确认Alternative机制的正确切换

### 2. 性能测试

- 对比启用前后的锁性能
- 测量功耗改善情况
- 评估多核扩展性

### 3. 兼容性测试

- 在不支持Zawrs的硬件上测试
- 验证向后兼容性
- 测试混合配置系统

## 总结

这个patch是RISC-V架构同步机制的重要改进：

1. **完善了Zawrs扩展支持**: 实现了缺失的字节和半字条件等待操作
2. **提供了高效的等待机制**: 利用硬件特性实现节能等待
3. **保持了完全兼容性**: 通过Alternative机制确保向后兼容
4. **优化了队列自旋锁性能**: 为RISC-V的主要同步机制提供硬件加速

该patch的实现巧妙地解决了RISC-V架构缺乏字节/半字Load-Reserved指令的限制，通过字对齐访问和位操作实现了等效功能，同时充分利用了Zawrs扩展的节能特性，为RISC-V平台的高性能并发编程奠定了坚实基础。