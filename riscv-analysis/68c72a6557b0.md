# Patch Analysis: 68c72a6557b0

## Commit Information

**Commit ID**: 68c72a6557b072bff79658b9c0fdb0e69148e32d  
**Author**: Anup Patel <apatel@ventanamicro.com>  
**Date**: Mon Oct 21 01:17:32 2024 +0530  
**Subject**: RISC-V: KVM: Use SBI sync SRET call when available  

## Patch Summary

本patch实现了一个优化的KVM世界切换机制，当SBI嵌套加速扩展可用时，使用SBI sync SRET调用。这改进了当KVM RISC-V作为Guest运行在其他hypervisor下时的KVM世界切换性能。

## 详细修改内容

### 1. 头文件修改 (arch/riscv/include/asm/kvm_nacl.h)

#### 新增函数声明
```c
void __kvm_riscv_nacl_switch_to(struct kvm_vcpu_arch *vcpu_arch,
                               unsigned long sbi_ext_id,
                               unsigned long sbi_func_id);
```

**修改原理**:
- 添加了新的汇编函数声明，用于支持基于SBI的嵌套加速世界切换
- 该函数接受VCPU架构指针和SBI扩展/功能ID作为参数

### 2. VCPU核心逻辑修改 (arch/riscv/kvm/vcpu.c)

#### kvm_riscv_vcpu_enter_exit函数重构

**原始实现**:
```c
static void noinstr kvm_riscv_vcpu_enter_exit(struct kvm_vcpu *vcpu)
{
    struct kvm_cpu_context *gcntx = &vcpu->arch.guest_context;
    struct kvm_cpu_context *hcntx = &vcpu->arch.host_context;

    kvm_riscv_vcpu_swap_in_guest_state(vcpu);
    guest_state_enter_irqoff();

    hcntx->hstatus = csr_swap(CSR_HSTATUS, gcntx->hstatus);
    __kvm_riscv_switch_to(&vcpu->arch);
    gcntx->hstatus = csr_swap(CSR_HSTATUS, hcntx->hstatus);

    vcpu->arch.last_exit_cpu = vcpu->cpu;
    guest_state_exit_irqoff();
}
```

**新实现**:
```c
static void noinstr kvm_riscv_vcpu_enter_exit(struct kvm_vcpu *vcpu)
{
    void *nsh;
    struct kvm_cpu_context *gcntx = &vcpu->arch.guest_context;
    struct kvm_cpu_context *hcntx = &vcpu->arch.host_context;

    kvm_riscv_vcpu_swap_in_guest_state(vcpu);
    guest_state_enter_irqoff();

    if (kvm_riscv_nacl_sync_sret_available()) {
        // 使用SBI嵌套加速路径
        nsh = nacl_shmem();
        
        // CSR处理逻辑
        if (kvm_riscv_nacl_autoswap_csr_available()) {
            // 自动交换CSR模式
        } else if (kvm_riscv_nacl_sync_csr_available()) {
            // 同步CSR模式
        } else {
            // 传统CSR交换
        }
        
        // 使用SBI调用进行世界切换
        __kvm_riscv_nacl_switch_to(&vcpu->arch, SBI_EXT_NACL, SBI_EXT_NACL_SYNC_SRET);
    } else {
        // 传统世界切换路径
        hcntx->hstatus = csr_swap(CSR_HSTATUS, gcntx->hstatus);
        __kvm_riscv_switch_to(&vcpu->arch);
        gcntx->hstatus = csr_swap(CSR_HSTATUS, hcntx->hstatus);
    }

    vcpu->arch.last_exit_cpu = vcpu->cpu;
    guest_state_exit_irqoff();
}
```

### 3. 汇编代码新增 (arch/riscv/kvm/vcpu_switch.S)

#### 新增__kvm_riscv_nacl_switch_to函数

新增`__kvm_riscv_nacl_switch_to`函数，实现基于SBI的优化世界切换：

```assembly
/*
 * Parameters:
 * A0 <= Pointer to struct kvm_vcpu_arch
 * A1 <= SBI extension ID (SBI_EXT_NACL)
 * A2 <= SBI function ID (SBI_EXT_NACL_SYNC_SRET)
 */
SYM_FUNC_START(__kvm_riscv_nacl_switch_to)
	SAVE_HOST_GPRS                    // 保存宿主机通用寄存器

	SAVE_HOST_AND_RESTORE_GUEST_CSRS .Lkvm_nacl_switch_return
	                                  // 保存宿主机CSR，恢复客户机CSR

	/* Resume Guest using SBI nested acceleration */
	add	a6, a2, zero               // a6 = SBI function ID
	add	a7, a1, zero               // a7 = SBI extension ID
	ecall                           // 执行SBI调用进行嵌套加速

	/* Back to Host */
	.align 2
.Lkvm_nacl_switch_return:
	SAVE_GUEST_GPRS                   // 保存客户机通用寄存器

	SAVE_GUEST_AND_RESTORE_HOST_CSRS  // 保存客户机CSR，恢复宿主机CSR

	RESTORE_HOST_GPRS                 // 恢复宿主机通用寄存器

	/* Return to C code */
	ret
SYM_FUNC_END(__kvm_riscv_nacl_switch_to)
```

#### 关键技术点

1. **参数传递**:
   - A0: 指向`struct kvm_vcpu_arch`的指针
   - A1: SBI扩展ID (`SBI_EXT_NACL`)
   - A2: SBI功能ID (`SBI_EXT_NACL_SYNC_SRET`)

2. **寄存器管理**:
   - 使用宏`SAVE_HOST_GPRS`保存宿主机通用寄存器
   - 使用宏`SAVE_HOST_AND_RESTORE_GUEST_CSRS`处理CSR切换
   - 通过`.Lkvm_nacl_switch_return`标签处理返回路径

3. **SBI调用机制**:
   - 将SBI参数加载到a6(功能ID)和a7(扩展ID)寄存器
   - 使用`ecall`指令触发SBI调用
   - 底层hypervisor处理实际的世界切换

4. **性能优化**:
   - 避免了传统的trap-emulate开销
   - 利用硬件虚拟化扩展进行快速切换
   - 减少了上下文切换的指令数量

## 技术原理分析

### 1. SBI嵌套加速机制

该patch引入了SBI (Supervisor Binary Interface) 嵌套加速机制，通过以下方式优化KVM性能：

#### SBI NACL扩展定义
- **扩展ID**: `SBI_EXT_NACL` (0x4E41434C)
- **功能函数**:
  - `SBI_EXT_NACL_PROBE_FEATURE` (0x0): 探测NACL特性
  - `SBI_EXT_NACL_SET_SHMEM` (0x1): 设置共享内存
  - `SBI_EXT_NACL_SYNC_CSR` (0x2): 同步CSR操作
  - `SBI_EXT_NACL_SYNC_HFENCE` (0x3): 同步HFENCE操作
  - `SBI_EXT_NACL_SYNC_SRET` (0x4): 同步SRET操作

#### NACL特性标志
- `SBI_NACL_FEAT_SYNC_CSR` (0x0): 支持CSR同步
- `SBI_NACL_FEAT_SYNC_HFENCE` (0x1): 支持HFENCE同步
- `SBI_NACL_FEAT_SYNC_SRET` (0x2): 支持SRET同步
- `SBI_NACL_FEAT_AUTOSWAP_CSR` (0x3): 支持CSR自动交换

**传统KVM世界切换**:
- 直接操作硬件CSR寄存器
- 使用trap机制进行Guest/Host切换
- 每次切换都需要完整的上下文保存/恢复

**SBI嵌套加速**:
- 利用底层hypervisor提供的SBI接口
- 通过ecall指令调用SBI服务
- 底层hypervisor可以优化世界切换过程

### 2. 共享内存布局

#### 内存区域划分
```
共享内存总大小: SBI_NACL_SHMEM_SIZE
├── SRET区域 (0x0000-0x01FF, 512字节)
├── AUTOSWAP区域 (0x0200-0x027F, 128字节)
├── 未使用区域 (0x0280-0x07FF, 1408字节)
├── HFENCE区域 (0x0800-0x0F7F, 1920字节)
├── 脏位图区域 (0x0F80-0x0FFF, 128字节)
└── CSR区域 (0x1000起, 8KB)
```

#### AUTOSWAP机制
- **HSTATUS自动交换**: `SBI_NACL_SHMEM_AUTOSWAP_FLAG_HSTATUS`
- **偏移地址**: `SBI_NACL_SHMEM_AUTOSWAP_HSTATUS` (8字节对齐)
- **工作原理**: 在VM entry/exit时自动保存/恢复hstatus寄存器

### 3. CSR处理优化

通过NACL机制优化CSR (Control and Status Register) 访问：

- **条件访问**: 根据`kvm_riscv_nacl_sync_csr_available()`动态选择访问方式
- **共享内存访问**: 使用`nacl_csr_read/write/swap`进行高效CSR操作
- **CSR索引映射**: `SBI_NACL_SHMEM_CSR_INDEX(csr_num)` 将CSR号映射到共享内存索引
- **自动交换**: 支持CSR的自动交换机制，减少trap开销

**三种CSR处理模式**:

1. **自动交换模式** (autoswap):
   - 使用共享内存区域存储CSR值
   - 底层hypervisor自动处理CSR交换
   - 最高效的模式

2. **同步CSR模式** (sync_csr):
   - 通过SBI调用同步CSR值
   - 比传统模式更高效

3. **传统模式**:
   - 直接操作CSR寄存器
   - 兼容性最好但性能较低

### 4. HFENCE优化机制

#### HFENCE类型支持
- `SBI_NACL_SHMEM_HFENCE_TYPE_GVMA`: Guest虚拟内存地址fence
- `SBI_NACL_SHMEM_HFENCE_TYPE_GVMA_ALL`: 全局GVMA fence
- `SBI_NACL_SHMEM_HFENCE_TYPE_GVMA_VMID`: 基于VMID的GVMA fence
- `SBI_NACL_SHMEM_HFENCE_TYPE_VVMA`: 虚拟虚拟内存地址fence
- `SBI_NACL_SHMEM_HFENCE_TYPE_VVMA_ASID`: 基于ASID的VVMA fence

#### 配置字段
- **PEND位**: 标识fence操作是否挂起
- **TYPE字段**: 指定fence操作类型
- **ORDER字段**: 指定内存页面大小顺序
- **VMID/ASID字段**: 虚拟机/地址空间标识符

### 5. 同步SRET机制

通过`SBI_EXT_NACL_SYNC_SRET`实现优化的上下文切换：

- **直接切换**: 避免传统的trap-emulate模式
- **状态保存**: 在共享内存SRET区域保存/恢复上下文
- **性能提升**: 显著减少VM entry/exit的开销

```c
// 自动交换配置
nacl_scratch_write_long(nsh,
                       SBI_NACL_SHMEM_AUTOSWAP_OFFSET +
                       SBI_NACL_SHMEM_AUTOSWAP_HSTATUS,
                       gcntx->hstatus);
nacl_scratch_write_long(nsh,
                       SBI_NACL_SHMEM_AUTOSWAP_OFFSET,
                       SBI_NACL_SHMEM_AUTOSWAP_FLAG_HSTATUS);

// SRET参数传递
nacl_scratch_write_longs(nsh,
                        SBI_NACL_SHMEM_SRET_OFFSET +
                        SBI_NACL_SHMEM_SRET_X(1),
                        &gcntx->ra,
                        SBI_NACL_SHMEM_SRET_X_LAST);
```

## NACL系统初始化与管理

### 1. 初始化流程

```c
int kvm_riscv_nacl_init(void)
{
    // 1. 检查SBI版本和NACL扩展支持
    if (sbi_spec_version < sbi_mk_version(1, 0) ||
        sbi_probe_extension(SBI_EXT_NACL) <= 0)
        return -ENODEV;

    // 2. 启用NACL支持
    static_branch_enable(&kvm_riscv_nacl_available);

    // 3. 探测并启用各种NACL特性
    if (nacl_probe_feature(SBI_NACL_FEAT_SYNC_CSR))
        static_branch_enable(&kvm_riscv_nacl_sync_csr_available);
    if (nacl_probe_feature(SBI_NACL_FEAT_SYNC_HFENCE))
        static_branch_enable(&kvm_riscv_nacl_sync_hfence_available);
    if (nacl_probe_feature(SBI_NACL_FEAT_SYNC_SRET))
        static_branch_enable(&kvm_riscv_nacl_sync_sret_available);
    if (nacl_probe_feature(SBI_NACL_FEAT_AUTOSWAP_CSR))
        static_branch_enable(&kvm_riscv_nacl_autoswap_csr_available);

    // 4. 为每个CPU分配共享内存
    for_each_possible_cpu(cpu) {
        nacl = per_cpu_ptr(&kvm_riscv_nacl, cpu);
        shmem_page = alloc_pages(GFP_KERNEL | __GFP_ZERO,
                               get_order(SBI_NACL_SHMEM_SIZE));
        nacl->shmem = page_to_virt(shmem_page);
        nacl->shmem_phys = page_to_phys(shmem_page);
    }
}
```

### 2. 运行时管理

#### 启用NACL
```c
int kvm_riscv_nacl_enable(void)
{
    nacl = this_cpu_ptr(&kvm_riscv_nacl);
    ret = sbi_ecall(SBI_EXT_NACL, SBI_EXT_NACL_SET_SHMEM,
                    nacl->shmem_phys, 0, 0, 0, 0, 0);
    return sbi_err_map_linux_errno(ret.error);
}
```

#### 禁用NACL
```c
void kvm_riscv_nacl_disable(void)
{
    sbi_ecall(SBI_EXT_NACL, SBI_EXT_NACL_SET_SHMEM,
              SBI_SHMEM_DISABLE, SBI_SHMEM_DISABLE, 0, 0, 0, 0);
}
```

### 3. 静态分支优化

NACL使用Linux内核的静态分支机制进行运行时优化：

```c
DEFINE_STATIC_KEY_FALSE(kvm_riscv_nacl_available);
DEFINE_STATIC_KEY_FALSE(kvm_riscv_nacl_sync_csr_available);
DEFINE_STATIC_KEY_FALSE(kvm_riscv_nacl_sync_hfence_available);
DEFINE_STATIC_KEY_FALSE(kvm_riscv_nacl_sync_sret_available);
DEFINE_STATIC_KEY_FALSE(kvm_riscv_nacl_autoswap_csr_available);
```

- **零开销抽象**: 当NACL不可用时，相关代码路径被完全优化掉
- **动态特性检测**: 根据底层hypervisor支持情况动态启用特性
- **分层回退**: 不同特性可以独立启用/禁用

## 性能优化效果

### 1. 减少陷入开销
- 传统模式每次世界切换都需要多次trap
- SBI模式通过单次ecall完成切换
- 减少了hypervisor陷入的次数

### 2. CSR操作优化
- 自动交换模式避免了显式的CSR读写
- 底层hypervisor可以批量处理CSR操作
- 减少了特权指令的执行次数

### 3. 上下文切换优化
- 利用底层hypervisor的优化实现
- 可能包括硬件加速特性
- 减少了软件层面的开销

## 兼容性设计

### 1. 运行时检测
```c
if (kvm_riscv_nacl_sync_sret_available()) {
    // 使用优化路径
} else {
    // 使用传统路径
}
```

### 2. 分层回退机制
- 优先使用autoswap模式
- 回退到sync_csr模式
- 最终回退到传统模式

### 3. 静态分支优化
- 使用Linux内核的static key机制
- 在非嵌套场景下几乎零开销

## 相关提交分析

本patch是RISC-V KVM嵌套虚拟化支持系列patch的一部分，以下是主要相关提交:

### 1. 基础架构提交

**d466c19cead5** - "RISC-V: KVM: Add common nested acceleration support"
- 添加了通用嵌套加速支持框架
- 实现了SBI NACL扩展的检测和启用机制
- 使用静态键(static keys)确保非嵌套场景的最小影响
- 新增文件: `arch/riscv/include/asm/kvm_nacl.h`, `arch/riscv/kvm/nacl.c`

### 2. CSR访问优化提交

**e28e6b69767b** - "RISC-V: KVM: Use nacl_csr_xyz() for accessing H-extension CSRs"
- 优化H扩展CSR的访问方式
- 使用NACL提供的CSR访问接口

**dab55604aec5** - "RISC-V: KVM: Use nacl_csr_xyz() for accessing AIA CSRs"
- 优化AIA(Advanced Interrupt Architecture) CSR访问
- 进一步扩展NACL CSR访问机制的应用范围

### 3. 内存管理优化提交

**5bdecd891e50** - "RISC-V: KVM: Use NACL HFENCEs for KVM request based HFENCEs"
- 使用NACL提供的HFENCE操作
- 优化KVM请求基础的HFENCE处理

### 4. 上下文切换优化提交

**8f57adac3916** - "RISC-V: KVM: Break down the __kvm_riscv_switch_to() into macros"
- 将世界切换函数分解为宏
- 为支持多种切换模式做准备

**3e7d154ad89b** - "RISC-V: KVM: Save trap CSRs in kvm_riscv_vcpu_enter_exit()"
- 在VCPU进入/退出时保存trap CSR
- 完善上下文切换的状态保存机制

### 5. 系列patch的演进路径

```
d466c19cead5 (基础框架)
    ↓
e28e6b69767b (H扩展CSR优化)
    ↓
dab55604aec5 (AIA CSR优化)
    ↓
8f57adac3916 (切换函数重构)
    ↓
3e7d154ad89b (trap CSR保存)
    ↓
68c72a6557b0 (SBI sync SRET) ← 当前分析的patch
    ↓
5bdecd891e50 (HFENCE优化)
```

## 总结

这个patch通过引入SBI嵌套加速机制，显著优化了RISC-V KVM在嵌套虚拟化场景下的性能。主要改进包括:

1. **架构优化**: 利用底层hypervisor的SBI接口
2. **性能提升**: 减少陷入次数和CSR操作开销
3. **兼容性**: 保持与传统模式的完全兼容
4. **可扩展性**: 为未来的硬件加速特性预留接口

该patch体现了现代虚拟化技术中分层优化的设计思想，通过标准化的SBI接口实现了跨平台的性能优化。