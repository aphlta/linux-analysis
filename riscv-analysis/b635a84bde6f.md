# RISC-V XIP Kernel 只读段大小限制移除分析

## 1. Commit 信息

- **Commit ID**: b635a84bde6f0b94944b5d960f4e6a52ac3555c6
- **标题**: riscv: remove limit on the size of read-only section for XIP kernel
- **作者**: Nam Cao <namcao@linutronix.de>
- **提交日期**: 2024年6月7日
- **合并日期**: 2024年9月12日
- **审查者**: Alexandre Ghiti <alexghiti@rivosinc.com>
- **维护者**: Palmer Dabbelt <palmer@rivosinc.com>

## 2. 问题背景

### 2.1 XIP Kernel 简介

XIP (eXecute In Place) 内核是一种特殊的内核配置，允许内核代码直接从Flash存储器中执行，而不需要先将其复制到RAM中。这种配置在嵌入式系统中特别有用，可以节省宝贵的RAM资源。

### 2.2 XIP_OFFSET 的作用

在此patch之前，RISC-V XIP内核使用硬编码的`XIP_OFFSET`宏来定义可写数据段在内核中的偏移量：

```c
#ifdef CONFIG_XIP_KERNEL
#define XIP_OFFSET             SZ_32M
#define XIP_OFFSET_MASK        (SZ_32M - 1)
#else
#define XIP_OFFSET             0
#endif
```

这个硬编码值（32MB）限制了内核只读段的最大大小，因为只读段位于可写数据段之前。

### 2.3 问题描述

当内核变得过大时，这种硬编码限制会导致构建失败。kernel test robot报告了这样的构建失败案例，表明现有的32MB限制已经不够用了。

## 3. 修改内容详细分析

### 3.1 移除的代码

在`arch/riscv/include/asm/pgtable.h`中移除了XIP_OFFSET的定义：

```c
-#ifdef CONFIG_XIP_KERNEL
-#define XIP_OFFSET             SZ_32M
-#define XIP_OFFSET_MASK        (SZ_32M - 1)
-#else
-#define XIP_OFFSET             0
-#endif
```

### 3.2 修改的代码

#### 3.2.1 set_memory.h 的修改

在`arch/riscv/include/asm/set_memory.h`中，扩展了SECTION_ALIGN的适用条件：

```c
-#ifdef CONFIG_STRICT_KERNEL_RWX
+#if defined(CONFIG_STRICT_KERNEL_RWX) || defined(CONFIG_XIP_KERNEL)
```

这确保XIP内核也使用适当的段对齐。

#### 3.2.2 链接脚本的修改

在`arch/riscv/kernel/vmlinux-xip.lds.S`中进行了关键修改：

**添加头文件包含**：
```c
+#include <asm/set_memory.h>
```

**修改数据段位置计算**：
```c
-       . = KERNEL_LINK_ADDR + XIP_OFFSET;      /* location in memory */
+       . = ALIGN(SECTION_ALIGN);               /* location in memory */
```

**修改LOAD_OFFSET计算**：
```c
-#define LOAD_OFFSET (KERNEL_LINK_ADDR + XIP_OFFSET - (__data_loc & XIP_OFFSET_MASK))
+#define LOAD_OFFSET (KERNEL_LINK_ADDR + _sdata - __data_loc)
```

## 4. 技术原理分析

### 4.1 原有方案的问题

原有方案使用硬编码的XIP_OFFSET有以下问题：

1. **固定限制**: 32MB的硬编码限制无法适应不断增长的内核大小
2. **浪费空间**: 如果内核小于32MB，会浪费地址空间
3. **维护困难**: 需要手动调整这个值来适应不同的内核大小

### 4.2 新方案的优势

新方案通过动态计算替代硬编码值：

1. **动态适应**: 使用`_sdata`和`_start`符号动态计算数据段位置
2. **无大小限制**: 只读段可以根据实际需要增长
3. **自动对齐**: 使用`SECTION_ALIGN`确保适当的内存对齐

### 4.3 SECTION_ALIGN 的作用

```c
#if defined(CONFIG_STRICT_KERNEL_RWX) || defined(CONFIG_XIP_KERNEL)
#ifdef CONFIG_64BIT
#define SECTION_ALIGN (1 << 21)  // 2MB对齐
#else
#define SECTION_ALIGN (1 << 22)  // 4MB对齐
#endif
```

这种对齐确保：
- 内存保护单元(MPU)可以正确工作
- 页表映射效率最优
- 硬件缓存性能最佳

## 5. 相关提交分析

这个patch是一个更大的patch系列的一部分，该系列旨在完全移除XIP_OFFSET的使用：

### 5.1 前置提交

1. **a7cfb999433a**: "riscv: drop the use of XIP_OFFSET in create_kernel_page_table()"
   - 在页表创建中移除XIP_OFFSET的使用
   - 使用`_sdata`和`_start`符号替代

2. **75fdf791dff0**: "riscv: drop the use of XIP_OFFSET in kernel_mapping_va_to_pa()"
   - 在虚拟地址到物理地址转换中移除XIP_OFFSET
   - 使用`kernel_map.xiprom_sz`替代

3. **23311f57ee13**: "riscv: drop the use of XIP_OFFSET in XIP_FIXUP_FLASH_OFFSET"
4. **e4eac34feda4**: "riscv: drop the use of XIP_OFFSET in XIP_FIXUP_OFFSET"

### 5.2 相关优化提交

- **5cf089672119**: "riscv: replace misleading va_kernel_pa_offset on XIP kernel"
- **f2df5b4fdd74**: "riscv: don't export va_kernel_pa_offset in vmcoreinfo for XIP kernel"
- **aa3457f22f00**: "riscv: cleanup XIP_FIXUP macro"

## 6. 影响和意义

### 6.1 直接影响

1. **解决构建失败**: 修复了大型内核的构建问题
2. **提高灵活性**: 内核大小不再受32MB限制
3. **简化代码**: 移除了硬编码常量，代码更清晰

### 6.2 长期意义

1. **可扩展性**: 为未来内核大小增长提供了空间
2. **维护性**: 减少了需要手动调整的硬编码值
3. **一致性**: 与其他架构的XIP实现更加一致

## 7. 测试和验证

### 7.1 构建测试

这个patch解决了kernel test robot报告的构建失败问题，确保大型XIP内核可以成功构建。

### 7.2 功能测试

需要验证：
- XIP内核可以正常启动
- 内存映射正确
- 只读段和可写段的保护机制正常工作

## 8. 总结

这个patch通过移除硬编码的XIP_OFFSET限制，解决了RISC-V XIP内核只读段大小限制的问题。主要改进包括：

1. **移除硬编码限制**: 不再使用固定的32MB偏移量
2. **动态计算**: 使用链接器符号动态确定数据段位置
3. **改进对齐**: 确保XIP内核使用适当的段对齐
4. **简化维护**: 减少需要手动调整的参数

这个修改是RISC-V XIP内核支持的重要改进，为嵌入式系统提供了更大的灵活性和可扩展性。

## 9. 参考链接

- [Kernel Test Robot报告](https://lore.kernel.org/oe-kbuild-all/202404211031.J6l2AfJk-lkp@intel.com)
- [Patch链接](https://lore.kernel.org/r/3bf3a77be10ebb0d8086c028500baa16e7a8e648.1717789719.git.namcao@linutronix.de)
- [合并提交](https://lore.kernel.org/r/20240607202213.2781-1-namcao@linutronix.de)