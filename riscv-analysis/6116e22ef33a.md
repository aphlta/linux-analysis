# RISC-V zacas fully-ordered cmpxchg() 优化分析

## Commit 信息

**Commit ID:** 6116e22ef33a8239f3d53bb25377e9ed733c4176  
**作者:** Alexandre Ghiti <alexghiti@rivosinc.com>  
**提交日期:** 2024年11月3日  
**合并者:** Palmer Dabbelt <palmer@rivosinc.com>  
**合并日期:** 2024年11月11日  
**标题:** riscv: Improve zacas fully-ordered cmpxchg()  

## 问题背景

在RISC-V架构中，当前的fully-ordered cmpxchg()实现会产生以下汇编代码：

```assembly
amocas.X.rl     a5,a4,(s1)
fence           rw,rw
```

这种实现虽然提供了足够的同步保证，但不是最优的。根据RISC-V内存模型规范，可以使用更高效的映射方式：

```assembly
amocas.X.aqrl   a5,a4,(s1)
```

## 技术原理

### RISC-V内存屏障机制

从代码分析可以看出，RISC-V定义了以下内存屏障：

```c
#ifdef CONFIG_SMP
#define RISCV_ACQUIRE_BARRIER    RISCV_FENCE_ASM(r, rw)
#define RISCV_RELEASE_BARRIER    RISCV_FENCE_ASM(rw, w)
#define RISCV_FULL_BARRIER       RISCV_FENCE_ASM(rw, rw)
#else
#define RISCV_ACQUIRE_BARRIER
#define RISCV_RELEASE_BARRIER
#define RISCV_FULL_BARRIER
#endif
```

### ZACAS扩展

ZACAS (Atomic Compare-and-Swap)是RISC-V的一个扩展，提供了原子比较交换指令`amocas`。该扩展支持以下内存排序后缀：

- `.rl` (release): 释放语义
- `.aq` (acquire): 获取语义  
- `.aqrl` (acquire-release): 获取-释放语义

### 优化原理

**修改前的实现：**
- 使用`amocas.X.rl`指令提供释放语义
- 额外添加`fence rw,rw`指令提供完整的内存屏障

**修改后的实现：**
- 直接使用`amocas.X.aqrl`指令提供获取-释放语义
- 无需额外的fence指令

这种优化的理论依据是：`amocas.X.aqrl`指令本身就提供了完整的内存排序保证，等价于原来的`amocas.X.rl + fence rw,rw`组合。

## 代码修改详细分析

### 1. 宏定义重构

**新增的宏定义：**
```c
#define SC_SFX(x)     x
#define CAS_SFX(x)    x  
#define SC_PREPEND(x) x
#define SC_APPEND(x)  x
#define CAS_PREPEND(x) x
#define CAS_APPEND(x) x
```

这些宏用于分离SC (Store Conditional)和CAS (Compare-and-Swap)指令的不同参数，提供更细粒度的控制。

### 2. _arch_cmpxchg宏参数扩展

**修改前：**
```c
#define _arch_cmpxchg(ptr, old, new, sc_cas_sfx, prepend, append)
```

**修改后：**
```c
#define _arch_cmpxchg(ptr, old, new, sc_sfx, cas_sfx,
                     sc_prepend, sc_append,
                     cas_prepend, cas_append)
```

参数从6个扩展到9个，允许对SC和CAS指令分别指定：
- 后缀 (suffix)
- 前置代码 (prepend)
- 后置代码 (append)

### 3. 各种cmpxchg变体的更新

**arch_cmpxchg_relaxed (无内存排序)：**
```c
// 修改前
_arch_cmpxchg((ptr), (o), (n), "", "", "")

// 修改后  
_arch_cmpxchg((ptr), (o), (n),
              SC_SFX(""), CAS_SFX(""),
              SC_PREPEND(""), SC_APPEND(""),
              CAS_PREPEND(""), CAS_APPEND(""))
```

**arch_cmpxchg_acquire (获取语义)：**
```c
// 修改前
_arch_cmpxchg((ptr), (o), (n), "", "", RISCV_ACQUIRE_BARRIER)

// 修改后
_arch_cmpxchg((ptr), (o), (n),
              SC_SFX(""), CAS_SFX(""),
              SC_PREPEND(""), SC_APPEND(RISCV_ACQUIRE_BARRIER),
              CAS_PREPEND(""), CAS_APPEND(RISCV_ACQUIRE_BARRIER))
```

**arch_cmpxchg_release (释放语义)：**
```c
// 修改前
_arch_cmpxchg((ptr), (o), (n), "", RISCV_RELEASE_BARRIER, "")

// 修改后
_arch_cmpxchg((ptr), (o), (n),
              SC_SFX(""), CAS_SFX(""),
              SC_PREPEND(RISCV_RELEASE_BARRIER), SC_APPEND(""),
              CAS_PREPEND(RISCV_RELEASE_BARRIER), CAS_APPEND(""))
```

**arch_cmpxchg (完全排序) - 关键优化：**
```c
// 修改前
_arch_cmpxchg((ptr), (o), (n), ".rl", "", "     fence rw, rw\n")

// 修改后
_arch_cmpxchg((ptr), (o), (n),
              SC_SFX(".rl"), CAS_SFX(".aqrl"),
              SC_PREPEND(""), SC_APPEND(RISCV_FULL_BARRIER),
              CAS_PREPEND(""), CAS_APPEND(""))
```

**关键变化：**
- SC指令仍使用`.rl`后缀
- CAS指令改用`.aqrl`后缀（这是核心优化）
- CAS指令不再需要额外的fence指令
- SC指令保留原有的fence作为fallback

## 性能影响分析

### 1. 指令数量减少
- **修改前：** 2条指令 (`amocas.X.rl` + `fence rw,rw`)
- **修改后：** 1条指令 (`amocas.X.aqrl`)
- **性能提升：** 减少50%的指令数量

### 2. 执行效率提升
- 减少了额外的fence指令开销
- 降低了指令缓存压力
- 减少了流水线停顿的可能性

### 3. 内存排序保证
- 功能等价性：`.aqrl`提供的内存排序保证与`.rl + fence rw,rw`完全相同
- 符合RISC-V内存模型规范

## 相关扩展和依赖

### ZACAS扩展支持
该优化依赖于以下RISC-V扩展：
- **ZACAS:** 原子比较交换指令扩展
- **ZABHA:** 字节和半字原子操作扩展（用于小尺寸操作的fallback）

### 配置选项
```c
IS_ENABLED(CONFIG_RISCV_ISA_ZACAS)
IS_ENABLED(CONFIG_RISCV_ISA_ZABHA)
```

## 兼容性考虑

### 1. 硬件兼容性
- 仅在支持ZACAS扩展的RISC-V处理器上生效
- 不支持ZACAS的处理器会fallback到传统的LR/SC实现

### 2. 软件兼容性
- 保持了相同的API接口
- 内存排序语义完全兼容
- 不影响现有代码的正确性

## 测试和验证

该patch经过了以下人员的审查：
- **建议者：** Andrea Parri <andrea@rivosinc.com>
- **审查者：** Andrew Jones <ajones@ventanamicro.com>
- **审查者：** Andrea Parri <parri.andrea@gmail.com>

## 总结

这个patch是一个典型的性能优化，通过更好地利用RISC-V ZACAS扩展的特性，在保持功能正确性的前提下提升了原子操作的性能。主要贡献包括：

1. **性能提升：** 将fully-ordered cmpxchg从2条指令优化为1条指令
2. **架构优化：** 更好地利用了RISC-V内存模型的特性
3. **代码重构：** 提供了更灵活的宏定义结构，便于未来扩展
4. **向后兼容：** 保持了完整的API兼容性和功能等价性

这种优化对于高频使用原子操作的多线程应用程序具有重要意义，特别是在锁竞争激烈的场景下能够显著提升性能。