# RISC-V execmem扩展支持生成代码分配的Patch分析

## Commit信息
- **Commit ID**: 4d7b321a9ce0782a953874ec69acc2b12b9cb2cd
- **作者**: Mike Rapoport (IBM) <rppt@kernel.org>
- **日期**: 2024年5月5日
- **标题**: riscv: extend execmem_params for generated code allocations

## 1. Patch概述

这个patch是Linux内核execmem框架在RISC-V架构上的扩展实现，主要目的是统一kprobes和BPF JIT的内存分配机制，将原本分散的自定义内存分配实现整合到统一的execmem框架中。

## 2. 主要修改内容

### 2.1 头文件修改 (arch/riscv/include/asm/pgtable.h)

```c
+#else
+#define MODULES_VADDR          VMALLOC_START
+#define MODULES_END            VMALLOC_END
+#endif
```

**修改原理**:
- 为32位RISC-V定义了模块地址空间范围
- 32位系统使用VMALLOC区域作为模块加载区域
- 64位系统继续使用原有的2GB偏移机制

### 2.2 模块系统修改 (arch/riscv/kernel/module.c)

#### 条件编译范围调整
```c
-#if defined(CONFIG_MMU) && defined(CONFIG_64BIT)
+#ifdef CONFIG_MMU
```

**修改原理**:
- 扩展execmem支持到32位MMU系统
- 原本只有64位MMU系统支持execmem，现在32位也支持

#### execmem_params扩展
```c
[EXECMEM_KPROBES] = {
    .start  = VMALLOC_START,
    .end    = VMALLOC_END,
    .pgprot = PAGE_KERNEL_READ_EXEC,
    .alignment = 1,
},
[EXECMEM_BPF] = {
    .start  = BPF_JIT_REGION_START,
    .end    = BPF_JIT_REGION_END,
    .pgprot = PAGE_KERNEL,
    .alignment = PAGE_SIZE,
},
```

**修改原理**:
- **EXECMEM_KPROBES**: 使用VMALLOC区域，具有读执行权限，字节对齐
- **EXECMEM_BPF**: 使用专用的BPF JIT区域，具有内核权限，页对齐
- 不同的内存类型有不同的权限和对齐要求

### 2.3 移除kprobes自定义分配器 (arch/riscv/kernel/probes/kprobes.c)

```c
-#ifdef CONFIG_MMU
-void *alloc_insn_page(void)
-{
-       return  __vmalloc_node_range(PAGE_SIZE, 1, VMALLOC_START, VMALLOC_END,
-                                    GFP_KERNEL, PAGE_KERNEL_READ_EXEC,
-                                    VM_FLUSH_RESET_PERMS, NUMA_NO_NODE,
-                                    __builtin_return_address(0));
-}
-#endif
```

**修改原理**:
- 移除了kprobes专用的内存分配函数
- 统一使用execmem框架进行分配
- 减少代码重复，提高维护性

### 2.4 移除BPF JIT自定义分配器 (arch/riscv/net/bpf_jit_core.c)

```c
-void *bpf_jit_alloc_exec(unsigned long size)
-{
-       return __vmalloc_node_range(size, PAGE_SIZE, BPF_JIT_REGION_START,
-                                   BPF_JIT_REGION_END, GFP_KERNEL,
-                                   PAGE_KERNEL, 0, NUMA_NO_NODE,
-                                   __builtin_return_address(0));
-}
-
-void bpf_jit_free_exec(void *addr)
-{
-       return vfree(addr);
-}
```

**修改原理**:
- 移除了BPF JIT专用的内存分配和释放函数
- 统一使用execmem框架的分配器
- 简化了BPF JIT的内存管理

## 3. 技术原理分析

### 3.1 execmem框架背景

execmem框架是Linux内核中用于统一管理可执行内存分配的新机制，解决了以下问题：

1. **分散的内存分配**: 不同子系统(modules、kprobes、BPF、ftrace)都有自己的内存分配实现
2. **架构特定限制**: 不同架构对可执行内存的位置、权限、对齐有不同要求
3. **代码重复**: 多个子系统实现类似的内存分配逻辑

### 3.2 RISC-V内存布局

#### 64位RISC-V内存布局
```
高地址
+------------------+
|   Kernel Text    | <- KERNEL_LINK_ADDR (ADDRESS_SPACE_END - 2GB + 1)
+------------------+
|   Modules        | <- MODULES_VADDR to MODULES_END
+------------------+
|   BPF JIT        | <- BPF_JIT_REGION (128MB)
+------------------+
|   VMALLOC        | <- VMALLOC_START to VMALLOC_END
+------------------+
低地址
```

#### 32位RISC-V内存布局
```
高地址
+------------------+
|   Kernel Text    |
+------------------+
|   VMALLOC        | <- 包含Modules和其他分配
|   (含Modules)    |
+------------------+
|   BPF JIT        | <- 在VMALLOC区域内
+------------------+
低地址
```

### 3.3 内存权限设计

- **EXECMEM_KPROBES**: `PAGE_KERNEL_READ_EXEC`
  - 可读可执行，用于动态插入的探测代码
  - 字节对齐(alignment = 1)，因为指令可能不对齐

- **EXECMEM_BPF**: `PAGE_KERNEL`
  - 内核权限，BPF JIT生成的代码
  - 页对齐(alignment = PAGE_SIZE)，提高性能

### 3.4 架构差异处理

**64位vs32位差异**:
- 64位: 有专用的2GB模块区域和128MB BPF区域
- 32位: 模块和BPF都在VMALLOC区域内分配
- 32位系统地址空间有限，无法像64位那样预留大块专用区域

## 4. 相关提交分析

这个patch是execmem框架引入的一部分，相关的重要提交包括：

1. **12af2b83d0b1**: "mm: introduce execmem_alloc() and execmem_free()"
   - 引入了execmem框架的基础API
   - 定义了execmem_type枚举
   - 提供了统一的分配接口

2. **f6bec26c0a73**: "mm/execmem, arch: convert simple overrides of module_alloc to execmem"
   - 将简单的module_alloc重写转换为execmem
   - 为架构特定实现提供模板

3. **223b5e57d0d5**: "mm/execmem, arch: convert remaining overrides of module_alloc to execmem"
   - 完成剩余架构的转换
   - 统一所有架构的可执行内存分配

## 5. 影响和意义

### 5.1 代码简化
- 移除了约30行重复的内存分配代码
- 统一了kprobes和BPF的内存管理
- 提高了代码的可维护性

### 5.2 架构一致性
- RISC-V与其他架构保持一致的execmem接口
- 便于跨架构的功能开发和维护
- 为未来的优化提供了统一的基础

### 5.3 功能扩展
- 32位RISC-V现在也支持execmem框架
- 为未来添加新的可执行内存类型提供了基础
- 支持更细粒度的内存权限控制

### 5.4 性能考虑
- BPF JIT继续使用专用的128MB区域，保持性能
- kprobes使用VMALLOC区域，适合其使用模式
- 不同类型的内存有不同的对齐策略，优化性能

## 6. 潜在问题和限制

### 6.1 32位系统限制
- 32位系统的地址空间有限，可能影响大量BPF程序的加载
- VMALLOC区域的碎片化可能影响大块内存分配

### 6.2 兼容性
- 需要确保现有的kprobes和BPF程序继续正常工作
- 内存分配行为的微小变化可能影响某些边缘情况

### 6.3 调试复杂性
- 统一的分配器可能使特定子系统的内存问题更难调试
- 需要新的调试工具来理解execmem的分配模式

## 7. 总结

这个patch是Linux内核架构演进的一个重要步骤，通过引入execmem框架，RISC-V架构实现了可执行内存分配的统一管理。这不仅简化了代码，提高了维护性，还为未来的功能扩展奠定了基础。虽然存在一些潜在的限制，但总体上这是一个积极的改进，体现了内核开发中"统一接口、减少重复"的设计原则。