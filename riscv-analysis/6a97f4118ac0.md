# Patch 分析报告: 6a97f4118ac0

## 1. 基本信息

**Commit ID**: 6a97f4118ac0
**标题**: riscv: Fix sleeping in invalid context in die()
**作者**: Nam Cao <namcao@linutronix.de>
**提交时间**: 2024年
**Fixes**: 76d2a0493a17 ("RISC-V: Init and Halt Code")
**Cc**: stable@vger.kernel.org
**审核者**: Sebastian Andrzej Siewior <bigeasy@linutronix.de>

## 2. 问题描述

### 2.1 问题现象

在启用 PREEMPT_RT 的系统中，die() 函数在错误处理路径中出现了 "sleeping in invalid context" 的警告。具体错误信息如下：

```
BUG: sleeping function called from invalid context at kernel/locking/spinlock_rt.c:48
in_atomic(): 1, irqs_disabled(): 1, non_block: 0, pid: 285, name: mutex
preempt_count: 110001, expected: 0
RCU nest depth: 0, expected: 0
CPU: 0 UID: 0 PID: 285 Comm: mutex Not tainted 6.12.0-rc7-00022-ge19049cf7d56-dirty #234
Hardware name: riscv-virtio,qemu (DT)
Call Trace:
    dump_backtrace+0x1c/0x24
    show_stack+0x2c/0x38
    dump_stack_lvl+0x5a/0x72
    dump_stack+0x14/0x1c
    __might_resched+0x130/0x13a
    rt_spin_lock+0x2a/0x5c
    die+0x24/0x112
    do_trap_insn_illegal+0xa0/0xea
```

### 2.2 根本原因

在 PREEMPT_RT 内核中，普通的 spinlock 被替换为 rt_mutex，这种锁是可以睡眠的。但是在 die() 函数的上下文中（通常在中断或原子上下文中调用），不允许睡眠操作。

## 3. 技术分析

### 3.1 PREEMPT_RT 中的锁机制

在 PREEMPT_RT 内核中：

1. **普通 spinlock**: 被替换为 rt_mutex，可以睡眠，支持优先级继承
2. **raw_spinlock**: 保持原始的自旋锁行为，不会睡眠，即使在 PREEMPT_RT 中也是如此

从 `include/linux/preempt.h` 中可以看到：

```c
/*
 * The preempt_count offset after spin_lock()
 */
#if !defined(CONFIG_PREEMPT_RT)
#define PREEMPT_LOCK_OFFSET		PREEMPT_DISABLE_OFFSET
#else
/* Locks on RT do not disable preemption */
#define PREEMPT_LOCK_OFFSET		0
#endif
```

这说明在 PREEMPT_RT 中，普通的 spinlock 不会禁用抢占。

### 3.2 die() 函数的特殊性

die() 函数通常在以下情况下被调用：
- 内核 panic
- 非法指令异常
- 其他严重的系统错误

这些情况下，系统可能处于：
- 中断上下文
- 原子上下文
- 抢占被禁用的上下文

在这些上下文中，不允许进行可能导致睡眠的操作。

### 3.3 修复原理

将 `DEFINE_SPINLOCK(die_lock)` 改为 `DEFINE_RAW_SPINLOCK(die_lock)`，并相应地将：
- `spin_lock_irqsave()` 改为 `raw_spin_lock_irqsave()`
- `spin_unlock_irqrestore()` 改为 `raw_spin_unlock_irqrestore()`

这样确保即使在 PREEMPT_RT 内核中，die_lock 也保持原始的自旋锁行为，不会睡眠。

## 4. 代码修改详情

### 4.1 修改的文件

**文件**: `arch/riscv/kernel/traps.c`

### 4.2 具体修改

```diff
-static DEFINE_SPINLOCK(die_lock);
+static DEFINE_RAW_SPINLOCK(die_lock);

-	spin_lock_irqsave(&die_lock, flags);
+	raw_spin_lock_irqsave(&die_lock, flags);

-	spin_unlock_irqrestore(&die_lock, flags);
+	raw_spin_unlock_irqrestore(&die_lock, flags);
```

### 4.3 修改位置

1. **第38行**: 锁的定义
2. **第84行**: 获取锁
3. **第103行**: 释放锁

## 5. 影响分析

### 5.1 功能影响

- **正面影响**: 修复了 PREEMPT_RT 内核中的睡眠警告
- **无负面影响**: raw_spinlock 在非 PREEMPT_RT 内核中行为与普通 spinlock 相同

### 5.2 性能影响

- **微小影响**: raw_spinlock 可能在高竞争情况下性能略差，但 die() 函数很少被调用
- **整体无影响**: 这是错误处理路径，不在性能关键路径上

### 5.3 兼容性

- **向后兼容**: 修改不影响现有的非 PREEMPT_RT 内核
- **向前兼容**: 为 PREEMPT_RT 内核提供正确的行为

## 6. 相关提交分析

### 6.1 原始提交 (76d2a0493a17)

这是 RISC-V 架构的初始化和停机代码的提交，引入了 die() 函数的基本实现。当时使用普通的 spinlock，在非 PREEMPT_RT 内核中工作正常。

### 6.2 修复的必要性

随着 PREEMPT_RT 支持的完善，需要确保所有在原子上下文中使用的锁都是 raw_spinlock，以避免意外的睡眠操作。

## 7. 类似问题

在内核中，类似的修复还包括：
- 中断控制器驱动中的锁
- 时钟管理代码中的锁
- 其他异常处理路径中的锁

这些都需要在 PREEMPT_RT 环境下使用 raw_spinlock 来避免睡眠。

## 8. 总结

这个 patch 是一个典型的 PREEMPT_RT 兼容性修复，通过将普通 spinlock 替换为 raw_spinlock，确保 die() 函数在所有内核配置下都能正确工作。修复简单但重要，因为它涉及系统的错误处理机制，必须在任何情况下都能可靠工作。

这种类型的修复在 PREEMPT_RT 的发展过程中很常见，体现了实时内核对锁语义的严格要求。