# RISC-V CPU SBI Boot Data 修复分析

## Commit 信息

**Commit ID:** 02c725cd55eb5052b88eeaa3f60a391ef4dcaec5  
**作者:** Vivian Wang <wangruikang@iscas.ac.cn>  
**日期:** Tue Jun 24 16:04:46 2025 +0800  
**标题:** riscv: cpu_ops_sbi: Use static array for boot_data  
**上游Commit:** 2b29be967ae456fc09c320d91d52278cf721be1e  

## 问题背景

### 根本原因

自从commit 6b9f29b81b15 ("riscv: Enable pcpu page first chunk allocator")引入后，当启用NUMA时，在非常稀疏的配置下或者通过`percpu_alloc=page`启动参数强制使用时，可能会使用页面percpu分配器。

在这种情况下，percpu数据会被放置在vmalloc区域中。然而，`sbi_hsm_hart_start()`函数需要`sbi_hart_boot_data`的物理地址，并简单地假设`__pa()`函数能够正常工作。这导致刚启动的hart立即访问无效地址并挂起。

### 技术细节

1. **percpu分配器变化**: commit 6b9f29b81b15启用了页面percpu分配器作为嵌入式分配器的后备方案
2. **vmalloc区域限制**: 在sv39中，vmalloc区域只有64GB，在稀疏NUMA配置下可能不足
3. **物理地址转换问题**: 当percpu数据位于vmalloc区域时，`__pa()`无法正确转换虚拟地址为物理地址
4. **SBI HSM启动失败**: 新启动的hart收到错误的物理地址，导致系统挂起

## 代码修改分析

### 修改前的代码

```c
/*
 * Ordered booting via HSM brings one cpu at a time. However, cpu hotplug can
 * be invoked from multiple threads in parallel. Define a per cpu data
 * to handle that.
 */
static DEFINE_PER_CPU(struct sbi_hart_boot_data, boot_data);

static int sbi_cpu_start(unsigned int cpuid, struct task_struct *tidle)
{
    // ...
    struct sbi_hart_boot_data *bdata = &per_cpu(boot_data, cpuid);
    // ...
    hsm_data = __pa(bdata);  // 这里可能失败
    return sbi_hsm_hart_start(hartid, boot_addr, hsm_data);
}
```

### 修改后的代码

```c
/*
 * Ordered booting via HSM brings one cpu at a time. However, cpu hotplug can
 * be invoked from multiple threads in parallel. Define an array of boot data
 * to handle that.
 */
static struct sbi_hart_boot_data boot_data[NR_CPUS];

static int sbi_cpu_start(unsigned int cpuid, struct task_struct *tidle)
{
    // ...
    struct sbi_hart_boot_data *bdata = &boot_data[cpuid];
    // ...
    hsm_data = __pa(bdata);  // 现在可以正常工作
    return sbi_hsm_hart_start(hartid, boot_addr, hsm_data);
}
```

### 关键变化

1. **存储方式变更**: 从`DEFINE_PER_CPU`改为静态数组`static struct sbi_hart_boot_data boot_data[NR_CPUS]`
2. **访问方式变更**: 从`&per_cpu(boot_data, cpuid)`改为`&boot_data[cpuid]`
3. **内存位置变更**: 数据从可能的vmalloc区域移动到内核镜像中

## 数据结构分析

### sbi_hart_boot_data结构体

```c
/**
 * struct sbi_hart_boot_data - Hart specific boot used during booting and
 *                             cpu hotplug.
 * @task_ptr: A pointer to the hart specific tp
 * @stack_ptr: A pointer to the hart specific sp
 */
struct sbi_hart_boot_data {
    void *task_ptr;
    void *stack_ptr;
};
```

这个结构体很小，只包含两个指针，因此使用静态数组不会显著增加内存使用。

## 修复原理

### 内存布局对比

**修复前 (使用per-cpu变量):**
- 数据可能位于vmalloc区域
- `__pa()`对vmalloc地址无效
- 导致SBI调用失败

**修复后 (使用静态数组):**
- 数据位于内核镜像的.data段
- `__pa()`可以正确转换地址
- SBI调用成功

### 为什么静态数组可行

1. **内存位置**: 静态数组位于内核镜像中，有确定的物理地址映射
2. **大小合理**: `struct sbi_hart_boot_data`只有16字节(64位系统)，`NR_CPUS`个实例不会占用太多内存
3. **访问简单**: 直接数组索引访问，无需复杂的per-cpu机制

## 影响的系统配置

### 触发条件

1. **NUMA启用**: `CONFIG_NUMA=y`
2. **调试虚拟地址**: `CONFIG_DEBUG_VIRTUAL=y`(用于检测问题)
3. **强制页面分配**: 启动参数`percpu_alloc=page`
4. **稀疏NUMA配置**: 节点间距离很大的系统

### 受影响的平台

- **主要**: Sophgo SG2042 (NUMA=y SMP启动)
- **测试**: QEMU virt机器 (通过特定配置重现)
- **潜在**: 所有启用NUMA的RISC-V SMP系统

## 错误现象

### 内核日志

```
[    0.083192] smp: Bringing up secondary CPUs ...
[    0.086722] ------------[ cut here ]------------
[    0.086849] virt_to_phys used for non-linear address: (____ptrval____) (0xff2000000001d080)
[    0.088001] WARNING: CPU: 0 PID: 1 at arch/riscv/mm/physaddr.c:14 __virt_to_phys+0xe/0xf0
...
[    1.179875] CPU1: failed to come online
[    1.190324] smp: Brought up 1 node, 1 CPU
```

### 问题分析

1. **警告信息**: `virt_to_phys used for non-linear address`表明尝试转换vmalloc地址
2. **CPU启动失败**: `CPU1: failed to come online`显示辅助CPU无法启动
3. **系统降级**: 最终只有一个CPU在线运行

## 相关提交

### 引入问题的提交

**Commit:** 6b9f29b81b15 ("riscv: Enable pcpu page first chunk allocator")  
**作者:** Alexandre Ghiti <alexghiti@rivosinc.com>  
**目的:** 为RISC-V启用页面percpu分配器作为后备方案  
**副作用:** 在某些配置下导致SBI启动失败  

### 修复提交

**Commit:** 02c725cd55eb ("riscv: cpu_ops_sbi: Use static array for boot_data")  
**修复方法:** 使用静态数组替代per-cpu变量  
**优点:** 简单有效，内存开销小  

## 技术要点总结

### 核心问题

1. **地址转换**: vmalloc地址无法通过`__pa()`转换为物理地址
2. **SBI接口**: SBI HSM扩展需要真实的物理地址
3. **percpu机制**: 页面percpu分配器将数据放在vmalloc区域

### 解决方案

1. **静态分配**: 使用编译时确定的静态数组
2. **内核镜像**: 数据位于内核镜像的可预测位置
3. **简化访问**: 避免复杂的per-cpu地址计算

### 设计权衡

1. **内存使用**: 轻微增加静态内存使用
2. **可靠性**: 显著提高系统启动可靠性
3. **兼容性**: 保持与现有代码的兼容性

## 验证方法

### 重现问题

```bash
qemu-system-riscv64 -M virt -smp 2 -nographic \
  -kernel arch/riscv/boot/Image \
  -append "percpu_alloc=page"
```

配置要求:
- `CONFIG_NUMA=y`
- `CONFIG_DEBUG_VIRTUAL=y`

### 验证修复

应用patch后，相同的QEMU命令应该能够成功启动所有CPU，不再出现地址转换警告。

## 结论

这个patch通过将`sbi_hart_boot_data`从per-cpu变量改为静态数组，有效解决了在启用页面percpu分配器时SBI HSM启动失败的问题。修复方案简单直接，内存开销最小，是一个优雅的解决方案。这个问题突出了在内核开发中需要仔细考虑不同内存分配策略对地址转换的影响。