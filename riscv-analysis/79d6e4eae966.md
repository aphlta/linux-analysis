# RISC-V cmpxchg64 优化实现分析

## Commit 信息
- **Commit ID**: 79d6e4eae9662b9103fecf94d52b44deca56743c
- **作者**: Jisheng Zhang <jszhang@kernel.org>
- **提交日期**: 2024年3月25日
- **标题**: riscv: cmpxchg: implement arch_cmpxchg64_{relaxed|acquire|release}
- **审核者**: Andrea Parri <parri.andrea@gmail.com>
- **维护者**: Palmer Dabbelt <palmer@rivosinc.com>

## 1. Patch 修改内容详细分析

### 1.1 修改的文件
- **文件**: `arch/riscv/include/asm/cmpxchg.h`
- **修改行数**: +18行
- **修改类型**: 新增函数宏定义

### 1.2 具体代码修改

在 `arch/riscv/include/asm/cmpxchg.h` 文件末尾新增了三个64位cmpxchg变体的宏定义：

```c
#define arch_cmpxchg64_relaxed(ptr, o, n)                              \
({                                                                     \
       BUILD_BUG_ON(sizeof(*(ptr)) != 8);                              \
       arch_cmpxchg_relaxed((ptr), (o), (n));                          \
})

#define arch_cmpxchg64_acquire(ptr, o, n)                              \
({                                                                     \
       BUILD_BUG_ON(sizeof(*(ptr)) != 8);                              \
       arch_cmpxchg_acquire((ptr), (o), (n));                          \
})

#define arch_cmpxchg64_release(ptr, o, n)                              \
({                                                                     \
       BUILD_BUG_ON(sizeof(*(ptr)) != 8);                              \
       arch_cmpxchg_release((ptr), (o), (n));                          \
})
```

### 1.3 修改原理分析

#### 1.3.1 设计思路
这些宏定义实际上是对现有 `arch_cmpxchg_*` 函数的封装，主要目的是：

1. **类型安全检查**: 通过 `BUILD_BUG_ON(sizeof(*(ptr)) != 8)` 确保操作的是64位数据
2. **语义明确**: 明确表示这是64位原子比较交换操作
3. **内存序语义**: 提供不同内存序语义的变体
   - `relaxed`: 无内存序约束，性能最优
   - `acquire`: 获取语义，防止后续内存访问重排到当前操作之前
   - `release`: 释放语义，防止之前的内存访问重排到当前操作之后

#### 1.3.2 底层实现机制
这些宏最终调用的是已有的 `arch_cmpxchg_*` 实现，该实现基于：

1. **LR/SC指令对**: 对于不支持原生CAS的情况
   ```assembly
   lr.d    t0, (ptr)     # Load Reserved
   bne     t0, old, fail # 比较
   sc.d    t1, new, (ptr) # Store Conditional
   ```

2. **AMO指令**: 对于支持原生原子操作的情况
   ```assembly
   amocas.d.aqrl old, new, (ptr)
   ```

## 2. 相关代码修改的技术原理

### 2.1 RISC-V内存模型
RISC-V采用弱内存模型（Weak Memory Model），特点：
- 不保证内存访问的全局顺序
- 需要显式内存屏障来保证顺序
- 支持多种内存序语义

### 2.2 内存序语义实现

#### 2.2.1 Relaxed语义
```c
#define arch_cmpxchg_relaxed(ptr, o, n)                                \
    _arch_cmpxchg((ptr), (o), (n),                                    \
                  SC_SFX(""), CAS_SFX(""),                            \
                  SC_PREPEND(""), SC_APPEND(""),                      \
                  CAS_PREPEND(""), CAS_APPEND(""))
```
- 无内存屏障
- 性能最优
- 适用于不需要内存序保证的场景

#### 2.2.2 Acquire语义
```c
#define arch_cmpxchg_acquire(ptr, o, n)                                \
    _arch_cmpxchg((ptr), (o), (n),                                    \
                  SC_SFX(""), CAS_SFX(""),                            \
                  SC_PREPEND(""), SC_APPEND(RISCV_ACQUIRE_BARRIER),    \
                  CAS_PREPEND(""), CAS_APPEND(RISCV_ACQUIRE_BARRIER))
```
- 添加acquire屏障: `fence r,rw`
- 防止后续内存访问重排到当前操作之前

#### 2.2.3 Release语义
```c
#define arch_cmpxchg_release(ptr, o, n)                                \
    _arch_cmpxchg((ptr), (o), (n),                                    \
                  SC_SFX(""), CAS_SFX(""),                            \
                  SC_PREPEND(RISCV_RELEASE_BARRIER), SC_APPEND(""),    \
                  CAS_PREPEND(RISCV_RELEASE_BARRIER), CAS_APPEND(""))
```
- 添加release屏障: `fence rw,w`
- 防止之前的内存访问重排到当前操作之后

### 2.3 LOCKREF优化机制

#### 2.3.1 LOCKREF结构
```c
struct lockref {
    union {
#if USE_CMPXCHG_LOCKREF
        aligned_u64 lock_count;  // 64位原子操作
#endif
        struct {
            spinlock_t lock;     // 自旋锁
            int count;           // 引用计数
        };
    };
};
```

#### 2.3.2 优化原理
传统方式：
```c
spin_lock(&lockref->lock);
lockref->count++;
spin_unlock(&lockref->lock);
```

优化后的方式：
```c
CMPXCHG_LOOP(
    new.count++;
,
    return;
);
```

使用64位cmpxchg一次性操作lock和count，避免了锁竞争。

## 3. 相关提交分析

### 3.1 前置提交
**Commit**: eb1e5037294652ddf1437f62292c0727183f11ae
- **标题**: riscv: select ARCH_USE_CMPXCHG_LOCKREF
- **作用**: 启用基于cmpxchg的lockref实现
- **性能提升**: 
  - TH1520平台: 11.2%
  - JH7110平台: 12.0%

### 3.2 测试用例
使用Linus的测试用例进行性能测试：
- **链接**: http://marc.info/?l=linux-fsdevel&m=137782380714721&w=4
- **测试内容**: 文件系统操作中的lockref性能

### 3.3 后续优化空间
虽然在当前硬件平台（TH1520、JH7110）上没有明显性能提升，但为未来硬件平台预留了优化空间：
- 更高效的fence实现
- 更优化的lr.d/sc.d硬件实现

## 4. 技术影响分析

### 4.1 性能影响

#### 4.1.1 正面影响
1. **减少锁竞争**: 使用无锁算法替代自旋锁
2. **提高并发性**: 多核环境下的更好扩展性
3. **降低延迟**: 避免锁等待时间

#### 4.1.2 适用场景
- 高频率的引用计数操作
- 多核并发访问场景
- 文件系统操作（dentry、inode引用计数）

### 4.2 代码质量影响

#### 4.2.1 API完整性
- 提供了完整的64位cmpxchg API
- 与其他架构（ARM64、x86）保持一致
- 支持不同内存序语义

#### 4.2.2 类型安全
- 编译时检查确保64位操作
- 防止错误的数据类型使用

### 4.3 维护性影响

#### 4.3.1 代码复用
- 复用现有的cmpxchg实现
- 减少重复代码

#### 4.3.2 架构一致性
- 与其他架构的API保持一致
- 便于跨架构代码移植

## 5. 实际应用场景

### 5.1 文件系统
```c
// fs/dcache.c 中的dentry引用计数
static inline int dentry_cmp(const struct dentry *dentry, 
                            const unsigned char *ct, unsigned tcount)
{
    // 使用lockref进行原子操作
    lockref_get(&dentry->d_lockref);
    // ...
}
```

### 5.2 VFS层
```c
// fs/inode.c 中的inode引用计数
void ihold(struct inode *inode)
{
    WARN_ON(atomic_read(&inode->i_count) == 0);
    atomic_inc(&inode->i_count);
}
```

### 5.3 网络子系统
在网络数据包处理中的引用计数管理。

## 6. 总结

### 6.1 主要贡献
1. **完善API**: 实现了RISC-V架构下完整的64位cmpxchg API
2. **性能优化**: 为lockref优化提供了基础支持
3. **架构统一**: 与其他主流架构保持API一致性

### 6.2 技术价值
1. **无锁编程支持**: 提供了高效的无锁原子操作原语
2. **内存序控制**: 支持不同的内存序语义
3. **未来扩展**: 为未来硬件优化预留空间

### 6.3 实际效果
虽然在当前硬件平台上性能提升不明显，但这个patch为RISC-V架构提供了：
- 完整的原子操作API
- 与主流架构的兼容性
- 未来硬件优化的基础

这是一个典型的基础设施改进patch，重点在于API完整性和架构一致性，而非立即的性能提升。