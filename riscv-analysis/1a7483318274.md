# RISC-V USER_STACKTRACE支持补丁分析

## 基本信息

**Commit ID:** 1a7483318274  
**标题:** riscv: stacktrace: Add USER_STACKTRACE support  
**作者:** Jinjie Ruan <ruanjinjie@huawei.com>  
**测试者:** Jinjie Ruan <ruanjinjie@huawei.com>  
**抄送:** Björn Töpel <bjorn@kernel.org>  
**链接:** https://lore.kernel.org/r/20240708032847.2998158-3-ruanjinjie@huawei.com  
**签署者:** Palmer Dabbelt <palmer@rivosinc.com>  

## 补丁概述

这个补丁为RISC-V架构添加了用户空间栈跟踪(USER_STACKTRACE)支持，主要通过实现`arch_stack_walk_user()`函数来简化`perf_callchain_user()`的实现。

## 详细修改内容

### 1. 配置选项修改 (arch/riscv/Kconfig)

```diff
+       select USER_STACKTRACE_SUPPORT
```

- 在RISC-V架构配置中添加了`USER_STACKTRACE_SUPPORT`选项
- 这使得RISC-V架构能够支持用户空间栈跟踪功能
- 该选项启用后，内核可以在ftrace和perf等工具中提供用户空间的调用栈信息

### 2. 栈跟踪核心实现 (arch/riscv/kernel/stacktrace.c)

#### 新增函数：`unwind_user_frame()`

```c
static unsigned long unwind_user_frame(stack_trace_consume_fn consume_entry,
                                       void *cookie, unsigned long fp,
                                       unsigned long reg_ra)
{
    struct stackframe buftail;
    unsigned long ra = 0;
    unsigned long __user *user_frame_tail =
        (unsigned long __user *)(fp - sizeof(struct stackframe));

    /* Check accessibility of one struct frame_tail beyond */
    if (!access_ok(user_frame_tail, sizeof(buftail)))
        return 0;
    if (__copy_from_user_inatomic(&buftail, user_frame_tail,
                                  sizeof(buftail)))
        return 0;

    ra = reg_ra ? : buftail.ra;

    fp = buftail.fp;
    if (!ra || !consume_entry(cookie, ra))
        return 0;

    return fp;
}
```

**功能分析:**
- 从用户空间栈帧中提取返回地址和下一个栈帧指针
- 使用`access_ok()`检查用户空间地址的可访问性
- 使用`__copy_from_user_inatomic()`安全地从用户空间复制数据
- 优先使用传入的`reg_ra`参数，如果为0则使用栈帧中的返回地址
- 通过回调函数`consume_entry`处理获取到的返回地址

#### 新增函数：`arch_stack_walk_user()`

```c
void arch_stack_walk_user(stack_trace_consume_fn consume_entry, void *cookie,
                          const struct pt_regs *regs)
{
    unsigned long fp = 0;

    fp = regs->s0;
    if (!consume_entry(cookie, regs->epc))
        return;

    fp = unwind_user_frame(consume_entry, cookie, fp, regs->ra);
    while (fp && !(fp & 0x7))
        fp = unwind_user_frame(consume_entry, cookie, fp, 0);
}
```

**功能分析:**
- 实现了通用的用户空间栈遍历接口
- 从寄存器上下文`pt_regs`开始遍历
- 首先处理当前程序计数器(`regs->epc`)作为第一个地址
- 使用帧指针(`regs->s0`)开始栈帧遍历
- 循环调用`unwind_user_frame()`直到栈帧指针无效或未对齐(检查低3位)

### 3. 性能分析简化 (arch/riscv/kernel/perf_callchain.c)

#### 修改前的实现
原来的`perf_callchain_user()`函数包含了复杂的用户空间栈遍历逻辑，需要手动处理栈帧解析。

#### 修改后的实现

```c
void perf_callchain_user(struct perf_callchain_entry_ctx *entry,
                         struct pt_regs *regs)
{
    if (perf_guest_state()) {
        /* TODO: We don't support guest os callchain now */
        return;
    }

    arch_stack_walk_user(fill_callchain, entry, regs);
}
```

**改进分析:**
- 代码大幅简化，从原来的复杂实现减少到仅调用`arch_stack_walk_user()`
- 移除了大量重复的栈遍历代码
- 提高了代码的可维护性和可读性
- 统一了用户空间栈遍历的实现方式

## 技术原理分析

### 1. RISC-V栈帧结构

RISC-V使用标准的栈帧结构：
```
栈帧布局:
+------------------+ <- fp (frame pointer)
|   previous fp    |
+------------------+
|   return addr    |
+------------------+
|   local vars     |
+------------------+
```

### 2. 用户空间访问安全性

- **`access_ok()`检查:** 验证用户空间地址是否在有效范围内
- **`__copy_from_user_inatomic()`:** 原子性地从用户空间复制数据，避免页面错误
- **地址对齐检查:** 通过`!(fp & 0x7)`确保栈指针8字节对齐

### 3. 栈遍历算法

1. 从当前寄存器上下文开始
2. 提取帧指针(s0寄存器)和返回地址(ra寄存器)
3. 递归遍历每个栈帧，直到遇到无效指针
4. 每个有效地址通过回调函数传递给调用者

## 相关提交分析

这个补丁是一个系列补丁的一部分，从链接`20240708032847.2998158-3`可以看出这是第3个补丁。该系列补丁可能包括：

1. 基础架构准备
2. 通用接口定义
3. **当前补丁：RISC-V具体实现**
4. 可能的测试和文档更新

## 功能验证

### 1. ftrace用户栈跟踪测试

```bash
# cd /sys/kernel/debug/tracing
# echo 1 > options/userstacktrace
# echo 1 > options/sym-userobj
# echo 1 > events/sched/sched_process_fork/enable
# cat trace
```

**预期输出:**
```
bash-178     [000] ...1.    97.968395: sched_process_fork: comm=bash pid=178 child_comm=bash child_pid=231
bash-178     [000] ...1.    97.970075: <user stack trace>
 => /lib/libc.so.6[+0xb5090]
```

### 2. perf调用图测试

```bash
# perf record -e cpu-clock --call-graph fp top
# perf report --call-graph
```

**预期输出:**
```
66.54%     0.00%  top      [kernel.kallsyms]            [k] ret_from_exception
|
---ret_from_exception
   |
   |--58.97%--do_trap_ecall_u
   |          |
   |          |--17.34%--__riscv_sys_read
   |          |          ksys_read
   |          |          |
   |          |           --16.88%--vfs_read
   |          |                     |
   |          |                     |--10.90%--seq_read
```

## 编译要求

**重要提示:** 在RISC-V平台上，被采样的程序和C库需要使用`-fno-omit-frame-pointer`编译选项，否则用户栈将不包含函数帧信息。

## 影响和意义

### 1. 功能增强
- 为RISC-V架构提供了完整的用户空间栈跟踪支持
- 增强了调试和性能分析能力
- 支持ftrace和perf等工具的用户空间分析功能

### 2. 代码质量提升
- 统一了栈遍历接口，减少了代码重复
- 提高了代码的可维护性
- 遵循了Linux内核的通用架构设计模式

### 3. 生态系统完善
- 使RISC-V架构在调试工具支持方面更加完善
- 为开发者提供了更好的性能分析工具
- 促进了RISC-V生态系统的发展

## 总结

这个补丁成功地为RISC-V架构添加了用户空间栈跟踪支持，通过实现标准的`arch_stack_walk_user()`接口，不仅简化了现有的perf调用链实现，还为未来的调试和分析工具提供了统一的基础设施。补丁的实现考虑了用户空间访问的安全性，并且经过了充分的测试验证。