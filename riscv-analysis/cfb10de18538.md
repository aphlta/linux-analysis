# RISC-V KASAN内核栈大小修复分析 - Commit cfb10de18538

## 基本信息

- **Commit ID**: cfb10de18538e383dbc4f3ce7f477ce49287ff3d
- **作者**: Alexandre Ghiti <alexghiti@rivosinc.com>
- **提交日期**: 2024年9月17日 17:03:28 +0200
- **标题**: riscv: Fix kernel stack size when KASAN is enabled
- **修复的问题**: a7555f6b62e7 ("riscv: stack: Add config of thread stack size")
- **报告者**: syzbot+ba9eac24453387a9d502@syzkaller.appspotmail.com
- **邮件列表链接**: https://lore.kernel.org/r/20240917150328.59831-1-alexghiti@rivosinc.com
- **签署者**: Palmer Dabbelt <palmer@rivosinc.com>

## 问题描述

### 核心问题

当KASAN（Kernel Address Sanitizer）启用时，内核栈大小配置存在一个严重的配置时序问题：

1. **配置依赖问题**: 原始实现使用Kconfig来选择内核栈大小，在KASAN启用时将默认大小翻倍
2. **时序问题**: 这种方法只有在从一开始就选择KASAN时才有效
3. **后期配置失效**: 如果KASAN配置是后来添加的（例如使用menuconfig），`CONFIG_THREAD_SIZE_ORDER`不会更新，保持默认大小
4. **栈溢出风险**: 默认大小对于KASAN来说不够，导致内核栈溢出

### 问题根源分析

**原始实现的缺陷**:
```kconfig
# 修改前的配置
config THREAD_SIZE_ORDER
    int "Kernel stack size (in power-of-two numbers of page size)" if VMAP_STACK && EXPERT
    range 0 4
    default 1 if 32BIT && !KASAN
    default 3 if 64BIT && KASAN  # 这行在后期启用KASAN时不会生效
    default 2
```

**问题场景**:
1. 用户首次配置内核时未启用KASAN
2. `CONFIG_THREAD_SIZE_ORDER`被设置为默认值（32位为1，64位为2）
3. 后来用户通过menuconfig启用KASAN
4. `CONFIG_THREAD_SIZE_ORDER`值不会自动更新
5. 内核栈大小仍然是原来的默认值，对KASAN不够

## 代码修改详细分析

### 修改的文件

1. **arch/riscv/Kconfig** (3行修改：+1, -2)
2. **arch/riscv/include/asm/thread_info.h** (7行修改：+6, -1)

### 具体修改内容

#### 1. Kconfig修改

```diff
@@ -777,8 +777,7 @@ config IRQ_STACKS
 config THREAD_SIZE_ORDER
        int "Kernel stack size (in power-of-two numbers of page size)" if VMAP_STACK && EXPERT
        range 0 4
-       default 1 if 32BIT && !KASAN
-       default 3 if 64BIT && KASAN
+       default 1 if 32BIT
        default 2
        help
          Specify the Pages of thread stack size (from 4KB to 64KB), which also
```

**修改说明**:
- 移除了与KASAN相关的条件判断
- 简化为基于架构的默认值：32位系统默认为1，其他情况默认为2
- 将KASAN相关的栈大小计算逻辑移到头文件中

#### 2. thread_info.h修改

```diff
@@ -13,7 +13,12 @@
 #include <linux/sizes.h>
 
 /* thread information allocation */
-#define THREAD_SIZE_ORDER      CONFIG_THREAD_SIZE_ORDER
+#ifdef CONFIG_KASAN
+#define KASAN_STACK_ORDER      1
+#else
+#define KASAN_STACK_ORDER      0
+#endif
+#define THREAD_SIZE_ORDER      (CONFIG_THREAD_SIZE_ORDER + KASAN_STACK_ORDER)
 #define THREAD_SIZE            (PAGE_SIZE << THREAD_SIZE_ORDER)
```

**修改说明**:
- 引入`KASAN_STACK_ORDER`宏，当KASAN启用时为1，否则为0
- 重新定义`THREAD_SIZE_ORDER`为配置值加上KASAN额外需求
- 这样确保无论何时启用KASAN，都会自动增加栈大小

## 修改原理分析

### 1. 问题解决机制

**新的实现方式**:
- **编译时计算**: 将KASAN栈大小调整从配置时移到编译时
- **动态适应**: 无论KASAN何时启用，都会自动调整栈大小
- **透明处理**: 用户不需要手动调整栈大小配置

### 2. 栈大小计算逻辑

**修改前**:
```c
// 依赖Kconfig的条件判断
// 如果后期启用KASAN，配置不会更新
THREAD_SIZE_ORDER = CONFIG_THREAD_SIZE_ORDER  // 可能不足
```

**修改后**:
```c
// 编译时动态计算
KASAN_STACK_ORDER = CONFIG_KASAN ? 1 : 0
THREAD_SIZE_ORDER = CONFIG_THREAD_SIZE_ORDER + KASAN_STACK_ORDER
```

### 3. 栈大小对比

| 架构 | KASAN状态 | 修改前 | 修改后 | 页面数 | 实际大小 |
|------|-----------|--------|--------|--------|----------|
| 32位 | 禁用 | 1 | 1 | 2页 | 8KB |
| 32位 | 启用 | 1* | 2 | 4页 | 16KB |
| 64位 | 禁用 | 2 | 2 | 4页 | 16KB |
| 64位 | 启用 | 3** | 3 | 8页 | 32KB |

*注：如果KASAN是后期启用的，仍然是1，导致栈溢出  
**注：只有从开始就启用KASAN才是3

## 相关提交分析

### 1. 被修复的原始提交: a7555f6b62e7

**标题**: "riscv: stack: Add config of thread stack size"  
**作者**: Guo Ren <guoren@linux.alibaba.com>  
**日期**: 2023年6月14日  

**原始实现**:
```c
// 原来的实现方式
#ifdef CONFIG_KASAN
#define KASAN_STACK_ORDER 1
#else
#define KASAN_STACK_ORDER 0
#endif

#ifdef CONFIG_64BIT
#define THREAD_SIZE_ORDER      (2 + KASAN_STACK_ORDER)
#else
#define THREAD_SIZE_ORDER      (1 + KASAN_STACK_ORDER)
#endif
```

**问题**:
- 将逻辑移到了Kconfig中
- 创建了配置时序依赖问题
- 没有考虑后期配置变更的场景

### 2. 相关的KASAN支持提交

通过分析git历史，可以看到RISC-V的KASAN支持经历了多次改进：

- **KASAN基础支持**: 早期的KASAN移植
- **栈大小配置**: a7555f6b62e7引入了可配置的栈大小
- **本次修复**: cfb10de18538修复了配置时序问题

## 技术影响分析

### 1. 内存使用影响

**KASAN启用时的额外开销**:
- 每个线程额外使用一个页面（4KB或更多）
- 对于大量线程的系统，内存开销显著
- 但这是KASAN正常工作的必要代价

### 2. 性能影响

**栈大小增加的影响**:
- **缓存局部性**: 更大的栈可能影响缓存性能
- **内存压力**: 在内存受限的系统中可能造成压力
- **安全性提升**: 避免了栈溢出导致的系统崩溃

### 3. 兼容性影响

**向后兼容性**:
- 对于未启用KASAN的系统，行为保持不变
- 对于启用KASAN的系统，自动获得正确的栈大小
- 修复了之前可能导致系统不稳定的配置问题

## Bug报告分析

### 1. Syzbot报告

**报告链接**: https://lore.kernel.org/all/000000000000eb301906222aadc2@google.com/  
**报告者**: syzbot+ba9eac24453387a9d502@syzkaller.appspotmail.com

**问题现象**:
- 在启用KASAN的RISC-V系统上出现栈溢出
- 系统在特定工作负载下崩溃
- 错误与内核栈空间不足相关

### 2. 问题复现条件

1. **配置序列**:
   - 首次配置内核时未启用KASAN
   - 后来通过menuconfig启用KASAN
   - 重新编译内核

2. **运行环境**:
   - RISC-V 64位系统
   - 启用KASAN的内核
   - 高内存压力或深度调用栈的工作负载

## 解决方案评估

### 1. 修复方案的优点

**技术优势**:
- **简单有效**: 将逻辑从配置时移到编译时
- **自动适应**: 无需用户手动干预
- **向后兼容**: 不影响现有配置
- **维护性好**: 减少了配置复杂性

**安全优势**:
- **消除栈溢出风险**: 确保KASAN有足够的栈空间
- **提高系统稳定性**: 避免因栈不足导致的崩溃
- **改善调试体验**: KASAN能够正常工作

### 2. 潜在的替代方案

**方案A: 改进Kconfig依赖**
```kconfig
# 可能的改进方案
config THREAD_SIZE_ORDER
    int
    default 1 if 32BIT && !KASAN
    default 2 if 32BIT && KASAN
    default 2 if 64BIT && !KASAN
    default 3 if 64BIT && KASAN
```

**缺点**: 仍然存在配置时序问题

**方案B: 运行时检测**
```c
// 运行时动态调整
if (IS_ENABLED(CONFIG_KASAN)) {
    thread_size_order += 1;
}
```

**缺点**: 增加运行时开销，复杂性高

**选择当前方案的原因**:
- 编译时确定，无运行时开销
- 简单直接，易于理解和维护
- 完全解决了配置时序问题

## 测试和验证

### 1. 测试场景

**配置测试**:
1. 从头启用KASAN的配置
2. 后期启用KASAN的配置
3. 禁用KASAN的配置
4. 在不同架构（32位/64位）上的测试

**功能测试**:
1. KASAN检测功能正常工作
2. 系统在高负载下稳定运行
3. 内存使用符合预期

### 2. 验证方法

**编译时验证**:
```bash
# 检查生成的栈大小定义
grep THREAD_SIZE_ORDER build/arch/riscv/include/generated/asm-offsets.h
```

**运行时验证**:
```c
// 在内核中检查实际栈大小
printk("Thread stack size: %lu bytes\n", THREAD_SIZE);
```

## 总结

### 1. 修复效果

这个patch成功解决了RISC-V架构中KASAN内核栈大小配置的关键问题：

- **根本性修复**: 从根源上解决了配置时序依赖问题
- **自动化处理**: 无需用户手动调整配置
- **稳定性提升**: 消除了栈溢出导致的系统崩溃风险
- **维护性改善**: 简化了配置逻辑，减少了维护负担

### 2. 技术意义

**架构层面**:
- 展示了如何正确处理条件编译和配置依赖
- 提供了处理类似问题的参考模式
- 改善了RISC-V架构的KASAN支持质量

**工程层面**:
- 体现了配置系统设计的重要性
- 说明了编译时计算相比配置时计算的优势
- 强调了向后兼容性在内核开发中的重要性

### 3. 经验教训

**设计原则**:
1. **避免配置时序依赖**: 尽量在编译时而非配置时处理条件逻辑
2. **考虑配置变更场景**: 设计时要考虑用户后期修改配置的情况
3. **保持简单性**: 复杂的配置逻辑容易引入bug
4. **充分测试**: 特别是配置变更和边界情况的测试

**最佳实践**:
- 使用编译时宏而非配置时条件来处理动态需求
- 在头文件中集中处理相关的计算逻辑
- 保持配置选项的独立性，避免隐式依赖
- 提供清晰的文档说明配置的影响

这个修复不仅解决了当前的问题，还为未来类似问题的处理提供了良好的参考模式。