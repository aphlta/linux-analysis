# Patch Analysis: 36dec9e44805

## 基本信息

**Commit ID**: 36dec9e44805f80d32277be76d16c88373bdc20d  
**作者**: Yunhui Cui <cuiyunhui@bytedance.com>  
**提交日期**: Wed Feb 26 14:32:06 2025 +0800  
**标题**: RISC-V: selftests: Add TEST_ZICBOM into CBO tests  
**邮件链接**: https://lore.kernel.org/r/20250226063206.71216-4-cuiyunhui@bytedance.com  
**维护者**: Alexandre Ghiti <alexghiti@rivosinc.com>  

## Patch描述

这个patch为RISC-V的CBO（Cache Block Operations）测试套件添加了对Zicbom扩展的测试支持。当Zicbom扩展存在时，测试验证cbo.clean和cbo.flush指令可以正常执行。由于软件无法直接验证clean/flush功能的实际效果，测试主要判断这些指令是否能够合法执行而不产生非法指令异常。

## 详细修改内容

### 1. 新增测试函数

#### test_zicbom()函数
```c
static void test_zicbom(void *arg)
{
    struct riscv_hwprobe pair = {
        .key = RISCV_HWPROBE_KEY_ZICBOM_BLOCK_SIZE,
    };
    cpu_set_t *cpus = (cpu_set_t *)arg;
    __u64 block_size;
    long rc;

    rc = riscv_hwprobe(&pair, 1, sizeof(cpu_set_t), (unsigned long *)cpus, 0);
    block_size = pair.value;
    ksft_test_result(rc == 0 && pair.key == RISCV_HWPROBE_KEY_ZICBOM_BLOCK_SIZE &&
                     is_power_of_2(block_size), "Zicbom block size\n");
    ksft_print_msg("Zicbom block size: %llu\n", block_size);

    illegal_insn = false;
    cbo_clean(&mem[block_size]);
    ksft_test_result(!illegal_insn, "cbo.clean\n");

    illegal_insn = false;
    cbo_flush(&mem[block_size]);
    ksft_test_result(!illegal_insn, "cbo.flush\n");
}
```

这个函数执行三个测试：
1. **块大小验证**: 验证Zicbom块大小是2的幂次方
2. **cbo.clean测试**: 验证cbo.clean指令可以正常执行
3. **cbo.flush测试**: 验证cbo.flush指令可以正常执行

#### test_no_cbo_inval()函数
```c
static void test_no_cbo_inval(void *arg)
{
    ksft_print_msg("Testing cbo.inval instruction remain privileged\n");
    illegal_insn = false;
    cbo_inval(&mem[0]);
    ksft_test_result(illegal_insn, "No cbo.inval\n");
}
```

这个函数从原来的test_no_zicbom()中分离出来，专门测试cbo.inval指令在用户态下应该产生非法指令异常。

### 2. 修改现有函数

#### test_no_zicbom()函数重构
原来的函数测试3个指令（clean、flush、inval），现在只测试2个指令（clean、flush）：
```c
static void test_no_zicbom(void *arg)
{
    ksft_print_msg("Testing Zicbom instructions remain privileged\n");

    illegal_insn = false;
    cbo_clean(&mem[0]);
    ksft_test_result(illegal_insn, "No cbo.clean\n");

    illegal_insn = false;
    cbo_flush(&mem[0]);
    ksft_test_result(illegal_insn, "No cbo.flush\n");
}
```

#### check_no_zicbo_cpus()函数通用化
原来的check_no_zicboz_cpus()函数被重命名并通用化，可以检查任意CBO扩展：
```c
static void check_no_zicbo_cpus(cpu_set_t *cpus, __u64 cbo)
{
    // ...
    cbostr = cbo == RISCV_HWPROBE_EXT_ZICBOZ ? "Zicboz" : "Zicbom";
    
    if (pair.value & cbo)
        ksft_exit_fail_msg("%s is only present on a subset of harts.\n"
                           "Use taskset to select a set of harts where %s\n"
                           "presence (present or not) is consistent for each hart\n",
                           cbostr, cbostr);
    // ...
}
```

### 3. 测试框架更新

#### 新增测试类型
```c
enum {
    TEST_ZICBOZ,
    TEST_NO_ZICBOZ,
    TEST_ZICBOM,        // 新增
    TEST_NO_ZICBOM,
    TEST_NO_CBO_INVAL,  // 新增
};
```

#### 更新测试配置
```c
static struct test_info {
    bool enabled;
    unsigned int nr_tests;
    void (*test_fn)(void *arg);
} tests[] = {
    [TEST_ZICBOZ]       = { .nr_tests = 3, test_zicboz },
    [TEST_NO_ZICBOZ]    = { .nr_tests = 1, test_no_zicboz },
    [TEST_ZICBOM]       = { .nr_tests = 3, test_zicbom },     // 新增
    [TEST_NO_ZICBOM]    = { .nr_tests = 2, test_no_zicbom }, // 从3改为2
    [TEST_NO_CBO_INVAL] = { .nr_tests = 1, test_no_cbo_inval }, // 新增
};
```

#### main()函数逻辑更新
```c
// 添加Zicbom检测逻辑
if (pair.value & RISCV_HWPROBE_EXT_ZICBOM) {
    tests[TEST_ZICBOM].enabled = true;
    tests[TEST_NO_ZICBOM].enabled = false;
} else {
    check_no_zicbo_cpus(&cpus, RISCV_HWPROBE_EXT_ZICBOM);
}

// 在--sigill模式下启用新测试
if (argc > 1 && !strcmp(argv[1], "--sigill")) {
    // ...
    tests[TEST_NO_CBO_INVAL].enabled = true; // 新增
}
```

## 代码修改原理

### 1. Zicbom扩展支持

Zicbom（Cache Block Management Operations）是RISC-V的一个标准扩展，提供了缓存块管理操作：
- **cbo.clean**: 将缓存块写回到下一级存储层次，但保留在缓存中
- **cbo.flush**: 将缓存块写回到下一级存储层次并从缓存中移除
- **cbo.inval**: 使缓存块无效（仅在特权模式下可用）

### 2. 用户态访问控制

根据相关提交de70b532f91b，内核现在允许用户态程序使用cbo.clean和cbo.flush指令：
```c
if (riscv_has_extension_unlikely(RISCV_ISA_EXT_ZICBOM))
    current->thread.envcfg |= ENVCFG_CBCFE;
```

但cbo.inval指令仍然只能在特权模式下使用，用户态执行会产生非法指令异常。

### 3. 硬件探测机制

通过hwprobe系统调用（commit eb1003970940添加的支持）：
- 检测Zicbom扩展是否存在
- 获取缓存块大小（必须是2的幂次方）
- 确保所有CPU核心上的扩展支持一致性

### 4. 测试策略

由于软件无法直接验证缓存操作的实际效果，测试采用以下策略：
- **正向测试**: 当扩展存在时，验证指令不会产生异常
- **负向测试**: 当扩展不存在时，验证指令会产生预期的异常
- **一致性检查**: 确保所有CPU核心上的扩展支持状态一致

## 相关提交分析

这个patch是一个三部分patch系列的最后一部分：

### 1. de70b532f91b - "RISC-V: Enable cbo.clean/flush in usermode"
- **目的**: 在用户态启用cbo.clean和cbo.flush指令
- **实现**: 通过设置ENVCFG_CBCFE位来允许用户态访问
- **影响**: 使用户态程序能够直接进行缓存管理，提高性能

### 2. eb1003970940 - "RISC-V: hwprobe: Expose Zicbom extension and its block size"
- **目的**: 通过hwprobe接口暴露Zicbom扩展信息
- **实现**: 添加RISCV_HWPROBE_KEY_ZICBOM_BLOCK_SIZE键
- **影响**: 允许用户态程序查询Zicbom支持和块大小

### 3. 36dec9e44805 - "RISC-V: selftests: Add TEST_ZICBOM into CBO tests"
- **目的**: 为新的Zicbom功能添加测试覆盖
- **实现**: 扩展现有的CBO测试框架
- **影响**: 确保Zicbom功能的正确性和回归测试

## 技术意义

### 1. 性能优化
- 允许用户态程序直接管理缓存状态
- 减少系统调用开销
- 提供更精细的缓存控制

### 2. 标准化支持
- 完整实现RISC-V Zicbom标准扩展
- 提供标准化的硬件能力查询接口
- 确保跨平台兼容性

### 3. 测试完整性
- 提供全面的功能测试
- 支持回归测试
- 验证硬件和软件的正确集成

## 潜在影响

### 1. 安全考虑
- cbo.inval仍然受限于特权模式，防止用户态程序破坏系统缓存一致性
- cbo.clean/flush的用户态访问是安全的，不会影响系统稳定性

### 2. 兼容性
- 向后兼容：不支持Zicbom的系统仍然正常工作
- 渐进式部署：可以在支持的硬件上逐步启用

### 3. 生态系统
- 为高性能计算应用提供更好的缓存控制
- 支持数据库、科学计算等对缓存敏感的应用
- 促进RISC-V在高性能领域的采用

## 总结

这个patch完善了RISC-V平台对Zicbom扩展的支持，通过添加全面的测试覆盖来确保功能的正确性。它是一个完整的三部分实现的最后一环，为RISC-V平台提供了标准化的缓存管理能力，同时保持了安全性和兼容性。测试框架的设计考虑了多核系统的一致性要求，体现了对企业级应用场景的支持。