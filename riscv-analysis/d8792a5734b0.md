# RISC-V 模块重定位安全修复补丁分析

## 基本信息

**Commit ID:** d8792a5734b0f3e58b898c2e2f910bfac48e9ee3  
**作者:** Charlie Jenkins <charlie@rivosinc.com>  
**提交日期:** 2023年11月27日  
**标题:** riscv: Safely remove entries from relocation list  

## 问题背景

### 原始问题
这个补丁修复了commit 8fd6c5142395 ("riscv: Add remaining module relocations") 引入的问题。原始提交在RISC-V架构中添加了完整的模块重定位支持，但存在以下安全隐患：

1. **并发安全问题**: 使用全局变量存储重定位列表指针，不支持多线程并发加载模块
2. **内存泄漏风险**: 在遍历和删除链表时使用非安全的迭代器，可能导致内存泄漏
3. **内存分配失败处理**: 缺少对内存分配失败的适当错误处理

### 报告者
**报告者:** Ron Economos <re@w6rz.net>  
**问题链接:** https://lore.kernel.org/linux-riscv/444de86a-7e7c-4de7-5d1d-c1c40eefa4ba@w6rz.net  

## 技术分析

### 主要修改内容

#### 1. 移除全局变量，改为栈上分配

**修改前 (全局变量):**
```c
struct hlist_head *relocation_hashtable;
struct list_head used_buckets_list;
```

**修改后 (栈上变量):**
```c
struct hlist_head *relocation_hashtable;
struct list_head used_buckets_list;
unsigned int hashtable_bits;

hashtable_bits = initialize_relocation_hashtable(num_relocations,
                                                 &relocation_hashtable);

if (hashtable_bits < 0)
    return hashtable_bits;

INIT_LIST_HEAD(&used_buckets_list);
```

#### 2. 使用安全的链表遍历

**关键改进:**
- 使用 `list_for_each_entry_safe()` 替代 `list_for_each_entry()`
- 使用 `hlist_for_each_entry_safe()` 替代 `hlist_for_each_entry()`

**修改示例:**
```c
// 修改前
list_for_each_entry(bucket_iter, &used_buckets_list, head) {
    hlist_for_each_entry(rel_head_iter, bucket_iter->bucket, node) {
        list_for_each_entry(rel_entry_iter, rel_head_iter->rel_entry, head) {

// 修改后  
list_for_each_entry_safe(bucket_iter, bucket_iter_tmp,
                         used_buckets_list, head) {
    hlist_for_each_entry_safe(rel_head_iter, rel_head_iter_tmp,
                              bucket_iter->bucket, node) {
        list_for_each_entry_safe(rel_entry_iter, rel_entry_iter_tmp,
                                 &rel_head_iter->rel_entry, head) {
```

#### 3. 增强错误处理

**内存分配失败检查:**
```c
entry = kmalloc(sizeof(*entry), GFP_KERNEL);
if (!entry)
    return -ENOMEM;

rel_head = kmalloc(sizeof(*rel_head), GFP_KERNEL);
if (!rel_head) {
    kfree(entry);
    return -ENOMEM;
}

bucket = kmalloc(sizeof(struct used_bucket), GFP_KERNEL);
if (!bucket) {
    kfree(entry);
    kfree(rel_head);
    return -ENOMEM;
}
```

#### 4. 函数签名修改

**initialize_relocation_hashtable():**
```c
// 修改前
unsigned int initialize_relocation_hashtable(unsigned int num_relocations);

// 修改后
static unsigned int
initialize_relocation_hashtable(unsigned int num_relocations,
                                struct hlist_head **relocation_hashtable);
```

**process_accumulated_relocations():**
```c
// 修改前
void process_accumulated_relocations(struct module *me);

// 修改后
static void
process_accumulated_relocations(struct module *me,
                               struct hlist_head **relocation_hashtable,
                               struct list_head *used_buckets_list);
```

### 数据结构设计

补丁涉及的核心数据结构：

```c
struct used_bucket {
    struct list_head head;        // 链表节点
    struct hlist_head *bucket;    // 指向哈希桶
};

struct relocation_head {
    struct hlist_node node;       // 哈希链表节点
    struct list_head rel_entry;  // 重定位条目列表
    void *location;               // 重定位位置
};

struct relocation_entry {
    struct list_head head;        // 链表节点
    Elf_Addr value;              // 重定位值
    unsigned int type;           // 重定位类型
};
```

## 安全性改进

### 1. 并发安全
- **问题**: 全局变量在多线程环境下存在竞争条件
- **解决**: 将重定位数据结构移到栈上，每个模块加载过程独立

### 2. 内存安全
- **问题**: 非安全的链表遍历可能导致use-after-free
- **解决**: 使用`_safe`版本的遍历宏，在删除节点前保存下一个节点的指针

### 3. 资源管理
- **问题**: 内存分配失败时缺少清理机制
- **解决**: 添加完整的错误处理路径，确保已分配的内存得到释放

## 性能影响

### 正面影响
- 支持并发模块加载，提高系统吞吐量
- 减少全局状态，降低缓存冲突

### 潜在开销
- 每次模块加载都需要重新分配哈希表
- 栈空间使用略有增加

## 测试验证

**测试者:** Björn Töpel <bjorn@rivosinc.com>  
**测试结果:** 通过测试，确认修复了原始问题

## 相关提交

### 原始问题提交
**Commit:** 8fd6c5142395 ("riscv: Add remaining module relocations")  
**作者:** Charlie Jenkins  
**日期:** 2023年11月1日  
**功能:** 添加RISC-V架构的完整模块重定位支持

### 修复链
1. **8fd6c5142395** - 引入模块重定位功能
2. **d8792a5734b0** - 修复并发安全和内存管理问题

## 影响范围

### 受影响的架构
- **主要影响:** RISC-V架构
- **文件:** `arch/riscv/kernel/module.c`

### 受影响的功能
- 内核模块动态加载
- ELF重定位处理
- ADD/SUB/SET/ULEB128类型的重定位

## 总结

这个补丁是一个重要的安全修复，解决了RISC-V模块加载系统中的关键问题：

1. **并发安全**: 通过移除全局变量，支持多线程并发模块加载
2. **内存安全**: 使用安全的链表遍历，防止use-after-free漏洞
3. **错误处理**: 完善的内存分配失败处理机制
4. **代码质量**: 将函数标记为static，改善封装性

该修复对于在多核RISC-V系统上运行的Linux内核至关重要，确保了模块加载的稳定性和安全性。补丁的设计遵循了Linux内核的最佳实践，是一个高质量的安全修复。